<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>电路杂谈</title>
    <link href="/2025/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%94%B5%E8%B7%AF%E6%9D%82%E8%B0%88/"/>
    <url>/2025/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%94%B5%E8%B7%AF%E6%9D%82%E8%B0%88/</url>
    
    <content type="html"><![CDATA[<h1 id="电路">1 电路</h1><p><strong>电路</strong>，也称<strong><em>电气回路</em></strong>、<strong><em>回路</em></strong>、<strong><em>闭合回路</em></strong>、<strong><em>Electrical Circuit</em></strong>。一般由一下构件组成：</p><ul><li>电压源：提供电能</li><li>用电器：消耗电能</li><li>导线：传递电荷</li></ul><p><strong>电路组件</strong>以特定的联结方式与电压源相联结，组成闭合回路。</p><p>组件的联结方式有以下两种：</p><ul><li>串联电路：即加电源的单一回路。电源的一端接在一个组件的头，此组件的尾接在另一组件的头</li><li>并联电路：电路中将两个或两个以上的组件的一端接在一处，另一端亦接与一处</li></ul><p>电路分类：</p><ol type="1"><li><p>电子电路</p><ul><li><p>模拟电路：将<strong>连续性物理自然量</strong>转换为<strong>连续性电信号</strong>，并运算连续性电信号的电路称为模拟电路</p></li><li><p>数字电路：将<strong>连续性电信号</strong>转换为<strong>不连续性定量电信号</strong>，并运算不连续性定量电信号的电路称为数字电路</p></li></ul></li><li><p>集成电路：运用IC设计技术，将一般电路设计到半导体材料里的半导体电路，称为集成电路（IC）</p></li></ol><p>电路定律：</p><p>所有电路均遵循的一些基本电路定律：</p><ol type="1"><li>基尔霍夫电流定律</li><li>基尔霍夫电压定律</li><li>欧姆定律</li></ol><p>仅适用于线性电路：</p><ol type="1"><li>诺顿定理</li><li>戴维宁定理</li></ol><h1 id="电压">2 电压</h1><p>电压，也称<strong><em>电势差</em></strong>、<strong><em>电位差</em></strong>、<strong><em>Voltage</em></strong>。</p><p>定义：将一库伦的试探电荷从一点移动到另一点所需的能量</p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机组成原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Pytorch 简明教程</title>
    <link href="/2025/04/24/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/PyTorch%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"/>
    <url>/2025/04/24/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/PyTorch%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="一tensor">一、Tensor</h1><h2 id="性质-features">性质 | Features</h2><ul><li><p><code>tensor</code> 是一个特殊的数据结构，与 <code>array</code>和 <code>matrix</code> 类似</p></li><li><p>常见用法：在 PyToch中，用<code>tensor</code>来编码模型的<code>input</code> ,<code>output</code> 和 <code>paramater</code></p></li><li><p>区别：与 NumPy 中的 <code>ndarray</code> 相似，唯一不同的就是<code>tensor</code> 可以跑在 GPUs 以及其他硬件加速器上面</p></li><li><p>Bridge with NumPy：<code>tensor</code> 与 <code>ndarray</code>可以用过共享内存的方式直接转换，而省去了 <code>copy</code>这一操作</p></li><li><p>自微分优化： <code>tensor</code> 可以<code>automatic differentiation</code></p></li></ul><h2 id="创建-initialization">创建 | Initialization</h2><ul><li>从数据：<code>torch.tensor(data)</code></li><li>从NumPy ndarray：<code>torch.from_numpy(np_array)</code></li><li>从其他Tensor：<code>torch.ones_like(tensor)</code></li><li>随机数创建：<code>torch.rand()</code></li><li>常数创建：<code>torch.ones()</code>，<code>torch.zeros()</code></li></ul><h2 id="属性-attributes">属性 | Attributes</h2><ul><li><code>shape</code>：描述 tensor 形状</li><li><code>dtype</code>：描述 tensor 数据类型</li><li><code>device</code>：描述 tensor 运行设备</li></ul><h2 id="操作-operations">操作 | Operations</h2><ol type="1"><li>所有的<code>1200+</code>个操作，都支持在不同的设备上运行</li><li>默认的 <code>tensor</code> 存储在CPU上，转存其他设备用<code>tensor.to()</code> 方法</li><li>转存 <code>tensor</code> 费时费内存</li></ol><ul><li>Standard numpy-like indexing and slicing</li><li>Joining tensors</li><li>Arithmetic operations</li><li>In-place operations：add suffix <code>_</code> to method names ofoperations</li></ul><h2 id="桥接-bridge-with-numpy">桥接 | Bridge with NumPy</h2><ul><li>Tensor to NumPy array：<code>tensor.numpy()</code></li><li>NumPy array to Tensor：<code>tensor.from_numpy()</code></li></ul><h1 id="二datasets-dataloaders">二、Datasets &amp; DataLoaders</h1><blockquote><p>通常处理 data sample的操作代码<strong>十分繁琐</strong>并且<strong>难以维护</strong>，为了将 dataset code 从 training code部分解耦出来，提升其可读性和模块化程度。</p><p>PyTorch 提供了两个基本构件(primitives)：</p><ul><li><code>torch.utils.data.Dataset</code></li><li><code>torch.utils.data.DataLoader</code></li></ul></blockquote><h2 id="自定义-customized-datasets">自定义 | Customized Datasets</h2><p>官方示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">from</span> torchvison.io <span class="hljs-keyword">import</span> read_image<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomImageDataset</span>(<span class="hljs-title class_ inherited__">Dataset</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, annotations_file, img_dir, transform=<span class="hljs-literal">None</span>, target_transform=<span class="hljs-literal">None</span></span>):<br>        <span class="hljs-variable language_">self</span>.img_labels = pd.read_csv(annotations_file)<br>        <span class="hljs-variable language_">self</span>.img_dir = img_dir<br>        <span class="hljs-variable language_">self</span>.transform = transform<br>        <span class="hljs-variable language_">self</span>.target_transform = target_transform<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(img_labels)<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getitem__</span>(<span class="hljs-params">self, idx</span>):<br>        img_path = os.path.join(<span class="hljs-variable language_">self</span>.img_dir, <span class="hljs-variable language_">self</span>.img_labels.iloc[idx, <span class="hljs-number">0</span>]) <br>        img = read_image(img_path)<br>        label = <span class="hljs-variable language_">self</span>.img_labels.iloc[idx, <span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.transform：<br>        img = <span class="hljs-variable language_">self</span>.transform(img)<br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.target_transform:<br>            label = <span class="hljs-variable language_">self</span>.target_transform(label)<br>        <span class="hljs-keyword">return</span> img, label<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>安装实践 #3 ISE 14.7</title>
    <link href="/2025/04/07/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/ISE%2014.7%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
    <url>/2025/04/07/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/ISE%2014.7%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="官方下载器安装">1 官方下载器安装</h1><p>（1）访问 AMD Xilinx 官网，下载 ISE 14.7 的完整安装包 <ahref="https://www.xilinx.com/member/forms/download/xef.html?filename=Xilinx_ISE_DS_Lin_14.7_1015_1.tar">Fullinstaller for Linux (TAR/GZIP)</a></p><p>（2）将下载好的压缩包 <code>Xilinx_ISE_DS_Lin_14.7_1015_1.tar</code>解压到非中文目录</p><p>（3）执行解压好的安装包里面的安装程序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> Xilinx_ISE_DS_Lin_14.7_1015_1<br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">chmod</span> +x xsetup     <span class="hljs-comment">#当前sudo用户下给xsetup文件添加执行权限</span><br><span class="hljs-built_in">sudo</span> ./xsetup            <span class="hljs-comment">#进行安装</span><br></code></pre></td></tr></table></figure><p>（4）在弹出的可视化的安装程序中，选择<code>ISE Design Suite System Edition</code></p><p>（5）在官方下载程序里面下载 Cable Driver 通常会失败。</p><p>原因：由于ISE的cabledriver需要使用windrvr6模块，而该模块不支持较新的linux内核，所以不能使用官方的方式安装驱动。需要使用网上的开源代码安装驱动。</p><p>（6）安装完成后，会默认安装在 <code>/opt/Xilinx/</code> 目录下</p><h1 id="设置桌面快捷方式">2 设置桌面快捷方式</h1><p>（1）通过官方的 <code>installer</code> 安装 ISE14.7，默认是不会有快捷启动方式的。</p><p>（2）编写 ISE 14.7 启动脚本 <code>ise14.7_start.sh</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-built_in">source</span> /opt/Xilinx/14.7/ISE_DS/settings64.sh<br><span class="hljs-built_in">export</span> LD_PRELOAD=/opt/Xilinx/usb-driver/libusb-driver.so //替换为你编译好的驱动路径（见解决Cable Driver问题部分）<br>ise <span class="hljs-string">&quot;<span class="hljs-variable">$2</span>&quot;</span><br></code></pre></td></tr></table></figure><p>将其存放到你自定义的目录下（如：<code>~/Documents/MyScript/ise14.7_start.sh</code>），并添加执行权限</p><p>（3）编辑一个新的 <code>Desktop Entry</code> 文件（这是 GNOME环境，配置桌面快捷启动方式的入口文件）</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[Desktop Entry]</span><br><span class="hljs-attr">Name</span>=ISE <span class="hljs-number">14.7</span><br><span class="hljs-attr">Exec</span>=/path/to/your/ise14.<span class="hljs-number">7</span>_start.sh /opt/Xilinx/<span class="hljs-number">14.7</span>/ISE_DS/ %f<br><span class="hljs-attr">Icon</span>=/opt/Xilinx/<span class="hljs-number">14.7</span>/ISE_DS/ISE/data/images/pn-ise.png<br><span class="hljs-attr">StartupWMClass</span>=_np//解决窗口活动问题。只要设置了正确的WMClass，启动应用就会在图标旁边加点来表示活动。<br><span class="hljs-attr">Type</span>=Application<br></code></pre></td></tr></table></figure><p>保存为 <code>ise.desktop</code>文件，可以暂时保存到桌面，然后右键设置该文件的属性，添加执行权限，允许Launch</p><p>如果该文件图标还是不可执行，应该是 <code>desktop</code> 文件中的<code>Exec</code> 值中的参数 <code>/opt/Xilinx/...</code> 的问题</p><p>官方 <code>installer</code> 将 ISE 安装在 <code>/opt/Xilinx</code>这个路径下，所有者都是 <code>root</code></p><p>而刚才写的 <code>ise.desktop</code>文件，所有者是你当前登陆的用户。</p><p>所以，当然不能在用户级别的 <code>desktop</code>文件中去启动一个系统级的脚本</p><p>我的解决办法是，改 <code>/opt/Xilinx</code> 的权限（注：如果desktop文件语法没有问题，但还是无法启动，一般是路径权限问题）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chown</span> -R /opt/Xilinx username:username<br></code></pre></td></tr></table></figure><p>当图标状态改变为可执行时，可以 <code>ise.desktop</code> 放在<code>~/.local/share/applications/</code> 这个目录下，系统会自动识别</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mv</span> ise.desktop ~/.local/share/applications/<br></code></pre></td></tr></table></figure><h1 id="解决cable-driver问题">3 解决Cable Driver问题</h1><blockquote><p>原因：由于ISE的cabledriver需要使用windrvr6模块，而该模块不支持较新的linux内核，所以不能使用官方的方式安装驱动。需要使用网上的开源代码安装驱动。</p></blockquote><p>（1）安装驱动所需的依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt install libusb-dev libftdi-dev build-essential libc6-dev fxload<br></code></pre></td></tr></table></figure><ul><li>libusb-dev</li><li>libftdi-dev</li><li>build-essential：C/C++ 环境，接下来需要编译 git 上找的驱动库</li><li>libc6-dev</li><li>fxload</li></ul><p>（2）判断你的下载器类型</p><ul><li><p>如果你的FPGA下载器是 Xilinx 自家的 PlatformCable，直接进行步骤（3）</p></li><li><p>如果你的FPGA下载器是 Digilent 的 JTAG HS3，它是基于 FT232方案的（开源的一般都是这个）。请仔细阅读 git 库里面的 README 文档。最后面有基于 FT232 的方案。</p></li></ul><p>如何判断：</p><p>下载器连接PC正常后，执行以下命名，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> lsusb<br></code></pre></td></tr></table></figure><p>然后找到对应的USB端口，后面有公司名称。</p><p>（3）下载并编译 Cable Driver（建议 git 到非中文目录，如：我直接拉取在<code>/opt/Xilinx/usb-driver</code>）</p><p>git 库地址：<ahref="https://github.com/JohnDMcMaster/xilinx-usb-driver">https://github.com/JohnDMcMaster/xilinx-usb-driver</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> git://git.zerfleddert.de/usb-driver<br><span class="hljs-built_in">cd</span> /path/to/your/usb-driver<br>make<br></code></pre></td></tr></table></figure><p>编译完成后可能会弹出 Warnning，可以忽略</p><p>（4）通过设置文件<code>your/path/usb-driver/setup_pcusb</code>，安装编译好的驱动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> ./setup_pcusb /opt/Xilinx/14.7/ISE_DS/ISE/<br></code></pre></td></tr></table></figure><p>（5）重启 <code>udevadm</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> udevadm control --reload-rules<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>最佳实践</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法笔记</title>
    <link href="/2025/03/29/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    <url>/2025/03/29/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="一线性规划">一、线性规划</h1><p>问题： <span class="math display">\[\min Z=CX\\s.t.\left\{\begin{array}{}AX=b \\X\gt0\end{array}\right.\]</span></p><h2 id="单纯形算法">单纯形算法</h2>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机体系架构</title>
    <link href="/2025/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/"/>
    <url>/2025/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="指令集架构">指令集架构</h1><h2 id="x86-64">x86-64</h2><h2 id="arm">ARM</h2><p>Advanced RISC Machines</p><h2 id="risc-v">RISC-V</h2><p>Reduced Instruction Set Computer</p><h2 id="mips">MIPS</h2><p>Microprocessor without Interlocked Pipeline Stages</p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机组成原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>FPGA 产品分析</title>
    <link href="/2025/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/FPGA/FPGA%E4%BA%A7%E5%93%81%E5%88%86%E6%9E%90/"/>
    <url>/2025/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/FPGA/FPGA%E4%BA%A7%E5%93%81%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="xilinx">Xilinx</h1><p>AMD 旗下 Xlinx 公司有6个系列的在售FPGA芯片</p><ul><li>Spartan|低端|2009</li><li>Artix|中低端</li><li>Kintex|中端</li><li>Virtex|高端</li><li>Zynq|SoC</li><li>Versal</li></ul><h1 id="altera">Altera</h1><ul><li>Stratix|high-end</li><li>Arria|mid-range</li><li>Cyclone|lower-cost</li><li>Agilex</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机技术</category>
      
      <category>FPGA</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>NumPy</title>
    <link href="/2025/03/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/NumPy/"/>
    <url>/2025/03/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/NumPy/</url>
    
    <content type="html"><![CDATA[<h1 id="一简介">一、简介</h1><p><strong>NumPy</strong> 是一个Python语言的扩展程序库，前身是Numeric。</p><p>特点：</p><ol type="1"><li>支持高阶大规模数组 <code>ndarray</code>，并提供矩阵运算。</li><li>针对数组运算，提供大量的数学函数</li></ol><h1 id="二ndarray">二、ndarray</h1><h2 id="构成">构成</h2><p>类似C语言中的结构体，ndarray 对象由以下4部分组成：</p><ol type="1"><li>一个指向数据的指针</li><li>一个dtype对象：描述数组中固定大小的值</li><li>一个数组形状（shape）tuple：描述维度数</li><li>一个数组跨度（stride）tuple：描述在当前维度，当前元素前进到下一个元素所需”跨越“的字节数</li></ol><h2 id="创建">创建</h2><ul><li><p><code>np.array()</code> 函数返回一个 <code>ndarray</code>对象</p><p>参数：</p><ul><li><code>object</code></li><li><code>dtype</code></li><li><code>copy</code></li><li><code>order</code></li><li><code>subok</code></li><li><code>ndmin</code></li></ul></li><li><p><code>np.empty()</code></p></li><li><p><code>np.zeros(shape)</code></p></li><li><p><code>np.ones(shape)</code></p></li><li><p><code>np.full(shape, val)</code></p></li><li><p><code>np.zeros_like()</code></p></li><li><p><code>np.ones_like()</code></p></li><li><p><code>np.eye()</code>：创建单位矩阵，对角为1</p></li><li><p><code>np.asarray()</code></p></li><li><p><code>np.frombuffer(buffer)</code>：从内存缓冲区<code>buffer</code> 创建数组，与缓冲区 <code>buffer</code>共享内存。高效，迅速</p></li><li><p><code>np.fromiter</code></p></li></ul><h2 id="数据类型dtype">数据类型|dtype</h2><ul><li><code>bool_</code></li><li><code>int_</code>：默认类型，与 C 语言中的 <code>long</code>一致</li><li><code>intc</code>：与 C 语言中的 <code>int</code> 一致</li><li><code>intp</code></li><li><code>int8</code></li><li><code>int16</code></li><li><code>int32</code></li><li><code>int64</code></li><li><code>uint8</code></li><li><code>uint16</code></li><li><code>uint32</code></li><li><code>uint64</code></li><li><code>float_</code>：<code>float64</code> 简写</li><li><code>float16</code></li><li><code>float32</code></li><li><code>float64</code></li><li><code>complex_</code>：<code>complex128</code> 简写</li><li><code>complex64</code></li><li><code>complex128</code></li></ul><h2 id="索引indexing">索引|Indexing</h2><h2 id="切片slice">切片|Slice</h2><h2 id="广播broadcasting">广播|Broadcasting</h2><h1 id="三数据运算">三、数据运算</h1><p>## 数学函数</p><p>都是<strong>逐项计算</strong>函数，输入<code>ndarray</code>，返回也是<code>ndarray</code></p><ul><li><code>np.sin()</code></li><li><code>np.cos()</code></li><li><code>np.tan()</code></li><li><code>np.arcsin()</code></li><li><code>np.arccos()</code></li><li><code>np.arctan()</code></li><li><code>np.around(a,decimals)</code></li><li><code>np.degrees()</code></li><li><code>np.floor()</code></li><li><code>np.ceil()</code></li><li><code>np.exp()</code>：指数函数</li><li><code>np.maximum()</code>：最大值函数</li><li><code>np.minimum()</code>：最小值函数</li></ul><h2 id="算术函数">算术函数</h2><ul><li><code>np.add()</code></li><li><code>np.subtract()</code></li><li><code>np.multiply()</code></li><li><code>np.divide()</code></li><li><code>np.reciprocal()</code></li><li><code>np.power(a,b)</code></li><li><code>np.mod()</code></li></ul><h2 id="统计函数">统计函数</h2><ul><li><code>np.amin()</code></li><li><code>np.amax()</code></li><li><code>np.ptp()</code></li><li><code>np.median()</code>：返回中值（中位数）</li><li><code>np.mean()</code>：返回算术平均数</li><li><code>np.average()</code>：返回加权平均数</li><li><code>np.sum()</code>：求和</li></ul><h1 id="四矩阵计算">四、矩阵计算</h1><p><code>np.dot(a,b,out)</code>：</p><p>对于一维数组，做向量点积；</p><p>对于二维数组，做矩阵乘积；</p><p>对于多维数组，即结果数组中的每个元素都是：数组a的最后一维上的所有元素与数组b的倒数第二位上的所有元素的乘积和</p><p><code>np.vdot()</code>：</p><p>返回两个向量的点积，如果第一个参数是复数，那么它的共轭复数会用于计算。如果参数是多维数组，它会被展开。</p><p><code>np.inner()</code></p><p>返回一维数组的向量内积。对于更高的维度，它返回最后一个轴上的和的乘积。</p><p><code>np.matmul()</code></p><p>对于二维数组，作矩阵乘积。</p><p>如果任一参数的维数大于2，则将其视为存在于最后两个索引的矩阵的栈，并进行相应广播。</p><p>如果任一参数是一维数组，则通过在其维度上附加 1来将其提升为矩阵，并在乘法之后被去除。</p><p><code>np.det()</code></p><p>计算矩阵的行列式</p><p><code>np.inv()</code></p><p>返回矩阵乘法的逆矩阵</p><h1 id="五其他技巧">五、其他技巧</h1><h2 id="持久化">持久化</h2><ul><li><code>np.save(filename, arr)</code>：将数组 <code>arr</code>保存到文件</li><li><code>np.load(filename)</code>：从 <code>filename</code>读书数组，返回数组</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机技术</category>
      
      <category>编程语言</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>神经网络基础</title>
    <link href="/2025/03/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    <url>/2025/03/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="cross-entropy-loss">Cross-Entropy Loss</h2><p><span class="math display">\[J(W)=\frac{1}{m}\sum^{m-1}_{i=0}\sum^{n-1}_{j=0} y_{ij}\log(\hat y_{ij})\]</span></p><h2 id="backpropagation">Backpropagation</h2><p>denote:</p><p>每层的误差项 <span class="math inline">\(\delta\)</span>表示的是一个误差<strong>向量</strong>，每层之间连接的权重 <spanclass="math inline">\(W\)</span>表示的是一个权重<strong>矩阵</strong></p><p><strong>误差项</strong>在反向传播中的递推关系：</p><p>（1）输出层与上一层： <span class="math display">\[\delta^L=\nabla_{a^L}C\circ \sigma&#39;(z^L)\]</span> （2）<span class="math inline">\(l\)</span> 层与 <spanclass="math inline">\(l+1\)</span> 层 <span class="math display">\[\delta^{l}=(W^{l+1})^T\delta^{l+1}\circ\sigma&#39;(z^l)\]</span> 根据 Stochastic Gradient Descent方法，通过<strong>误差项</strong>来修正权重与偏置：</p><p>（1）权重 <span class="math display">\[\frac{\partial C}{\partial W^l_{jk}}=\delta^l_j\cdot a^{l-1}_{k}\]</span> （2）偏置 <span class="math display">\[\frac{\partial C}{\partial b^{l}_j}=\delta^l_j\]</span></p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LeNet5</title>
    <link href="/2025/03/03/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/LeNet/"/>
    <url>/2025/03/03/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/LeNet/</url>
    
    <content type="html"><![CDATA[<h1 id="architecture">Architecture</h1><ul><li>Every convolutional layer includes three parts: <strong>convolution,pooling and nonlinear activation functions</strong></li><li>Using convolution to extract spatial features(Convolution was called<strong>receptive fields</strong> originally)</li><li>Subsampling average pooling layer</li><li>tanh activation function</li><li>fully connected layers in the final layers for classification</li><li>Sparse connection between layers to reduce the complexity ofcomputation</li></ul><p>the meaning of convolution:</p><ul><li>Local receptive fields | 局部感知</li><li>Shared weights | 共享权重</li><li>Translation invariance | 平移不变性</li></ul>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>迭代算法</title>
    <link href="/2025/03/03/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E8%BF%AD%E4%BB%A3%E7%AE%97%E6%B3%95/"/>
    <url>/2025/03/03/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E8%BF%AD%E4%BB%A3%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<ul><li><p>Monte Carlo Methods</p></li><li><p>FFT（Fast Fourier Transform）</p></li><li><p>Backpropagation</p></li><li><p>Power Iteration</p></li><li><p>K-means Clustering</p></li><li><p>PageRank</p></li><li><p>Jacobi and Gauss-Seidel Iterations</p></li><li><p>Genetic Method</p></li><li><p>Newton-Raphson Method</p></li><li><p>Conjugate Gradient Method</p></li><li><p>Gradient Descent</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>深度学习 课程笔记</title>
    <link href="/2025/03/01/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/YOLO%E7%B3%BB%E5%88%97%E8%A7%A3%E8%AF%BB%20#1%20YOLOv1/"/>
    <url>/2025/03/01/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/YOLO%E7%B3%BB%E5%88%97%E8%A7%A3%E8%AF%BB%20#1%20YOLOv1/</url>
    
    <content type="html"><![CDATA[<h1 id="引言">1 引言</h1>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Machine Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深度学习 课程笔记</title>
    <link href="/2025/03/01/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0_%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    <url>/2025/03/01/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0_%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="优化器optimizer">优化器|Optimizer</h1><h2 id="sgd">SGD</h2><p>概念：SGD(Stochastic Gradient Descent)，每次更新权重只用小批次(minibatch)的样本梯度，而不是整个数据集的梯度。</p><p>公式： <span class="math display">\[\theta=\theta-\alpha\cdot\nabla J\]</span></p><p>优点：</p><ul><li>计算量小</li><li>可以频繁更新，加快训练速度</li></ul><p>缺点：</p><ul><li>更新不稳定，可能导致震荡，不容易收敛</li><li>需要调整学习率</li></ul><h2 id="sgd-with-momentum">SGD With Momentum</h2><p>概念：受物理世界启发，在更新参数时，加入动量，i.e. 积累历史梯度。</p><p>公式： <span class="math display">\[v_t=\beta\,v_{t-1}+(1-\beta)\nabla J\\\theta=\theta-\alpha v_t\]</span> 其中：<span class="math inline">\(\beta\)</span>是动量衰减因子，通常取0.9</p><p>优点：</p><ul><li>下降更快</li><li>容易跳出局部极小值</li><li>减小震荡次数</li><li>提高收敛速度</li></ul><p>缺点：</p><ul><li>需要调节衰减因子和学习率</li></ul><h2 id="adagrad">Adagrad</h2><p>概念：Adagrad(Adaptive GradientAlgorithm)，是一种自适应优化算法，会根据每个参数的历史梯度调整学习率。</p><p>公式： <span class="math display">\[\theta=\theta-\frac{\alpha}{\sqrt{G_t+\epsilon}}\cdot \nabla J\]</span></p><p>优点：</p><p>缺点：</p><h2 id="rmsprop">RMSprop</h2><p>概念：</p><h2 id="adam">Adam</h2><p>概念：Adam(Adaptive Momentum Estimation)，是 Momentum 与 RMSprop的结合</p><h2 id="nadam">Nadam</h2><h1 id="激活函数activation-function">激活函数|Activation Function</h1><h1 id="正则化regularization">正则化|Regularization</h1><p>（1）神经网络训练方式</p><ul><li>批量训练：一次性求出最小值并不好求，利用计算机用迭代计算</li><li>mini batch</li><li>随机梯度下降：每个 epoch随机选一个样本，在样本向前传播完之后，马上调整权重和偏置</li></ul><p>（2）常用激活函数|Activation Function</p><ul><li>Sigmoid Function</li><li>tanh Function</li><li>ReLu Function</li><li>Leaky ReLu</li></ul><p>（3）激活函数性质</p><ul><li>非线性</li><li>可微性</li><li>单调性</li><li><span class="math inline">\(f(x)\approx x\)</span></li><li>计算简单</li><li>归一化</li><li>输出值范围</li></ul><p>（4）损失代价函数|Loss or Cost Function</p><p>一般按照<strong>最小均方误差 MSE</strong> 原则 <spanclass="math display">\[J(w)=\sum_{\text{sample}}\sum_{i=1}^n (\hat{y}_i-y_i)^2\]</span> （5）常见的损失代价函数</p><ul><li>Sigmoid</li><li>Moon Loss</li><li>Triplet Loss</li><li>Contrastive Loss</li><li>Cross-Entropy Loss</li></ul><p>（6）防止过拟合|Overfitting</p><ul><li>参数范数惩罚：正则化：L1正则化，L2正则化</li><li>数据增强</li><li>Early Stopping（提前终止）</li><li>Bagging 集成</li><li>Dropout（漏失）</li><li>批正则化</li></ul><p>（7）防止过拟合——惩罚性成本函数</p><p>在 Cost Function中加上<strong>惩罚项</strong>，下面的例子是加上<strong>网络权重的平方和</strong></p><p>该方法类似于<strong>岭回归</strong></p><p>这种方法也叫 <strong><span class="math inline">\(L_2\)</span>正则化</strong> <span class="math display">\[J(w)=\frac{1}{2n}\sum_{i=1}^n(\hat{y}_i-y_i)^2+\lambda\sum_{j=1}^mW_j^2\]</span> （8）防止过拟合——漏失|Dropout</p><p>在训练的每一个迭代（批次），依概率漏掉一些神经元子集。</p><p>（9）提前停止|Early Stopping</p><p>比如：</p><p>对训练样本进行10个 epoch 之后，对测试样本观察损失函数</p><ol type="1"><li>损失下降，继续训练</li><li>损失上升，停止训练</li></ol><p>（10）动量|Momentum</p><p>概念：每次仅略微改变方向</p><p>保持步进方向的连续平均数，消除个别点的变化。 <spanclass="math display">\[v_t\coloneqq\eta \cdot v_{t-1}-\alpha\cdot\nabla J\\W\coloneqq W-v_t\]</span> <span class="math inline">\(\eta\)</span> 表示动量（decayrate），通常小于1</p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Machine Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多元微积分 #3 多元函数的极限</title>
    <link href="/2025/01/19/%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86_3_%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E6%9E%81%E9%99%90/"/>
    <url>/2025/01/19/%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86_3_%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E6%9E%81%E9%99%90/</url>
    
    <content type="html"><![CDATA[<h1 id="课堂笔记">课堂笔记</h1><p>（1）极限为什么在去心领域内讨论呢？</p><ul><li><p>极限是一个过程。</p></li><li><p>在大部分讨论极限的场合，函数在目标点一般是无定义的。</p><p>比如，研究 <span class="math inline">\(f&#39;(x)\)</span>，差商函数<span class="math inline">\(g(x)=\frac{f(x)-f(x_0)}{x-x_0}\)</span> 在<span class="math inline">\(x_0\)</span> 点显然无定义。</p></li></ul><p><span class="math display">\[f&#39;(x)=\lim_{x\to x_0}\frac{f(x)-f(x_0)}{x-x_0}\]</span></p><p>（2）什么是<strong>聚点（AccumulationPoint）</strong>？（二维为例）</p><ul><li><p>聚点就是极限点，在点 <span class="math inline">\(x\)</span>任意逼近的邻域内，总能找到集合中与它不同的点（可以被逼近）</p></li><li><p>一个点 <span class="math inline">\(x\)</span>的任意邻域内都有集合 <span class="math inline">\(A\setminus\{x\}\)</span> 中的点</p></li><li><p>这个点 <span class="math inline">\(x\)</span> 是可以被 <spanclass="math inline">\(A\)</span> 逼近的，<spanclass="math inline">\(x\)</span> 可以不在集合 <spanclass="math inline">\(A\)</span> 内</p></li><li><p>形式化定义：</p><p><span class="math inline">\((x_0,y_0)\)</span> 是平面区域 <spanclass="math inline">\(D\in\mathbb{R}^2\)</span> 的聚点，则 <spanclass="math display">\[(\forall \delta\gt0)\,(\mathring{U}((x_0,y_0),\delta)\capD\ne\varnothing)\]</span></p></li><li><p>再看一维例子：开区间 <span class="math inline">\((0,1)\)</span>的聚点是 <span class="math inline">\(0,1\)</span></p></li><li><p>聚点性质：可以不属于集合</p></li></ul><p>（3）为了定义多元函数极限，需要做哪两个准备？</p><ol type="1"><li>范数（绝对值的推广，距离的度量）</li><li>聚点（可逼近）</li></ol><h1 id="定义definition">定义|Definition</h1><p>设二元函数 <span class="math inline">\(f(P)=f(x,y)\)</span>的定义域为 <span class="math inline">\(D\)</span>，<spanclass="math inline">\(P_0(x_0,y_0)\)</span> 是 <spanclass="math inline">\(D\)</span> 的聚点。</p><p>如果存在 <span class="math inline">\(A\)</span> ，对于任意的 <spanclass="math inline">\(\varepsilon\gt0\)</span>，存在 <spanclass="math inline">\(\exist\delta\gt0\)</span> ，使得 <spanclass="math inline">\(P(x,y)\in D\cap\mathring{U}\{P_0,\delta\}\)</span>时，都有 <span class="math display">\[|f(P)-A|=|f(x,y)-A|\lt\varepsilon\]</span> 也记作 <span class="math display">\[\lim_{(x,y)\to(x_0,y_0)} f(x,y)=A\]</span></p><h1 id="定理theorem">定理|Theorem</h1><p style="text-align: center;font-size: 2em">二重极限的向量序列刻画：离散化</p><p>对于<strong>一元情况</strong>，已知： <span class="math display">\[\{x_n\}\in D,\,\lim_{n\to x_0}x_n=x_0\]</span> 若 <span class="math inline">\(x_n\to x_0\)</span>，有<strong>定理1</strong>： <span class="math display">\[\lim_{x\to x_0}f(x)=A\iff \lim_{n\to\infty}f(x_n)=A\]</span></p><p>同样的，对于<strong>二元函数</strong>极限</p><p><span class="math display">\[\lim_{(x,y)\to(x_0,y_0)}f(x,y)=A\]</span> 若对于<strong>任意的向量序列</strong>，有 <spanclass="math inline">\((x_n,y_n)\to(x_0,y_0)\)</span>，则有<strong>定理2</strong>：<span class="math display">\[\lim_{(x,y)\to(x_0,y_0)}f(x,y)=A\iff\lim_{n\to\infty}f(x_n,y_n)=A\]</span></p><p>对二元情况作<strong>充分性</strong>证明：</p><p>已知二元极限，则翻译成定义即： <span class="math display">\[(\forall \varepsilon\gt0)\,(\exists\delta\gt0)\,(0\lt\|(x,y)-(x_0,y_0)\|\lt\delta\to |f(x,y)-A|\lt \varepsilon)\]</span> 再结合条件，任意向量序列 <spanclass="math inline">\((x_n,y_n)\to(x_0,y_0)\)</span>，翻译成数学语言即：<span class="math display">\[(\forall \delta\gt0)\,(\exists N\gt0)\,(n\gt N\to\|(x_n,y_n)-(x_0,y_0)\|\lt\delta )\]</span> 综上所述，可推导出数列极限 <span class="math display">\[(\forall\varepsilon\gt0)\,(\exists N \gt 0)\,(n\gt N\to|f(x_n,y_n)-A|\lt\varepsilon)\]</span></p><p>二元情况作<strong>必要性</strong>证明：（反证法）</p><h1 id="例题">例题</h1><p>（1）证明 <span class="math display">\[\lim_{(x,y)\to(0,0)}(x^2+y^2)\sin{\frac{1}{x^2+y^2}}=0\]</span></p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>高等数学</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>多元微积分 #1 向量序列的极限</title>
    <link href="/2025/01/18/%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86_2_%E5%90%91%E9%87%8F%E5%BA%8F%E5%88%97%E6%9E%81%E9%99%90/"/>
    <url>/2025/01/18/%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86_2_%E5%90%91%E9%87%8F%E5%BA%8F%E5%88%97%E6%9E%81%E9%99%90/</url>
    
    <content type="html"><![CDATA[<p style="text-align: center;font-size: 2em">向量序列的极限：空间中的向量的离散运动</p><h1 id="定义">定义</h1><p><span class="math display">\[\lim_{n\to\infty}(x_n,y_n)=(a,b)\iff\lim_{n\to\infty}x_n=a,\,\lim_{n\to\infty}y_n=b\\\iff (\forall \varepsilon\gt0)\,(\exist N(\varepsilon)\gt0)\, (\forallx_n)\,(\forall y_n)\,(n\gt N(\varepsilon)\implies\|(x_n,y_n)-(a,b)\|\lt\varepsilon)\]</span></p><h1 id="证明">证明</h1><h2 id="必要性">必要性</h2><p><span class="math display">\[\lim_{n\to\infty}(x_n,y_n)=(a,b)\implies\lim_{n\to\infty}x_n=a,\,\lim_{n\to\infty}y_n=b\]</span></p><p>由 <spanclass="math inline">\(\|(x_n,y_n)-(a,b)\|\lt\varepsilon\)</span> 可知<span class="math display">\[\sqrt{(x_n-a)^2+(y_n-b)^2}\lt\varepsilon\]</span> 因为直角三角形斜边大于直角边，则显然 <spanclass="math display">\[|x_n-a|\lt\varepsilon\text{ and }|y_n-b|\lt\varepsilon\]</span></p><h2 id="充分性">充分性</h2><p><span class="math display">\[\lim_{n\to\infty}x_n=a,\,\lim_{n\to\infty}y_n=b\implies\lim_{n\to\infty}(x_n,y_n)=(a,b)\]</span></p><p>由条件得 <span class="math display">\[(\forall \varepsilon\gt0)\,(\exists N_1\gt0)\,(n\gt N_1\implies|x_n-a|\lt\varepsilon)\\(\forall \varepsilon\gt0)\,(\exists N_2\gt0)\,(n\gt N_2\implies|y_n-b|\lt\varepsilon)\]</span> 令 <span class="math display">\[|x_n-a|\lt\frac{1}{3}\varepsilon,\ |y_n-b|\lt\frac{2}{3}\varepsilon\]</span> 上述条件同时成立，需满足 <span class="math display">\[n\gt\max\{N_1(\frac{1}{3}\varepsilon),N_2(\frac{2}{3}\varepsilon)\}\]</span> 则 <span class="math display">\[\|(x_n,y_n)-(a,b)\|\lt|x_n-a|+|y_n-b|\lt\varepsilon\]</span> 即 <span class="math display">\[(\forall \varepsilon\gt0)(\exist N\gt0)(n\gt N\implies\|(x_n,y_n)-(a,b)\|\lt \varepsilon)\]</span></p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>高等数学</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python #1 速览Guide</title>
    <link href="/2025/01/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/"/>
    <url>/2025/01/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/</url>
    
    <content type="html"><![CDATA[<h1 id="一标识符">一、标识符</h1><ul><li>由字母、数字、下划线组成</li><li>以字母或者下划线<code>_</code>开头</li><li>对大小写敏感</li></ul><h1 id="二数据类型">二、数据类型</h1><h2 id="数字number">数字|Number</h2><p>python 的数字包括：</p><ul><li>int（整数）</li><li>float（浮点数）</li><li>complex（复数）</li><li>bool（布尔值）</li></ul><h2 id="字符串string">字符串|String</h2><p><strong>特性：</strong></p><ul><li><p>不可改变</p></li><li><p>单引号<code>''</code>和双引号<code>""</code>的使用完全相同</p></li><li><p>三引号<code>''' '''</code>或者<code>""" """</code>，表示多行字符</p></li><li><p>反斜杠<code>\</code>转义</p></li><li><p><code>r</code>（raw）使转义失效</p></li><li><p>加号<code>+</code>连结字符串，星号<code>*</code>重复</p></li><li><p>两种索引方式：从左往右，<code>0</code>开始；从右往左，<code>-1</code>开始</p></li><li><p>没有单独的字符类型</p></li><li><p>字符串有切片：<code>str[start:end]</code>，结束索引<code>end</code>不包含在切片内</p></li><li><p>切片可以配步长：<code>str[start:end:step]</code></p></li></ul><p><strong>内建函数：</strong></p><ul><li><code>len(str)</code></li><li><code>max(str)</code></li><li><code>min(str)</code></li></ul><p><strong>内置方法：</strong></p><ul><li><code>count(str,beg=0,end=len(str))</code></li><li><code>title()</code>：返回标题化的字符串</li><li><code>capitalize()</code>：第一个字母大写</li><li><code>upper()</code>：返回大写化的字符串</li><li><code>lower()</code>：返回小写化的字符串</li><li><code>find(str,beg=0,end=len(str))</code>：返回指定范围内查找到的字符串的首索引</li><li><code>index(str,beg=0,end=len(str))</code>：同<code>find</code></li><li><code>swapcase()</code></li></ul><h2 id="列表list">列表|List</h2><blockquote><p>一个打了激素的数组</p></blockquote><p><strong>性质：</strong></p><ul><li>元素可重复</li><li>可包含任意数据类型</li><li>可嵌套</li><li>可切片</li><li>具备连接符<code>+</code>、重复符<code>*</code></li></ul><p><strong>删除列表：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">del</span> <span class="hljs-built_in">list</span><br></code></pre></td></tr></table></figure><p><strong>内置函数：</strong></p><ul><li><code>len(list)</code></li><li><code>max(list)</code></li><li><code>min(list)</code></li><li><code>list(seq)</code>：将元组转换成列表</li></ul><p><strong>内置方法</strong>：</p><ul><li><p><code>clear()</code></p></li><li><p><code>copy()</code></p></li><li><p><code>append(obj)</code></p></li><li><p><code>extend(iterable)</code>：通过<code>iterable</code>的所有项来扩展列表</p></li><li><p><code>count(obj)</code>：统计对象出现次数</p></li><li><p><code>pop([index])</code>：默认弹出最后一个对象</p></li><li><p><code>insert(index,obj)</code></p></li><li><p><code>remove(obj)</code>：移除第一个匹配的值，未找到时触发<code>ValueError</code></p></li><li><p><code>index(obj)</code>：返回第一个匹配的值的<strong>零基索引</strong>，也可制定范围</p></li><li><p><code>reverse()</code>：翻转列表</p></li><li><p><code>sort(*,key=None,reverse=False)</code>：就地排序列表</p></li></ul><h2 id="元组tuple">元组|Tuple</h2><p><strong>特性：</strong></p><ul><li>类似 <code>List</code></li><li>内存内容不可变</li></ul><p><strong>内建函数：</strong></p><ul><li><code>len(tuple)</code></li><li><code>max(tup)</code></li><li><code>min(tup)</code></li><li><code>tuple(iterable)</code>：将可迭代系列转换为元组</li></ul><h2 id="集合set">集合|Set</h2><p><strong>特性：</strong></p><ul><li><p>是序列（<code>seq</code>）</p></li><li><p>元素不重复</p></li><li><p>元素无顺序</p></li></ul><p><strong>内建函数：</strong></p><ul><li><code>len(set)</code>：计算集合元素个数</li></ul><p><strong>内置方法：</strong></p><ul><li><code>add(hashable)</code>：给集合添加一个<code>hasable</code>的元素</li><li><code>clear()</code></li><li><code>copy()</code></li><li><code>pop()</code>：随机移除一个元素</li><li><code>remove(obj)</code>：移除指定元素</li><li><code>discard(obj)</code>：删除制定元素</li><li><code>update(iterable)</code>：给集合添加可迭代的序列</li></ul><h2 id="字典dictionary">字典|Dictionary</h2><p><strong>特性：</strong></p><ul><li><p>键值可以是任意数据类型</p></li><li><p>键不可变</p></li><li><p>键唯一</p></li><li><p>创建空字典用<code>&#123;&#125;</code></p></li></ul><p><strong>内建函数：</strong></p><ul><li><code>len(dict)</code></li><li><code>str(dict)</code>：打印字典</li></ul><p><strong>内置方法：</strong></p><ul><li><code>key in dict</code>：判断 <code>key</code> 是否在词典中</li><li><code>copy()</code></li><li><code>clear()</code></li><li><code>items()</code></li><li><code>keys()</code></li><li><code>values()</code></li><li><code>fromkeys(seq)</code></li><li><code>setdefault(key,default=None)</code>：设置键的默认值，如果键值不存在，则添加键</li></ul><h2 id="注意">注意</h2><p>（1）不可变的数据类型：</p><ul><li>Number</li><li>String</li><li>Tuple</li></ul><p>（2）可变数据类型</p><ul><li>List</li><li>Set</li><li>Dictionary</li></ul><h1 id="三流程控制">三、流程控制</h1><p>python 没有 <code>switch...case</code> 语句，</p><h2 id="if-语句">if 语句</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> condition1 :<br>    statements...<br><span class="hljs-keyword">elif</span> condition2 :<br>    statements...<br><span class="hljs-keyword">elif</span> condition3 :<br>    statements...<br><span class="hljs-keyword">else</span><br>statements...<br></code></pre></td></tr></table></figure><h2 id="match-语句">match 语句</h2><ul><li><p>接受一个 <code>expression</code>，将它的 <code>value</code>同一系列的 <code>pattern</code> 比较。</p></li><li><p>只运行第一个匹配的代码块</p></li><li><p><code>pattern</code>可以解包赋值（<code>unpacking</code>）</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">match</span> expression :<br>    <span class="hljs-keyword">case</span> constant1 : <br>        statements...<br>    <span class="hljs-keyword">case</span> constant2 :<br>        <br>    <span class="hljs-keyword">case</span> constant3 :<br>    <br>    <span class="hljs-keyword">case</span> _ :<br>        deault statements<br></code></pre></td></tr></table></figure><h2 id="for-语句">for 语句</h2><p>Pascal 语言在仅仅在<strong>算数过程上</strong>进行迭代</p><p>C语言允许用户自定义<strong>迭代步骤</strong>和<strong>终止条件</strong></p><p>不同于其他高级语言：</p><ul><li><p>Python 的 <code>for</code> 语句是在任何 <code>iterable</code>对象的 <code>item</code> 上按顺序进行迭代</p></li><li><p>迭代对象可以是字符串或者 <code>List</code></p></li></ul><h2 id="range-函数">range() 函数</h2><p><strong>函数重载：</strong></p><ul><li><code>range(end)</code></li><li><code>range(start,end)</code></li><li><code>range(start,end,step)</code></li></ul><p><strong>特性：</strong></p><p><code>range()</code> 返回的 <code>object</code> 表现得像一个<code>list</code> ，但实际上不是 <code>list</code> 而是一个<code>iterable</code> 对象。也不是一个 <code>iterator</code> ，名叫<code>range</code>对象</p><p><code>sum()</code> 函数也是接受一个 <code>iterable</code> 对象</p><h2 id="loop-中的-else-子句">loop 中的 else 子句</h2><p>loop 中的 <code>else</code> 子句与 try 语句中的 <code>else</code>子句有异曲同工之妙：</p><blockquote><p>a <code>try</code> statement’s <code>else</code> clause runs when noexception occurs, a loop’s <code>else</code> clause runs when no<code>break</code> occurs.</p></blockquote><ul><li><p><code>loop</code> 中 <code>else</code> 子句一般与<code>break</code> 配对，用于表示 <code>loop</code>顺利结束之后执行的代码块</p></li><li><p>在 <code>for</code> 循环中，完成了最后的 <code>iteration</code>后执行 <code>else</code></p></li><li><p>在 <code>while</code> 循环中，<code>loop condition</code> 变为<code>false</code> 后执行</p></li><li><p><code>return</code> 发生不会执行 <code>else</code></p></li><li><p><code>Exceptions</code> 发生不会执行 <code>else</code></p></li></ul><h2 id="pass-语句">pass 语句</h2><ul><li><code>pass</code> 语句什么也不干</li><li>主要用于在需要语法上保持一致，但不需要执行什么任务的地方</li><li>用在 <code>busy-wait</code> 上，如等待键盘输入</li><li>用在 <code>create minimal class</code> 上</li><li>用在待补全的函数体上，占位</li></ul><h1 id="四语法功能">四、语法功能</h1><h2 id="多行语句">多行语句</h2><p>一条语句太长，分行写，用反斜杠 <code>\</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">a=<span class="hljs-number">1</span>+<span class="hljs-number">2</span> \<br>+<span class="hljs-number">3</span> \<br>+<span class="hljs-number">4</span><br><span class="hljs-built_in">print</span>(a)<br><br><span class="hljs-comment">#输出10</span><br></code></pre></td></tr></table></figure><h2 id="一行多句">一行多句</h2><p>一行写多条语句，用分号<code>;</code>分割</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">a=<span class="hljs-number">1</span>;a+=<span class="hljs-number">2</span>;<span class="hljs-built_in">print</span>(a)<span class="hljs-comment">#输出3</span><br></code></pre></td></tr></table></figure><h2 id="推导式comprehension">推导式|Comprehension</h2><blockquote><p>从一个数据序列构建另一个新的数据序列</p></blockquote><p><strong>内置支持的推导式：</strong></p><ul><li>列表推导式：<code>[表达式 for 变量 in 列表 if 过滤条件]</code></li><li>元组推导式：<code>(表达式 for item in seq if 过滤条件)</code>，返回的是生成器对象</li><li>集合推导式：<code>&#123;表达式 for item in seq if 过滤条件&#125;</code></li><li>字典推导式：<code>&#123;键表达式 : 值表达式 for 值 in 列表 if 过滤条件&#125;</code></li></ul><p><strong>嵌套的推导式：</strong></p><p>实现矩阵转置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">matrix=[<br>    [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],<br>    [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>],<br>    [<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>],<br>]<br><br>t=[ [ row[i] <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> matrix] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>)]<br></code></pre></td></tr></table></figure><h2 id="迭代器iterator">迭代器|Iterator</h2><ul><li><p>迭代是 Python最强大的功能之一，是访问集合元素的一种方式。</p></li><li><p>迭代器是一个可以记住遍历的位置的对象。</p></li><li><p>迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。</p></li><li><p>迭代器有两个基本的方法：<strong>iter()</strong> 和<strong>next()</strong>。</p></li><li><p>字符串，列表或元组对象都可用于创建迭代器</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br> <br><span class="hljs-keyword">import</span> sys         <span class="hljs-comment"># 引入 sys 模块</span><br> <br><span class="hljs-built_in">list</span>=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>it = <span class="hljs-built_in">iter</span>(<span class="hljs-built_in">list</span>)    <span class="hljs-comment"># 创建迭代器对象</span><br> <br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-built_in">print</span> (<span class="hljs-built_in">next</span>(it))<br>    <span class="hljs-keyword">except</span> StopIteration:<br>        sys.exit()<br></code></pre></td></tr></table></figure><h2 id="生成器generator">生成器|Generator</h2><p>代码组内部有 <code>yield</code>语句的函数是一个生成器（generator）</p><p>生成器函数是一种特殊的函数，可以在迭代过程中逐步产生值，而不是一次性返回所有结果。</p><p>跟普通函数不同的是，生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。</p><p>当在生成器函数中使用 <strong>yield</strong>语句时，函数的执行将会暂停，并将 <strong>yield</strong>后面的表达式作为当前迭代的值返回。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">countdown</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-keyword">while</span> n &gt; <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">yield</span> n<br>        n -= <span class="hljs-number">1</span><br> <br><span class="hljs-comment"># 创建生成器对象</span><br>generator = countdown(<span class="hljs-number">5</span>)<br> <br><span class="hljs-comment"># 通过迭代生成器获取值</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(generator))  <span class="hljs-comment"># 输出: 5</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(generator))  <span class="hljs-comment"># 输出: 4</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(generator))  <span class="hljs-comment"># 输出: 3</span><br> <br><span class="hljs-comment"># 使用 for 循环迭代生成器</span><br><span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> generator:<br>    <span class="hljs-built_in">print</span>(value)  <span class="hljs-comment"># 输出: 2 1</span><br></code></pre></td></tr></table></figure><h2 id="切片slice">切片|Slice</h2><ul><li>切片是一个强大的数据操作方式</li><li>可用于<code>str</code>，<code>list</code>，<code>tuple</code>等序列类型</li><li>实现高效的数据访问、数据修改、数据复制</li><li>切片返回的是新对象</li></ul><p><strong>切片赋值（仅支持列表）</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">list</span> = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br><span class="hljs-built_in">list</span>[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>] = [<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>)<br></code></pre></td></tr></table></figure><p>输出：[0, 2, 1, 3, 4]</p><p><strong>切片删除（仅支持列表）</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">list</span> = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br><span class="hljs-keyword">del</span> <span class="hljs-built_in">list</span>[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>)<br></code></pre></td></tr></table></figure><p>输出：[0, 3, 4]</p><h1 id="五函数">五、函数</h1><ul><li><code>procedure</code>：代码块</li><li><code>function</code>：函数有返回值</li><li><code>method</code>：属于 <code>object</code> 的<code>function</code></li></ul><h2 id="特性">特性</h2><ul><li>python 里面的函数都是 <code>function</code>，而不是<code>procedure</code> 尽管他没有任何返回值。</li><li>默认返回值是 <code>None</code></li></ul><h2 id="形式参数">形式参数</h2><p><strong>默认参数：</strong></p><ul><li>默认参数会在函数调用时被共享</li></ul><p><strong>特殊参数（Special Arguments）：</strong></p><ul><li><code>positional-or-keyword</code></li><li><code>positional-only</code>：用 <code>/</code> 分割</li><li><code>keyword-only</code>：用 <code>*</code> 分割</li></ul><p>关键字参数后面不能有位置参数</p><p><strong>任意参数（Arbitrary Arguments）：</strong></p><ul><li><p><code>*</code>用元组</p></li><li><p><code>**</code>用字典</p></li><li><p>在函数定义中，排在任意参数后面的参数，只能用<code>keyword arguments</code> 传入</p></li></ul><p><strong>解包参数列表（Unpaking Arguments List）：</strong></p><ul><li><code>*</code> ：解包 <code>list</code> 和<code>tuple</code></li><li><code>**</code>：<code>keyword</code> 解包<code>dictionary</code></li></ul><h2 id="lambda-表达式">lambda 表达式</h2><p>特征：</p><ul><li>Small</li><li>Anonymous</li><li>a single expression</li><li>是一个语法糖（syntatics sugar）</li><li>当需要一个函数对象时，lambda表达式就派上用场</li><li>可以当参数传入</li></ul><h1 id="六数据结构">六、数据结构</h1><h2 id="list实现栈">List实现栈</h2><p>两个<strong>内置方法</strong>实现栈的<strong>后进先出</strong>：</p><ul><li><code>list.pop([index])</code>：弹栈，若不指定<code>index</code>，默认返回列表最后一个元素</li><li><code>list.append(obj)</code>：进栈，在列表末尾添加元素<code>obj</code></li></ul><h2 id="队列的实现">队列的实现</h2><p>用 <code>collections.deque</code>实现快速从两端添加或删除元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque<br><br>queue=deque([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>])<br><br>queue.append(<span class="hljs-number">5</span>)    <span class="hljs-comment"># 5到了</span><br>queue.append(<span class="hljs-number">6</span>)   <span class="hljs-comment"># 6到了</span><br>queue.popleft()    <span class="hljs-comment"># 1出队</span><br>queue.popleft()    <span class="hljs-comment"># 2出队</span><br></code></pre></td></tr></table></figure><h1 id="七模块">七、模块</h1><h2 id="模块导入">模块导入</h2><p><strong>特性：</strong></p><ul><li><code>module</code> 如果有<code>excutable statements</code>，在导入时执行一次，用来初始化模块</li><li>以 <code>_</code> 开头的函数，不会被导入</li><li><code>module</code> 在每个 <code>interpreter session</code>只会被导入一次</li></ul><p><strong>变种：</strong></p><ul><li><code>import somemodule</code>：导入整个模块</li><li><code>from somemodule import func1,func2</code>：从某个模块导入函数，（并加入到当前的命名空间）</li></ul><h2 id="搜索路径">搜索路径</h2><ul><li><code>sys.builtin_module_names</code>：内置模块</li><li><code>sys.path</code>：可以被修改，初始化为以下三种<ul><li><code>current directory</code></li><li><code>PYTHONPATH</code></li><li><code>installation dependent default</code> ：通常包含<code>site-packages</code></li></ul></li></ul><h2 id="compiled-python-file">Compiled Python File</h2><ul><li>存储在 <code>__pycache__/module.version.pyc</code> 路径下</li><li><code>pyc</code> 比 <code>py</code> 快在装载速度上</li></ul><h1 id="八输入输出">八、输入输出</h1><h2 id="输出格式">输出格式</h2><p><strong>输出的3种方法：</strong></p><ul><li><code>expression statements</code></li><li><code>print()</code> 函数</li><li><code>fileobject.write()</code>：文件对象的 <code>write()</code>方法</li></ul><p><strong>格式控制的方法：</strong></p><ul><li><code>formatted string literal</code>：以<code>f</code> 开头</li><li><code>str.format()</code>：可以位置参数给入，也可以关键字参数给入，</li><li><code>format % values</code></li></ul><p><strong>例子：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">names=&#123;<span class="hljs-string">&quot;Louis&quot;</span>: <span class="hljs-number">20</span>, <span class="hljs-string">&quot;John&quot;</span>: <span class="hljs-number">30</span>, <span class="hljs-string">&quot;Alice&quot;</span>: <span class="hljs-number">25</span>&#125;<br><br><span class="hljs-keyword">for</span> name, age <span class="hljs-keyword">in</span> names.items():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;name:<span class="hljs-number">10</span>&#125;</span> is <span class="hljs-subst">&#123;age:<span class="hljs-number">5.1</span>f&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="文件读写">文件读写</h2><p><strong>特性：</strong></p><ul><li><p><code>for statement</code> 可以迭代文件对象<code>f</code></p></li><li><p><code>open(filename,mode,encoding=None)</code> 函数返回<code>file object</code></p><p><code>mode</code> 有</p><ul><li><p><code>r</code>：只读（默认）</p></li><li><p><code>w</code>：只写（会覆盖原有文件）</p></li><li><p><code>a</code>：添加</p></li><li><p><code>r+</code>：读写</p></li><li><p><code>a+</code>：读写（添加）</p></li><li><p><code>w+</code>：读写（覆盖）</p></li></ul></li><li><p>使用 <code>with</code> 关键词操作文件，会在它的<code>suite</code> （代码块）结束后自动正确地关闭文件</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;workfile&#x27;</span>, encoding=<span class="hljs-string">&quot;utf-8&quot;</span>) <span class="hljs-keyword">as</span> f:<br>    <span class="hljs-comment"># this is suite</span><br>    read_data = f.read()<br><br><span class="hljs-comment"># We can check that the file has been automatically closed.</span><br>f.closed<br><span class="hljs-literal">True</span> <br></code></pre></td></tr></table></figure><p><strong>文件方法：</strong></p><ul><li><p><code>f.read(size=-1)</code>：读 <code>size</code>大小的数据（单位是字节），不指定则默认读取整个文件</p></li><li><p><code>f.readline(size=-1)</code>：读 <code>size</code>大小的数据（单位是字节），不指定则默认读取整行数据（包括换行符）</p></li><li><p><code>f.write(str)</code>：返回写入字数</p></li><li><p><code>f.tell()</code>：返回文件对象的当前位置</p></li><li><p><code>f.seek(offset,whence)</code>：修改文件对象的<code>current position</code>，由 <code>whence</code>指定相对位置，<code>offset</code> 指定偏移量</p><p><code>whence</code> 参数：</p><ul><li><code>0</code>：开始</li><li><code>1</code>：当前位置</li><li><code>2</code>：文件尾部</li></ul></li></ul><h2 id="json支持">JSON支持</h2><ul><li>导入 <code>json</code> 库</li><li><code>json.dumps(x)</code>：简单序列化</li><li><code>json.dump(x,f)</code>：序列化到文件 <code>f</code></li><li><code>json.load(f)</code>：从文件 <code>f</code> 反序列化</li></ul><h1 id="九错误处理">九、错误处理</h1><ul><li><code>except</code> 语句最多执行一次</li><li><code>break</code> 、<code>continue</code> 、<code>return</code>出现在 <code>try</code> 子句中 ， <code>finally</code> 子句先执行，再<code>raise</code></li><li><code>break</code> 、<code>continue</code> 、<code>return</code>出现在 <code>finally</code> 子句中，</li></ul><h1 id="十类">十、类</h1><h2 id="创建语法">创建语法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Class_Name</span>(Base_Class1,Base_Class2):<br>attr1=<span class="hljs-string">&quot;1&quot;</span><br>    attr2=<span class="hljs-string">&quot;2&quot;</span><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,attr1,attr2</span>): <br>        <span class="hljs-variable language_">self</span>.attr1=attr1<br>        <span class="hljs-variable language_">self</span>.attr2=attr2<br>    <br>example=Class_Name(attr_1,attr_2)    <br></code></pre></td></tr></table></figure><h2 id="专有方法">专有方法</h2><ol type="1"><li><code>__init__</code></li><li><code>__del__</code></li><li><code>__repr__</code></li><li><code>__setitem__</code></li><li><code>__getitem__</code></li><li><code>__len__</code></li><li><code>__cmp__</code></li><li><code>__call__</code></li><li><code>__add__</code></li><li><code>__sub__</code></li><li><code>__mul__</code></li><li><code>__truediv__</code></li><li><code>__mod__</code></li><li><code>__pow__</code></li></ol><h1 id="标准库">标准库</h1><h2 id="使用技巧">使用技巧</h2><p><strong>查看库的信息：</strong></p><ul><li><code>dir(module)</code></li><li><code>help(module)</code></li></ul><h2 id="random">random</h2><ul><li><code>random.choice(seq)</code>：从非空序列 <code>seq</code>返回一个随机元素</li><li><code>random.sample(population, k, *, counts=None)</code>：从总体，</li><li><code>random.random()</code>：返回 <code>[0.0,1.0)</code>之间的随机浮点数</li><li><code>random.randrange()</code>：</li><li><code>random.shuffle(x: MutableSequence)</code>：将可写的序列随机打乱位置</li></ul><h2 id="struct">struct</h2><ul><li><p><code>struct.pack()</code></p></li><li><p><code>struct.unpack(format, buffer)</code>：将从<code>buffer</code> 读入的数据，转换为python内置的数据类型</p></li></ul><h2 id="gzip">gzip</h2><p><code>gzip.open(path, mode, encoding)</code></p><h2 id="pickle">pickle</h2><ul><li><code>pickle.dump(obj, file_obj)</code>：将对象序列化为字节流，保存到文件</li><li><code>pickle.dumps(obj)</code>：将对象序列化成字节流，返回该字节流</li><li><code>pickle.load(data)</code>：</li><li><code>pickle.loads(bytes)</code>：将字节流反序列化成对象，返回该对象</li></ul><h2 id="json">json</h2>]]></content>
    
    
    <categories>
      
      <category>计算机技术</category>
      
      <category>编程语言</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>多元微积分 #1 方向导数</title>
    <link href="/2025/01/01/%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86_1_%E6%96%B9%E5%90%91%E5%AF%BC%E6%95%B0/"/>
    <url>/2025/01/01/%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86_1_%E6%96%B9%E5%90%91%E5%AF%BC%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="一一般的定义">一、一般的定义</h1><p><span class="math inline">\(f: U \mapsto \mathbb{R}\)</span> ，是<span class="math inline">\(\mathbb{R}^n\)</span> 上某个开集 <spanclass="math inline">\(U\)</span> 映射到实数 <spanclass="math inline">\(\mathbb{R}\)</span> 的函数，给定 <spanclass="math inline">\(\mathbb{R}^n\)</span> 内某点 <spanclass="math inline">\(\mathbf{x}=\{x_1,\cdots,x_n\}\)</span>，和某非零向量 <spanclass="math inline">\(\mathbf{v}=\{v_1,\cdots,v_n\}\)</span></p><p>定义一个依赖 <span class="math inline">\(\mathbf x\)</span> 跟 <spanclass="math inline">\(\mathbf v\)</span>，从 <spanclass="math inline">\(\mathbb R\)</span> 映射到 <spanclass="math inline">\(\mathbb R\)</span> 的 函数： <spanclass="math display">\[f_{\mathbf v}:t\mapsto f(\mathbf x+t\mathbf v)\]</span> 若 <span class="math inline">\(f_{\mathbf v}\)</span> 对 <spanclass="math inline">\(t\)</span> 的微分在 <spanclass="math inline">\(t=0\)</span> 处存在，那么可以定义 <spanclass="math inline">\(f\)</span> 在点 <spanclass="math inline">\(\mathbf x\)</span> 沿向量 <spanclass="math inline">\(\mathbf v\)</span> 的方向导数为 <spanclass="math display">\[\nabla_{\mathbf v} f(\mathbf x)=\left. \frac{\mathrm{d}f_{\mathbfv}}{\mathrm{d} t}\right|_{t=0}=\lim_{t\to 0}\frac{f(\mathbf x+t\mathbfv)-f(\mathbf x)}{t}\]</span></p><h1 id="二方向导数的计算">二、方向导数的计算</h1><p>在三元的情况下，设 <span class="math display">\[\rho=\sqrt{(\Delta x)^2+(\Delta y)^2+(\Delta z)^2}\]</span> 若三元函数 <span class="math inline">\(f\)</span> 在点 <spanclass="math inline">\((x,y,z)\)</span> 邻域内可微， <spanclass="math display">\[\frac{\partial f}{\partial \mathbf u}=\lim_{\rho \to 0} \frac{f(x+\Deltax,y+\Delta y,z+\Delta z)-f(x,y,z)}{\rho}\]</span> 分子全增量展开， <span class="math display">\[\lim_{\rho\to0}\,\frac{\partial f}{\partial x}\cdot\frac{\Deltax}{\rho}+\frac{\partial f}{\partial y}\cdot\frac{\Deltay}{\rho}+\frac{\partial f}{\partial z}\cdot\frac{\Delta z}{\rho}+\omega\]</span> 即 <span class="math display">\[\frac{\partial f}{\partial \mathbf u}=\nabla f(\mathbf x)\cdot \mathbf u\]</span></p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>高等数学</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux内核 #2 Namespaces</title>
    <link href="/2024/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/Linux/Linux%E5%86%85%E6%A0%B8_2_Namespaces/"/>
    <url>/2024/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/Linux/Linux%E5%86%85%E6%A0%B8_2_Namespaces/</url>
    
    <content type="html"><![CDATA[<h1 id="what-is-linux-namespaces">What is Linux Namespaces?</h1><p>​ Linux Namespaces 是一个 Linux内核功能，用于划分内核资源。它允许进程看到不同的视图，隔离其在系统中的资源，使得它们的运行环境对外界看起来像是在独立的操作系统中。通过namespace，多个进程可以在同一台物理机上共享资源的同时，实现进程间的隔离，从而提高系统的安全性、可管理性和可扩展性。</p><h1 id="linux-提供的命名空间">Linux 提供的命名空间</h1><ul><li><p>PID Namespace</p><blockquote><p>这样在不同的 PID Namespace 中，同样的 PID可以对应不同的进程。例如，容器内的进程可以拥有 PID 1，但在宿主机上该 PID可能是另一个进程。</p></blockquote></li><li><p>Mount Namespace</p><blockquote><p>每个 Namespace 拥有独立的挂载点视图。通过这个Namespace，容器或进程可以拥有自己独立的文件系统结构，避免与宿主机或其他容器共享文件系统。</p></blockquote></li><li><p>Network Namespace</p><blockquote><p>将网络接口、IP 地址、路由表、端口等网络资源隔离到各个 Namespace中。每个 Namespace可以拥有独立的网络栈，从而实现独立的网络配置和通信。</p></blockquote></li><li><p>IPC Namespace</p><blockquote><p>为不同的进程提供独立的IPC（进程间通信）资源，如消息队列、共享内存和信号量。不同 Namespace中的进程无法直接访问其他 Namespace 中的 IPC 资源。</p></blockquote></li><li><p>UTS Namespace</p><blockquote><p>允许不同的 Namespace 中拥有独立的主机名（hostname）和域名（domainname）。这意味着每个容器或进程可以在其 Namespace中设置不同的主机名，而不影响宿主机或其他容器。</p></blockquote></li><li><p>User Namespace</p><blockquote><p>隔离不同 Namespace 中的用户和用户组 ID（UID 和 GID）。在同一个用户Namespace 中，可以映射不同的用户 ID 和组ID，从而使得容器内的进程以不同的权限运行，避免与宿主机上的用户 ID冲突。</p><p><strong>用途</strong>: 容器运行时，通过 User Namespace可以使容器内的用户以非特权用户身份运行，而不需要以 root身份运行，从而增加安全性。</p></blockquote></li></ul><h1 id="总结">总结</h1><p>Linux Namespaces提供了一种轻量级的资源隔离机制，它是实现容器技术的基础。通过不同的Namespace 类型，Linux可以将进程、网络、文件系统、用户等资源进行有效的隔离，保证不同应用或服务之间的安全性和独立性。这种隔离机制在虚拟化、容器化以及多租户环境中具有广泛应用。</p>]]></content>
    
    
    <categories>
      
      <category>计算机技术</category>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux内核 #1 Cgroups</title>
    <link href="/2024/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/Linux/Linux%E5%86%85%E6%A0%B8_1_Cgroups/"/>
    <url>/2024/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/Linux/Linux%E5%86%85%E6%A0%B8_1_Cgroups/</url>
    
    <content type="html"><![CDATA[<h1 id="what-is-cgroups">What is cgroups?</h1><p>​ Control Groups，是一个Linux内核功能，用来限制、控制与分离一个<strong>进程组的</strong>资源。最早的名称为<strong>进程容器（processcontainers）</strong>。</p><h1 id="functionality">Functionality</h1><p>cgroups 提供</p><ul><li>资源限制（ResourcesLimiting）：组可以被设置不超过设定的内存限制、I/O带宽限制、CPU配额限制、最大打开文件数</li><li>优先级设定（Prioritation）：一些组可能会得到更大的CPU，或磁盘I/O吞吐量</li><li>结算（Accounting）：衡量一个组的资源使用情况，可用于计费目的</li><li>控制（Control）：冻结组的进程，运行检查点和重新启动</li></ul><h1 id="cgroup">cgroup</h1><p>​ cgroup是一组受相同条件约束的进程，并与一组参数或限制相关联，这些组可以是层次结构的，意味着每个组都从其父组继承限制。</p>]]></content>
    
    
    <categories>
      
      <category>计算机技术</category>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>虚拟化技术</title>
    <link href="/2024/12/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E8%99%9A%E6%8B%9F%E5%8C%96/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF/"/>
    <url>/2024/12/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E8%99%9A%E6%8B%9F%E5%8C%96/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<p style="text-align: center;font-size: 2em">虚拟化技术：计算机资源的重新分配</p><h1 id="一概念">一、概念</h1><h2 id="定义">定义</h2><p>在计算机技术中，<strong>虚拟化</strong>（技术）或<strong>虚拟技术</strong>（Virtualization）是一种<strong>资源管理技术</strong>，是将计算机的各种实体资源，予以抽象、转换后呈现出来并可供分割、组合为一个或多个电脑配置环境。</p><p>传统的虚拟技术：虚拟机（VMs）:</p><p>有两个对象：</p><ol type="1"><li>Hypervisor：用来创建、运行、管理虚拟机</li><li>VM（Virtual Machine）</li></ol><h2 id="hypervisor">Hypervisor</h2><p>补充两个概念</p><ol type="1"><li>Host Machine：通常指的是虚拟化平台，如果是 type 2Hypervisor，则会有一个 Host OS</li><li>GuestMachine：通常指的是在虚拟化平台（Hypervisor）上运行的虚拟机（LinuxVM）</li></ol><pre><code class=" mermaid">block-betacolumns 3block:type1:1columns 3VM1VM2VM3B[&quot;Hypervisor&quot;]:3A[&quot;Hardware&quot;]:3end</code></pre><p style="text-align: center">Type1 架构图</p><pre><code class=" mermaid">block-betablock:type2:1columns 3VM1VM2VM3C[&quot;Hypervisor&quot;]:3B[&quot;Host OS&quot;]:3A[&quot;Hardware&quot;]:3end</code></pre><p style="text-align: center">Type2 架构图</p><h1 id="二历史">二、历史</h1><p>虚拟技术起源于20世界60年代末，美国IBM公司当时开发了一套被称作虚拟机监视器<strong>VMM</strong>（Virtual MachineMonitor）的软件，该软件作为计算机硬件层上面的一层软件抽象层，将计算机硬件虚拟分割成一个或多个虚拟机，并提供多用户对大型计算机的同时、交互访问。</p><p>有关容器化（Containerization or OS Level Virtualization）的历史：</p><blockquote><p>2008 年 Linux 内核引进了 cgroups （control-groups）, " paved the wayfor all the different container technologies we see today "</p></blockquote><h1 id="三分类">三、分类</h1><h2 id="按照抽象程度分类递增">按照抽象程度分类（递增）</h2><ul><li><p>硬件抽象层等级的虚拟化（Hardware Abstruction Level）：VMwareESXi、Hyper-V</p><blockquote><p>这个等级的虚拟化靠Hypervisor，运行平台的叫 HostMachine，平台上运行的叫 Guest Machine</p><p>type 1 hypervisor ，不经操作系统，直接运行在硬件上；type 2 hypervisor运行在操作系统上</p></blockquote></li><li><p>指令集架构等级的虚拟化（Instruction Set ArchitectureLevel）：Bochs、QEMU</p></li><li><p>操作系统等级的虚拟化或<strong>容器化</strong>（Operating SystemLevel or Containerization）：Docker、LXC</p><blockquote><p>将操作系统内核虚拟化，这个等级的虚拟机共享实体主机的硬件以及操作系统，呈现彼此独立且隔离的虚拟机环境。</p><p>补充概念：应用软件的环境是由操作系统、函数库、相依性软件、特定的文件系统以及其他环境设置所组成。</p></blockquote></li><li><p>编程语言等级的虚拟化（Programming LanguageLevel）：Java、.NET</p><blockquote><p>将高级语言转换成字节码，通过虚拟机转译成可以直接执行的指令</p></blockquote></li><li><p>函数库等级的虚拟化（Library Level）：Wine、WSL</p></li></ul><h2 id="按虚拟对象分类">按虚拟对象分类</h2><ul><li><p>硬件虚拟化</p></li><li><p>虚拟机</p><ul><li>平台虚拟化<ul><li>完全虚拟化：敏感指令在操作系统和硬件之间被捕捉处理，客户操作系统无需更改，所有软件都能在虚拟机中运行。</li><li>硬件辅助虚拟化：利用硬件（主要是CPU）辅助处理敏感指令，以实现完全虚拟化的功能。如KVM, Hyper-V</li><li>部分虚拟化</li><li>准虚拟化</li><li>操作系统级虚拟化：使操作系统内核支持多用户空间实例。如 LXC,chroot</li></ul></li><li>应用程序虚拟化</li></ul></li><li><p>虚拟内存</p></li><li><p>存储虚拟化</p></li><li><p>网络虚拟化</p></li></ul><p>QEMU的架构</p><blockquote><p>QEMU（Quick Emulator）和 Bochs 类似</p><p>QEMU的架构由纯软件实现，并在Guest与Host中间，来处理Guest的硬件请求，并由其转译给真正的硬件。</p><p>然而因为QEMU是纯软件实现的，所有的指令都要经过QEMU，使得性能很差，而配合KVM则可以解决这一问题。</p><p>QEMU虚拟化的思路是：提取Guest代码，翻译为<strong>TCG</strong>中间代码，而后翻译为<strong>Host</strong>代码。相当于实现了一个“中间人”的角色。</p></blockquote><h1 id="四虚拟技术的发展">四、虚拟技术的发展</h1><p>下面是云服务厂商虚拟化技术的一个迭代。基本上都是基于硬件虚拟化</p><p>（1）VMware-ESXi</p><p>是一个 type-1 Hypervisor，直接运行在硬件上</p><p>（2）Xen</p><p>是一个 type-1 Hypervisor，直接运行在硬件上</p><p>（3）KVM（Kernal Based Virtual Machine）</p><p>是一个 type-2Hypervisor，依赖于操作系统（Linux内核）来管理虚拟化，本身是一个<strong>内核模块</strong>，基于硬件虚拟化来虚拟化功能。</p><p>将 Linux 内核转化为 Hypervisor。</p><p>KVM被合并入Linux内核版本2.6.20的主流分支，于2007年2月5日发布。</p>]]></content>
    
    
    <categories>
      
      <category>计算机技术</category>
      
      <category>虚拟化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Virtualization</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker #1 架构</title>
    <link href="/2024/12/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/Docker/Docker_%E6%9E%B6%E6%9E%84/"/>
    <url>/2024/12/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/Docker/Docker_%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="一docker-架构">一、Docker 架构</h1><p>Docker 是一个 client-server 架构的应用软件，包含：</p><ol type="1"><li>docker-daemon：<code>dockerd</code></li><li>APIs</li><li>docker-client</li></ol><p>client 可以连接 local-daemon，也可以连接 remote-daemon</p><h1 id="二docker与linux内核">二、Docker与Linux内核</h1><p>在 0.9 之前，Docker 一直用的 LXC 技术来利用 Linux内核的虚拟化功能。</p><p>在 0.9 版本之后，Docker 采用自研的 libcontainer 来使用 Linux内核提供的虚拟化功能，并且也可以选择其它接口。</p><p>Docker 可选的接口</p><ol type="1"><li>libcontainer</li><li>libvirt</li><li>LXC</li><li>systemd_nspawn</li></ol><figure><img src="/img/dockerinterfaces.svg" alt="Docker 底层接口" /><figcaption aria-hidden="true">Docker 底层接口</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>计算机技术</category>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最佳安装实践 #2 Docker</title>
    <link href="/2024/12/21/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/Docker_%E6%9C%80%E4%BD%B3%E5%AE%89%E8%A3%85%E5%AE%9E%E8%B7%B5/"/>
    <url>/2024/12/21/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/Docker_%E6%9C%80%E4%BD%B3%E5%AE%89%E8%A3%85%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="命令行安装推荐">命令行安装（推荐）</h1><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">&quot;Docker Desktop Installer.exe&quot; install<br></code></pre></td></tr></table></figure><p>安装选项：</p><p><code>--installation-dir=&lt;path&gt;</code>: Changes the defaultinstallation</p><p><code>--windows-containers-default-data-root=&lt;path&gt;</code>:Specifies the default location for the Windows containers.</p><p>设置 Windows 容器默认存储路径</p><p><code>--wsl-default-data-root=&lt;path&gt;</code>: Specifies thedefault location for the WSL distribution disk.</p><p>设置 WSL 发行版的磁盘路径</p><p><code>--backend=&lt;backend name&gt;</code>: Selects the defaultbackend to use for Docker Desktop, <code>hyper-v</code>,<code>windows</code> or <code>wsl-2</code> (default)</p>]]></content>
    
    
    <categories>
      
      <category>最佳实践</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Installation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最佳安装实践 #1 WSL2</title>
    <link href="/2024/12/21/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/WSL2_%E6%9C%80%E4%BD%B3%E5%AE%89%E8%A3%85%E5%AE%9E%E8%B7%B5/"/>
    <url>/2024/12/21/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/WSL2_%E6%9C%80%E4%BD%B3%E5%AE%89%E8%A3%85%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<blockquote><p>参考于 Windows 官方文档</p></blockquote><h1 id="一键安装">一键安装</h1><blockquote><p>[!NOTE]</p><p>必须运行 Windows 10 版本 2004 及更高版本（内部版本 19041及更高版本）或 Windows 11 才能使用以下命令</p></blockquote><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">wsl <span class="hljs-literal">--install</span><br></code></pre></td></tr></table></figure><p>这个命令：</p><ol type="1"><li>启用可选的 WSL 和虚拟机平台组件</li><li>下载并安装最新的 Linux 内核</li><li>将 WSL 2 设置为默认值</li></ol><p>接下来就可以：</p><ul><li>下载并安装 Ubuntu Linux 发行版</li></ul><h1 id="手动安装">手动安装</h1><p>（1）通过 Windows 启用功能面板，启用：</p><ol type="1"><li>Windows Subsystem for Linux</li><li>Virtual Machine Platform</li></ol><p>（2）更新到 WSL2</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">wsl <span class="hljs-literal">--update</span><br></code></pre></td></tr></table></figure><p>（3）配置 WSL2 为默认版本</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">wsl <span class="hljs-literal">--set-default-version</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>（4）下载 Linux Distro</p><h1 id="常用命令">常用命令</h1><ul><li><code>wsl --list -online</code>：查看可下载的发行版</li><li><code>wsl --unregistry</code>：卸载发行版，移除 VHDX文件，删除相关配置，修改注册表（不可逆）</li><li><code>wsl --distrubution</code>：启动发行版</li><li><code>wsl --export &lt;DistroName&gt; &lt;ExportFilePath&gt;</code>：导出发行版。导出VHDX 文件等，这个命令只导出文件系统内容，不会导出 WSL相关的配置或用户设置（比如 <code>/etc/wsl.conf</code> 文件、Windows环境设置等）。一般导出成归档文件。</li><li><code>wsl --import &lt;DistroName&gt; &lt;InstallLocation&gt; &lt;ExportFilePath&gt;</code>：导入发行版。</li></ul>]]></content>
    
    
    <categories>
      
      <category>最佳实践</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Installation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CAP原则浅谈</title>
    <link href="/2024/12/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E5%88%86%E5%B8%83%E5%BC%8F/CAP%E5%AE%9A%E7%90%86%E6%B5%85%E8%B0%88/"/>
    <url>/2024/12/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E5%88%86%E5%B8%83%E5%BC%8F/CAP%E5%AE%9A%E7%90%86%E6%B5%85%E8%B0%88/</url>
    
    <content type="html"><![CDATA[<h1 id="一概述">一、概述</h1><p>CAP theorem or Brewer's theorem是指一个分布式计算系统不可能同时满足以下三点</p><ol type="1"><li>Consistency（一致性）</li><li>Availability（可用性）</li><li>Partition Tolerance（分区容错性）</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机技术</category>
      
      <category>分布式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linear Algebra #0 应试笔记</title>
    <link href="/2024/10/10/%E6%95%B0%E5%AD%A6/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0_0_%E5%BA%94%E8%AF%95%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/10/10/%E6%95%B0%E5%AD%A6/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0_0_%E5%BA%94%E8%AF%95%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="行列式">行列式</h1><h2 id="性质">性质</h2><p>（1）倍加行列式不变</p><p>（2）倍乘可以提到外面</p><p>（3）互换变号</p><p>（4）单行可拆性</p><h2 id="分块矩阵">分块矩阵</h2><p>（1）分块三角阵 <span class="math display">\[A=\begin{pmatrix}B &amp; X\\0 &amp; C\end{pmatrix}\to\begin{pmatrix}B_1 &amp; X_1\\0 &amp; C_1\end{pmatrix}=A_1\]</span> 则 <span class="math display">\[|A|=|A_1|=|B_1||C_1|=|B||C|\]</span></p><h2 id="范德蒙德行列式">范德蒙德行列式</h2><p><span class="math display">\[V_n=\begin{bmatrix}1&amp;x_1&amp;x_1^2&amp;\cdots&amp;x_1^{n-1}\\1&amp;x_2&amp;x_2^2&amp;\cdots&amp;x_2^{n-1}\\1&amp;x_3&amp;x_3^2&amp;\cdots&amp;x_3^{n-1}\\\vdots&amp;\vdots&amp;\vdots&amp;\ddots &amp;\vdots\\1&amp;x_n&amp;x_n^2&amp;\cdots&amp;x_n^{n-1}\\\end{bmatrix}\]</span> 则 <span class="math display">\[\det(V_n)=\prod_{1\le i\lt j\le n}(x_j-x_i)\]</span> 证明：</p><p>从 <span class="math inline">\(n-1\)</span> 列开始，倍乘 <spanclass="math inline">\(-x_n\)</span> 加到前一列，直到第 1 列 <spanclass="math display">\[V_n=\left|\begin{matrix}1&amp;x_1-x_n&amp;x_1^2-x_1x_n&amp;\cdots&amp;x_1^{n-1}-x_1^{n-2}x_n\\1&amp;x_2-x_n&amp;x_2^2-x_2x_n&amp;\cdots&amp;x_2^{n-1}-x_2^{n-2}x_n\\1&amp;x_3-x_n&amp;x_3^2-x_3x_n&amp;\cdots&amp;x_3^{n-1}-x_3^{n-2}x_n\\\vdots&amp;\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\1&amp;0&amp;0&amp;\cdots&amp;0\\\end{matrix}\right|\]</span> 按第 <span class="math inline">\(n\)</span> 行展开 <spanclass="math display">\[V_n=(-1)^{n+1}\left|\begin{matrix}x_1-x_n&amp;x_1^2-x_1x_n&amp;\cdots&amp;x_1^{n-1}-x_1^{n-2}x_n\\x_2-x_n&amp;x_2^2-x_2x_n&amp;\cdots&amp;x_2^{n-1}-x_2^{n-2}x_n\\x_3-x_n&amp;x_3^2-x_3x_n&amp;\cdots&amp;x_3^{n-1}-x_3^{n-2}x_n\\\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\x_{n-1}-x_n&amp;x_{n-1}^2-x_{n-1}x_n&amp;\cdots&amp;x_{n-1}^{n-1}-x_{n-2}^{n-2}x_n\\\end{matrix}\right|_{}\]</span> 因式分解 <span class="math display">\[V_n=(-1)^{n+1}\left|\begin{matrix}x_1-x_n&amp;x_1(x_1-x_n)&amp;\cdots&amp;x_1^{n-2}(x_1-x_n)\\x_2-x_n&amp;x_2(x_2-x_n)&amp;\cdots&amp;x_2^{n-2}(x_2-x_n)\\x_3-x_n&amp;x_3(x_3-x_n)&amp;\cdots&amp;x_3^{n-2}(x_3-x_n)\\\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\x_{n-1}-x_n&amp;x_{n-1}(x_{n-1}-x_n)&amp;\cdots&amp;x_{n-1}^{n-2}(x_{n-1}-x_n)\\\end{matrix}\right|\]</span> 提取公因式 <span class="math display">\[V_n=(-1)^{n+1}(x_1-x_n)(x_2-x_n)(x_3-x_n)\cdots(x_{n-1}-x_n)\left|\begin{matrix}1&amp;x_1&amp;\cdots&amp;x_1^{n-2}\\1&amp;x_2&amp;\cdots&amp;x_2^{n-2}\\1&amp;x_3&amp;\cdots&amp;x_3^{n-2}\\\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\1&amp;x_{n-1}&amp;\cdots&amp;x_{n-1}^{n-2}\\\end{matrix}\right|\]</span> 于是得到递推公式 <span class="math display">\[\begin{align}V_n&amp;=(x_n-x_1)(x_n-x_2)(x_n-x_3)\cdots(x_n-x_{n-1})V_{n-1}\\&amp;=\prod_{i=1}^{n-1}(x_n-x_{i})V_{n-1}\end{align}\]</span></p><p><span class="math inline">\(\text{Vandermonde}\)</span> 行列式不为0<span class="math inline">\(\iff\)</span> <spanclass="math inline">\(x_i\)</span> 各不相同</p><h1 id="矩阵变换">矩阵变换</h1><h2 id="初等变换">初等变换</h2><p>（1）倍加</p><p>（2）倍乘</p><p>（3）互换</p><p>初等矩阵：由单位阵经过一次初等变换得到的矩阵</p><p>性质：初等矩阵可逆</p><h2 id="广义初等变换">广义初等变换</h2><p>（1）广义换法变换</p><p><span class="math display">\[\begin{bmatrix}0&amp;E\\E&amp;0\end{bmatrix}\]</span></p><p>显然，这种变换都是可逆的（行列式不为0），则可分解为n个初等矩阵的乘积，即不改变矩阵的秩</p><p>（2）广义消法变换</p><p>（3）广义倍法变换</p><h1 id="矩阵">矩阵</h1><h2 id="应用">应用</h2><p>（1）解线性方程组</p><p>（2）线性映射的表示</p><blockquote><p>对每个线性变换 <span class="math inline">\(f:\mathbb{R}^n \to\mathbb{R}^m,\)</span> 存在唯一的一个<span class="math inline">\(m\timesn\)</span> 的矩阵 <span class="math inline">\(A\)</span> 使得 <spanclass="math inline">\(f(x)=A_fx\)</span></p><p>即 <span class="math inline">\(f\mapsto A_f\)</span></p></blockquote><p>矩阵是 <strong>线性映射</strong> <spanclass="math inline">\(\mathscr{A}\)</span> 在 <strong>入口基</strong> 和<strong>出口基</strong> 下的一种<strong>表示</strong></p><ol type="1"><li><p>矩阵等价</p><ul><li>秩相等（充要条件）</li></ul><blockquote><p>矩阵等价，表示着是同一种 <strong>线性映射</strong>在不同基底下的不同表示。有限维空间中的一种线性映射可以按秩分类。</p></blockquote></li><li><p>矩阵相似</p><blockquote><p><strong>线性变换</strong> 在一组相同基下的表示。</p></blockquote><p>有以下推论：</p><ul><li><p>秩相等</p></li><li><p>特征多项式相等</p><blockquote><p>A,B矩阵相似，说明特征矩阵相似，进一步说明特征矩阵的行列式（即特征多项式）相等</p></blockquote></li><li><p>特征值相等</p></li><li><p><strong>K阶主子式之和</strong> 分别相等</p><ul><li>迹相等</li><li>行列式相等</li></ul></li></ul></li><li><p>矩阵合同</p><ul><li>秩相等</li><li>正惯性指数相等</li></ul></li></ol><h2 id="实对称矩阵">实对称矩阵</h2><p><span class="math inline">\(A^T=A\)</span></p><p>（1）属于不同特征值的特征向量<strong>正交</strong></p><p>设 <span class="math inline">\(\lambda_1\ne\lambda_2\)</span>，且已知<span class="math inline">\(A^T=A\)</span> <span class="math display">\[\lambda_1\xi_2^T\xi_1=\xi_2^TA\xi_1=(A^T\xi_2)^T\xi_1=(A\xi_2)^T\xi_1=\lambda_2\xi^T_2\xi_1\]</span> 则 <spanclass="math inline">\(\Rightarrow\xi_2^T\xi_1=0\)</span></p><p>（2）相同特征值的的特征向量必线性无关</p><p>（3）实对称阵必可以通过<strong>一个可逆的线性变换</strong>相似对角化</p><p>（3）实对称阵必可以通过<strong>正交变换</strong>相似对角化</p><h2 id="反对称矩阵">反对称矩阵</h2><p><span class="math inline">\(A=-A^{T}\)</span></p><p>（1）主对角线元素为0</p><p>（2）奇数阶行列式为0 <span class="math display">\[|A|=|A^{T}|=|-A|=(-1)^n|A|\]</span> 当 <span class="math inline">\(n\)</span> 为奇数时，<spanclass="math inline">\(|A|\)</span> 只能是0</p><p>（3）矩阵的转置为负矩阵</p><h2 id="格拉姆矩阵">格拉姆矩阵</h2><p><span class="math inline">\(\text{Gram Matrix}\)</span></p><p><span class="math display">\[G = \begin{pmatrix} \langle \mathbf{v}_1, \mathbf{v}_1 \rangle &amp;\langle \mathbf{v}_1, \mathbf{v}_2 \rangle &amp; \cdots &amp; \langle\mathbf{v}_1, \mathbf{v}_n \rangle \\ \langle \mathbf{v}_2, \mathbf{v}_1\rangle &amp; \langle \mathbf{v}_2, \mathbf{v}_2 \rangle &amp; \cdots&amp; \langle \mathbf{v}_2, \mathbf{v}_n \rangle \\ \vdots &amp; \vdots&amp; \ddots &amp; \vdots \\ \langle \mathbf{v}_n, \mathbf{v}_1 \rangle&amp; \langle \mathbf{v}_n, \mathbf{v}_2 \rangle &amp; \cdots &amp;\langle \mathbf{v}_n, \mathbf{v}_n \rangle \end{pmatrix}\]</span></p><h2 id="史密斯标准型">史密斯标准型</h2><p><span class="math inline">\(\text{Smith Canonical Form}\)</span></p><p><span class="math display">\[\begin{bmatrix}d_1(\lambda)&amp; &amp;\\&amp;d_r(\lambda)&amp;\\&amp;&amp;0\end{bmatrix}\]</span></p><h2 id="若尔当标准型">若尔当标准型</h2><p><span class="math inline">\(\text{Jordan Canonical Form}\)</span></p><blockquote><p>不是所有矩阵都能相似对角化，但是一定能相似于 Jordan标准型，这个矩阵近似于对角阵。</p></blockquote><p>一个矩阵的每个初等因子，对应一个阶数为这个特征值几何重数的 Jordan块，这个Jordan 块矩阵的特征值只等于定义它的标准型。</p><p>将矩阵所有的 Jordan块拼起来就成了Jordan标准形。</p><p>一个矩阵相似于它的 Jordan 标准型。因为他们的初等因子是一样的。</p><blockquote><p>相应于每一个若当块所用的基底，是一条广义特征向量链。</p></blockquote><h2 id="黑塞矩阵">黑塞矩阵</h2><p><span class="math inline">\(\text{Hessian Matrix}\)</span></p><blockquote><p>多元函数二阶导数构成的矩阵，可以多元函数展开。</p></blockquote><p>（1）西尔维斯特判别法 <span class="math inline">\(\text{SylvesterCriterion}\)</span></p><p>正定：<span class="math inline">\(A\)</span> 的各阶顺序主子式都大于0<span class="math display">\[D_{i}\gt0,\quad i=1,2,\cdots\]</span> 负定：对于 <span class="math inline">\(A\)</span>的顺序主子式，偶数阶为正，奇数阶为负</p><p>（2）函数的黑塞矩阵与雅可比矩阵的关系 <span class="math display">\[H(f)=J(\nabla f)\]</span></p><h2 id="雅可比矩阵">雅可比矩阵</h2><p><span class="math inline">\(\text{Jacobi Matrix}\)</span></p><h1 id="矩阵分解">矩阵分解</h1><p>（1）LU分解</p><p>（2）QR分解</p><p>（3）奇异值分解 （<spanclass="math inline">\(\text{SigularValueDecomposition}\)</span>）</p><p>（4）特征值分解（谱分解）</p><p>（5）<span class="math inline">\(\text{Cholesky}\)</span> 分解</p><p>实对称阵的谱分解：</p><p>实对称阵必可以<strong>正交相似对角化</strong> <spanclass="math display">\[A=Q\LambdaQ^T=\lambda_1\beta_1\beta_1^T+\cdots+\lambda_n\beta_n\beta_n^T=\sum_{i=1}^{n}\lambda_i\beta_i\beta_i^T\]</span>实对称阵等于其特征值对应的<strong>正交单位特征向量</strong>的<strong>张量</strong>的<strong>乘积之和</strong></p><h1 id="特征值和特征向量">特征值和特征向量</h1><p><span class="math inline">\(\text{Eigenvalue andEigenvector}\)</span></p><p><span class="math inline">\(\exists v\ne0,\quad Av=\lambda v\iff(A-\lambda I)v=0\)</span> 有非零解 <spanclass="math inline">\(\iff\det(A-\lambda I)=0\)</span></p><h2 id="韦达定理">韦达定理</h2><p>描述一元n次多项式根和系数的关系，<span class="math inline">\(a_nx^n+a_{n-1}x^{n-1}+\cdots+a_1x+a_0\)</span> <spanclass="math display">\[\sum_{i=1}^{n} x_i=-\frac{a_{n-1}}{a_n}\\\prod_{i=1}^n x_i=(-1)^n\frac{a_0}{a_n}\]</span></p><h2 id="常用矩阵特征值">常用矩阵特征值</h2><p><span class="math display">\[\begin{array}{c|c|c|c}\hline\text{矩阵} &amp; kA &amp; A^n &amp; p(A) &amp; A^{-1} &amp; A^* &amp;P^{-1}AP\\\hline\text{特征值} &amp; k\lambda &amp; \lambda^n &amp; p(\lambda) &amp;\frac{1}{\lambda} &amp; \frac{|A|}{\lambda}&amp; \lambda\\\hline\text{特征向量} &amp; \xi &amp; \xi &amp; \xi &amp; \xi &amp; \xi &amp;P^{-1}\xi\\\hline\end{array}\]</span></p><h1 id="相似理论">相似理论</h1><blockquote><p>域上矩阵相似可以转换为环上矩阵等价</p></blockquote><p>定理：矩阵相似 <span class="math inline">\(\iff\)</span>在多项式环上的，特征矩阵 <spanclass="math inline">\(\lambda\mathbf{I}-\mathbf{A}\)</span>等价</p><h2 id="矩阵相似">矩阵相似</h2><p>（1）定义：</p><p><span class="math inline">\(n\)</span> 阶方阵 <spanclass="math inline">\(A,B\)</span> 相似，若有非奇异矩阵 <spanclass="math inline">\(P\)</span> <span class="math display">\[AP=PB\]</span> 或者 <span class="math display">\[P^{-1}AP=B\]</span> （2）几何意义</p><p>将 <span class="math inline">\(A\)</span> 视为 <spanclass="math inline">\(\mathbb{F}^n\)</span>上的的<strong>线性变换</strong>；出口基和入口基都选 <spanclass="math inline">\(P\)</span> ；则线性变换 <spanclass="math inline">\(A\)</span> 的矩阵表示为 <spanclass="math inline">\(B\)</span></p><h2 id="相似的传递">相似的传递</h2><h2 id="相似不变量">相似不变量</h2><p>即多项式环上矩阵的等价不变量：</p><ol type="1"><li><p>Smith标准型</p></li><li><p>不变因子</p><blockquote><p>smith标准型上的对角元素，可以由行列式因子计算得到。</p></blockquote></li><li><p>k阶行列式因子</p><blockquote><p>不依赖于初等行列变换的，所有k阶子式的最大公因子</p></blockquote></li><li><p>初等因子</p><blockquote><p>不变因子作质因分解的质因式及其幂</p></blockquote></li></ol><p>根据以上理论，可以得出，实数域两个矩阵相似，有以下量不变：</p><ol type="1"><li>行列式</li><li>迹</li><li>秩</li><li>特征多项式</li><li>特征值</li></ol><h2 id="不变子空间">不变子空间</h2><p>矩阵作用于一个子空间上，该子空间的像还在原来的空间上，这就叫不变子空间。</p><blockquote><p>特征向量和特征值，就是一维的不变子空间概念</p></blockquote><p>特殊的不变子空间：</p><p>（1）矩阵的核 <span class="math inline">\(\kerA=\{x|Ax=0\}\)</span></p><p>（2）矩阵的像 <span class="math inline">\(\text{Im} A=\{Ax|x\in\mathbb{F}^n\}\text{ or}\text{span}\{\alpha_1,\alpha_2,\cdots\}\)</span></p><p>（3）<span class="math inline">\(\{0\}\)</span></p><p>（4）<span class="math inline">\(\mathbb{F}^n\)</span></p><h2 id="三角化">三角化</h2><p>（1）定理：<span class="math inline">\(P^{-1}AP=B\)</span> ，<spanclass="math inline">\(P,B\)</span> 分块如下 <spanclass="math display">\[P=\begin{bmatrix}P_1 &amp; P_2\end{bmatrix}\quad B=\begin{bmatrix}B_{11} &amp; B_{12}\\B_{21} &amp; B_{22}\\end{bmatrix}\]</span> 则 <span class="math display">\[AP=PB\Rightarrow\left\{\begin{array}{lrl}AP_1&amp;=&amp;P_1B_{11}+P_2B_{21}\\AP_2&amp;=&amp;P_1B_{12}+P_2B_{22}\\\end{array}\right.\]</span> 若</p><ol type="1"><li><span class="math inline">\(B_{21}=0\iff\)</span> <spanclass="math inline">\(\text{Im} P_1\)</span> 为 <spanclass="math inline">\(A\)</span> 的不变子空间</li><li><span class="math inline">\(B_{12}=0\iff\)</span> <spanclass="math inline">\(\text{Im} P_2\)</span> 为 <spanclass="math inline">\(A\)</span> 的不变子空间</li></ol><p>（2）用矩阵的核 <span class="math inline">\(\ker A\)</span>作为不变子空间</p><p>（3）用矩阵的像 <span class="math inline">\(\text{Im} A\)</span>作为不变子空间</p><h2 id="对角化">对角化</h2><h2 id="shur-上三角化">Shur 上三角化</h2><p>复数域上的一个矩阵，一定能相似于一个上三角矩阵</p><h1 id="环上矩阵">环上矩阵</h1><p><span class="math inline">\(\text{Matrix on a Ring}\)</span></p><p>（1）记号与概念</p><ol type="1"><li><spanclass="math inline">\(\mathbb{F}[\lambda]\)</span>：多项式环</li><li><spanclass="math inline">\(\mathbb{F}(\lambda)\)</span>：有理分式域</li><li><span class="math inline">\((\mathbb{F}[\lambda])^{m\timesn}\)</span>：多项式环上矩阵的全体</li></ol><p>对于一个系数为实数域的多项式矩阵，它是一个环上的矩阵，有加减乘，没有除法</p><p>对于第二类初等变换有严格的要求：不允许乘以一个多项式，只能乘非零常数</p><p>因为，多项式没有乘法的<strong>逆元</strong>，做初等变换之后，再变回来必须乘以乘法逆元，如果允许多项式乘法，则变不回来了</p><p>（2）单位模阵：多项式矩阵的逆矩阵还是多项式矩阵</p><p><span class="math inline">\(|U(\lambda)|\in\mathbb{F}[\lambda]\)</span></p><p><spanclass="math inline">\(U^{-1}(\lambda)=\frac{A^*}{|U(\lambda)|}\)</span></p><p><span class="math inline">\(U(\lambda)\)</span> 是单位模阵<spanclass="math inline">\(\iff|U(\lambda)|=c\)</span>，c为非零常数</p><h2 id="smith标准型">Smith标准型</h2><p>多项式环上的矩阵一定可以做初等变换到一个标准型，这个标准型就是Smith标准型。</p><h1 id="实二次型">实二次型</h1><h2 id="化简">化简</h2><p>（1）正交变换</p><p>依据：任何实对称矩阵 <spanclass="math inline">\(A\)</span>，一定存在正交矩阵 <spanclass="math inline">\(Q\)</span> ，使得 <spanclass="math inline">\(Q^TAQ=\Lambda\)</span> <spanclass="math display">\[x^TAx=y^TQ^TAQy=y^T\Lambda y\]</span> （2）配方法</p><p>依据：任何实对称矩阵 <span class="math inline">\(A\)</span>，必存在可逆矩阵 <span class="math inline">\(C\)</span>，使得 <spanclass="math inline">\(C^TAC=\Lambda\)</span></p><p>若原二次型<strong>未出现平方项</strong></p><p>可先做变换： <span class="math display">\[\left\{\begin{array}{ccl}x_1 &amp;= &amp;y_1+y_2\\x_2&amp; =&amp;y_1-y_2\\x_3&amp;=&amp;y_3\end{array}\right.\]</span> 使其出现平方项，再做配方</p><h2 id="合同">合同</h2><p><span class="math inline">\(\text{Congruence}\)</span></p><p>定义：<span class="math inline">\(A\simeq B\)</span>当且仅当，存在可逆的线性变化 <span class="math inline">\(C\)</span><span class="math display">\[C^TAC=B\]</span></p><p>（1）可逆的线性变换不会改变矩阵的秩</p><p>（2）和对称矩阵合同的矩阵也是对称的 <span class="math display">\[B^T=(C^TAC)^T=C^TA^TC=C^TAC=B\]</span> （3）惯性定理（<spanclass="math inline">\(\text{Sylvester&#39;s law ofinertia}\)</span>）：</p><p>不论取什么样的可逆的线性变换，将二次型化为标准型后，正、负惯性指数不变（合同不变量）</p><p>两个矩阵合同</p><p><span class="math inline">\(A\simeq B\iff\)</span>具有相同的正、负惯性指数</p><p><span class="math inline">\(\iff\)</span> 相同的正、负特征值个数</p><p><span class="math inline">\(\iff\)</span>相同的秩以及正惯性指数（或负）</p><h2 id="正定">正定</h2><p>定义： <span class="math inline">\(n\)</span> 元二次型<spanclass="math inline">\(f(\mathbf{x})=\mathbf{x}^TA\mathbf{x}\)</span>正定 <span class="math inline">\(\iff \forall\mathbf{x}\ne0,\mathbf{x}^TA\mathbf{x}\gt0\)</span></p><p>充要条件：</p><p>正定<span class="math inline">\(\iff\)</span> <spanclass="math inline">\(\forall \mathbf{x}\ne0,\mathbf{x}^TA\mathbf{x}\gt0\)</span></p><p><span class="math inline">\(\iff\)</span> 特征值均正 <spanclass="math inline">\(\lambda_i\gt 0\)</span></p><p><span class="math inline">\(\iff f\)</span> 的正惯性指数为 <spanclass="math inline">\(p=n\)</span></p><p><span class="math inline">\(\iff\)</span> 所有顺序主子式为正（<spanclass="math inline">\(\text{Sylvester&#39;s Criterion}\)</span> ）</p><p><span class="math inline">\(\iff\)</span> 存在可逆矩阵 <spanclass="math inline">\(D,\quad A=D^TD\)</span>（<spanclass="math inline">\(\text{Cholesky}\)</span> 分解）</p><p>必要条件：</p><p><span class="math inline">\(\implies|A|\gt0\)</span></p><p><span class="math inline">\(\implies a_{ii}\gt0\)</span></p><p><span class="math inline">\(\text{Sylvester&#39;sCriterion}\)</span></p><p>矩阵 <span class="math inline">\(A\)</span> 正定 <spanclass="math inline">\(\iff\)</span> <spanclass="math inline">\(A\)</span>的<strong>全部顺序主子式</strong>为正</p><p>矩阵 <span class="math inline">\(A\)</span> 负定 <spanclass="math inline">\(\iff\)</span> <spanclass="math inline">\(A\)</span>的<strong>偶数阶</strong>顺序主子式为正，<strong>奇数阶</strong>顺序主子式为负</p><h2 id="最值问题">最值问题</h2><p>因为实二次型，一定有正交变换 <spanclass="math inline">\(\mathbf{x}=\mathbf{Q}\mathbf{y},\mathbf{Q}^T=\mathbf{Q}^{-1}\)</span><span class="math display">\[\mathbf{x}^TA\mathbf{x}=\mathbf{y}^T\Lambda\mathbf{y}=\sum_{i=1}^n\lambda_iy_i^2\\\min_{1\le i\le n}\{\lambda_i\}\sum_{i=1}^ny_i^2 \le\sum_{i=1}^n\lambda_iy_i^2 \le \max_{1\le i\len}\{\lambda_i\}\sum_{i=1}^ny_i^2\]</span></p><p>且 <span class="math display">\[\mathbf{x}^T\mathbf{x}=(\mathbf{Q}\mathbf{y})^T\mathbf{Q}\mathbf{y}=\mathbf{y}^T\mathbf{y}=\sum_{i=1}^ny_i^2\]</span> 所以 <span class="math display">\[\lambda_{min}\mathbf{x}^T\mathbf{x}\le\mathbf{x}^TA\mathbf{x}\le\lambda_{max}\mathbf{x}^T\mathbf{x}\\\iff\max\{\frac{f(\mathbf{x})}{\mathbf{x}^T\mathbf{x}}\}=\lambda_{max}\\\iff \min\{\frac{f(\mathbf{x})}{\mathbf{x}^T\mathbf{x}}\}=\lambda_{min}\]</span></p><h1 id="向量组的-gram-矩阵">向量组的 Gram 矩阵</h1><ol type="1"><li>交互 Gram 矩阵</li></ol><p>两个向量组的交互 Gram矩阵，可以计算两个向量组张成的子空间之间，任意向量的内积。</p><p>向量组张成的子空间中，内积运算化为矩阵运算。 <spanclass="math display">\[\begin{align}&lt;\sum_{i=1}^{s}k_i\alpha_i,\sum_{j=1}^{t}l_j\beta_j&gt; &amp;=(\begin{bmatrix}\alpha_1 &amp; \cdots &amp; \alpha_s\end{bmatrix}\begin{bmatrix}k_1\\\vdots\\k_s\end{bmatrix})^T\begin{bmatrix}\beta_1 &amp; \cdots &amp; \beta_t\end{bmatrix}\begin{bmatrix}l_1\\\vdots\\l_t\end{bmatrix}\\&amp; =\begin{bmatrix}k_1\\\vdots\\k_s\end{bmatrix}^T\begin{bmatrix}\alpha_1^T\\\vdots\\\alpha_s^T\end{bmatrix}\begin{bmatrix}\beta_1 &amp; \cdots &amp; \beta_t\end{bmatrix}\begin{bmatrix}l_1\\\vdots\\l_t\end{bmatrix}\\&amp;=\begin{bmatrix}k_1 &amp; \cdots &amp; k_s\end{bmatrix}\begin{bmatrix}\alpha_1^T\beta_1 &amp; \cdots &amp; \alpha_1^T\beta_t \\\vdots &amp; &amp; \vdots\\\alpha_s^T\beta_1 &amp; \cdots &amp; \alpha_s^T\beta_t\end{bmatrix}\begin{bmatrix}l_1\\\vdots\\l_t\end{bmatrix}\\&amp;=\mathbf{x}^T\mathbf{G}\mathbf{y}\end{align}\]</span></p><ol start="2" type="1"><li><p>一个向量组自己和自己的交互 Gram 矩阵，称为该向量组的 Gram矩阵</p><blockquote><p>向量组的 Gram 矩阵是对称、非负定的</p></blockquote></li><li><p>度量矩阵</p><blockquote><p>基向量组的 Gram 矩阵</p></blockquote></li></ol><h1 id="标准正交基">标准正交基</h1><h2 id="沿普通基">沿普通基</h2><blockquote><p>克莱默法则</p></blockquote><p>解方程组 <span class="math display">\[\begin{align}\mathbf{A}\mathbf{x} &amp;=\mathbf{b}\\\mathbf{x} &amp;= \mathbf{A}^{-1}\mathbf{b}\\\mathbf{x} &amp;=\frac{A^*}{|A|}\mathbf{b}\end{align}\]</span></p><p><span class="math inline">\(x\)</span> 的分量 <spanclass="math inline">\(x_j\)</span> 具体展开为 <spanclass="math display">\[x_{i}=\frac{b_1A_{1i}+\cdots+b_nA_{ni}}{|A|}\]</span></p><h2 id="沿正交基">沿正交基</h2><blockquote><p>解耦合，求第 j 个分量，只与第 j 个基有关。</p></blockquote><p>已知 <span class="math display">\[x_1\alpha_1+\cdots+x_n\alpha_n=\mathbf{b}\\\]</span> 等式两边同时左内积 <spanclass="math inline">\(\alpha_j\)</span> $$ <spanclass="math display">\[\begin{align}\langle\alpha_j,x_1\alpha_1+\cdots+x_j\alpha_j+\cdots+x_n\alpha_n\rangle&amp;=\langle\alpha_j,\mathbf{b}\rangle\\x_j\langle\alpha_j,\alpha_j\rangle&amp;=\langle\alpha_j,\mathbf{b}\rangle\\x_j&amp;=\frac{\langle\alpha_j,\mathbf{b}\rangle}{\langle\alpha_j,\alpha_j\rangle}\end{align}\]</span> $$</p><h1 id="最优化问题">最优化问题</h1><p>基于线性回归问题，目的是拟合模型参数，这里的未知量是参数 <spanclass="math display">\[\hat \beta=(X^TX)^{-1}X^Ty\]</span></p><p><strong>最小二乘拟合</strong>：</p><p>当方程数多于未知数个数时，寻找一个 <spanclass="math inline">\(x\)</span> 使残差的平方和最小 <spanclass="math display">\[\hat x=\arg\min_{x}\{\|Ax-b\|^2\}\]</span></p><p>目标函数 <span class="math display">\[J(x)=\|Ax-b\|^2=\langle Ax-b,Ax-b\rangle=(Ax-b)^T(Ax-b)\]</span> 展开 <span class="math display">\[\begin{align}J(x)&amp;=(Ax-b)^TAx-(Ax-b)^Tb\\&amp;=[(Ax)^T(Ax-b)]^T-b^T(Ax-b)\\&amp;=x^TA^TAx-x^TA^Tb-b^TAx-b^Tb\\&amp;=x^TA^TAx-2b^TAx-b^Tb\end{align}\]</span> 对 <span class="math inline">\(x\)</span> 求梯度，并令其为0<span class="math display">\[\nabla_x J(x)=2A^TAx-2A^Tb=0\]</span> 求解最小值等于求解最小二乘法的正规方程 <spanclass="math display">\[A^TAx=A^Tb\]</span></p><p>$$</p><p>$$</p><h1 id="技巧">技巧</h1><h2 id="解齐次方程组">解齐次方程组</h2><p>解方程组的秒杀技巧：</p><p>对于解齐次方程组 <spanclass="math inline">\(\mathbf{A}\mathbf{x}=\mathbf{0}\)</span>，若有无穷解（欠定解）</p><ol type="1"><li><p>将矩阵 <span class="math inline">\(\mathbf{A}\)</span>做<strong>同解变换（初等行变换）</strong>到<strong>行最简阶梯型矩阵</strong></p></li><li><p>取阶梯口列向量对应的变量为<strong>约束变量</strong>，其他位置的变量为<strong>自由变量</strong>（任意赋值）</p></li><li><p>构造一个解空间的极大线性无关组，其余位置的取值为：自由变量所在的列的系数<strong>反号顺抄</strong></p></li></ol><p>原理：将最简行阶梯矩阵的自由变量，移到等式的另外一边，然后找解空间的<strong>极大线性无关组</strong>，一般用标准正交基 <spanclass="math display">\[\left\{\begin{array}{lcl}x_1 &amp; = &amp; a_{11}x_{m+1}+a_{12}x_{m+2}+\cdots+a_{1(n-m)}x_n\\x_2 &amp; = &amp; a_{21}x_{m+1}+a_{22}x_{m+2}+\cdots+a_{2(n-m)}x_n\\&amp; \vdots &amp; \\x_m &amp; = &amp; a_{m1}x_{m+1}+a_{m2}x_{m+2}+\cdots+a_{m(n-m)}x_n\\\end{array}\right.\]</span> 其中 <span class="math inline">\(m\lt n\)</span>，左边是约束变量，右边是自由变量</p><p>一般的，我们将 <span class="math inline">\(n-m\)</span>维空间的一个极大无关组取为其 <strong>标准正交基</strong> <spanclass="math display">\[\begin{pmatrix}1 &amp; 0 &amp; \cdots &amp;0\\0 &amp; 1 &amp; \cdots &amp;0\\\vdots &amp;\vdots&amp; \ddots&amp;\vdots\\0&amp;0&amp;\cdots &amp;1\end{pmatrix}_{(n-m)\times (n-m)}\]</span>所以将某个自由变量置1，其余置0时，将一个标准基的一个分量带入时，对应的约束变量等于：对应<strong>自由变量</strong>的系数的<strong>反号顺抄</strong></p><h2 id="用正交求特征向量">用正交求特征向量</h2><p>（1）<spanclass="math inline">\(\lambda_1\ne\lambda_2\ne\lambda_3\)</span>，知2求3</p><p>设 <span class="math inline">\(\lambda_3=(x,y,z)\)</span></p><p>则解方程 <span class="math display">\[\left\{\begin{align}\lambda_3\perp\lambda_1\\\lambda_3\perp\lambda_2\\\end{align}\right.\]</span> （2）<span class="math inline">\(\lambda_1=(a_1,a_2,a_3),\quad \lambda_2=\lambda_3\)</span>，知单求重</p><p>设 <span class="math inline">\((x,y,z)\)</span> 属于 <spanclass="math inline">\(A\)</span> 的二维特征子空间，则解方程 <spanclass="math display">\[a_1 x+a_2 y+a_3 z=0\]</span></p><h2 id="公共解">公共解</h2><p>三个角度：</p><p>（1）<span class="math inline">\(A,B,\alpha,\beta\)</span>具体给出</p><p>解法：直接联立，解方程 <span class="math display">\[\begin{bmatrix}A\\B\end{bmatrix}x=0\quad\text{or}\quad\begin{bmatrix}A\\B\end{bmatrix}x=\begin{bmatrix}\alpha\\\beta\end{bmatrix}\]</span> （2）给出 <span class="math inline">\(A\)</span>的基础解系，和 <span class="math inline">\(B\)</span> 的具体表达式</p><p>解法：设 A 的通解 <spanclass="math inline">\(k_1\xi_1+k_2\xi_2+\cdots+k_s\xi_s\)</span>，并带入 <spanclass="math inline">\(Bx=0\)</span>，求出 <spanclass="math inline">\(k_i\)</span> 之间的关系，代回<spanclass="math inline">\(Ax=0\)</span> 的通解</p><p>（3）给出 <span class="math inline">\(A,B\)</span> 的基础解系</p><p>解法：设 <span class="math inline">\(A\)</span> 的通解 <spanclass="math inline">\(k_1\xi_1+k_2\xi_2+\cdots +k_s\xi_s\)</span>，<spanclass="math inline">\(B\)</span> 的通解 <spanclass="math inline">\(l_1\eta_1+l_2\eta_2+\cdots +l_t\eta_t\)</span></p><p>联立 <span class="math display">\[k_1\xi_1+k_2\xi_2+\cdots +k_s\xi_s=l_1\eta_1+l_2\eta_2+\cdots +l_t\eta_t\]</span> 解方程 <span class="math display">\[k_1\xi_1+k_2\xi_2+\cdots +k_s\xi_s-l_1\eta_1-l_2\eta_2-\cdots-l_t\eta_t=0\]</span></p><h2 id="同解">同解</h2><p><span class="math inline">\(A_{m\times n}\,\mathbf{x}=0,\quadB_{s\times n}\,\mathbf{x}=0\)</span> 同解</p><p><span class="math inline">\(\iff Ax=0\)</span> 的解满足 <spanclass="math inline">\(Bx=0\)</span>，互相带入</p><p><span class="math inline">\(\iff r(A)=r(B)\)</span>，<spanclass="math inline">\(Ax=0\)</span> 的解满足 <spanclass="math inline">\(Bx=0\)</span> 的解</p><p><span class="math inline">\(\iffr(A)=r(B)=r(\begin{bmatrix}A\\B\end{bmatrix})\)</span></p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>线性代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linear</tag>
      
      <tag>Algebra</tag>
      
      <tag>Math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>概率论 #0 应试笔记</title>
    <link href="/2024/10/10/%E6%95%B0%E5%AD%A6/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/%E6%A6%82%E7%8E%87%E8%AE%BA_0_%E5%BA%94%E8%AF%95%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/10/10/%E6%95%B0%E5%AD%A6/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/%E6%A6%82%E7%8E%87%E8%AE%BA_0_%E5%BA%94%E8%AF%95%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="概率公理化">概率公理化</h1><h2 id="概率空间">概率空间</h2><p>定义：概率空间是一个三元组 <spanclass="math inline">\((\Omega,\mathcal{F},P)\)</span></p><p>（1）<span class="math inline">\(\Omega\)</span>表示<strong>样本空间</strong></p><p>（2）<span class="math inline">\(\mathcal{F}\)</span>表示<strong>事件集合</strong>，是样本空间 <spanclass="math inline">\(\Omega\)</span> 的子集，是一个 <spanclass="math inline">\(\sigma\)</span> 代数。即满足：</p><ol type="1"><li>包含全集：<span class="math inline">\(\Omega\in\mathcal{F}\)</span></li><li>补集封闭：<span class="math inline">\(A\in \mathcal{F},\quad A^c\in\mathcal{F}\)</span></li><li>可数并运算封闭：<spanclass="math inline">\(A_n\in\mathcal{F},n=1,2,\cdots\)</span></li></ol><p><span class="math display">\[\bigcup_{n=1}^\infty A_n\in\mathcal{F}\]</span></p><p>在此，空间 <span class="math inline">\((\Omega,\mathcal{F})\)</span>是一个<strong>可测空间</strong>，在此空间上定义<strong>测度</strong></p><p>（3）<span class="math inline">\(P\)</span>表示<strong>概率测度</strong></p><p>概率测度 <span class="math inline">\(P:\mathcal{F}\to\mathbf{R}\)</span> 需要满足以下三个公理</p><ol type="1"><li><p>可数可加性： 如果 <spanclass="math inline">\(\{A_i\}_{i=1}^\infty \subset \mathcal{F}\)</span>为两两不相交的集合，则 <span class="math display">\[P(\bigcup_{i=1}^\infty A_i)=\bigcup_{i=1}^\infty P(A_i)\]</span></p></li><li><p>归一性：<span class="math inline">\(P(\Omega)=1\)</span></p></li><li><p>非负性：<span class="math inline">\(P(A)\ge 0\)</span></p></li></ol><h1 id="一大数定律">一、大数定律</h1><ol type="1"><li><p>切比雪夫大数定律</p><blockquote><p>强大数定律、一般性强，只要求方差存在且一致有上界</p></blockquote></li><li><p>伯努利大数定律</p><blockquote><p>频率在实验次数趋于无穷的情况下依概率收敛于概率</p></blockquote></li><li><p>辛钦大数定律</p><blockquote><p>独立同分布，期望存在</p></blockquote></li></ol><h1 id="二中心极限定理">二、中心极限定理</h1><ol type="1"><li><p>列维-林德伯格定理</p><blockquote><p>独立同分布，相加之后趋于正态分布</p></blockquote></li><li><p>棣莫佛-拉普拉斯定理</p><blockquote><p>二项分布，n越大，趋于正态分布</p></blockquote></li></ol><h1 id="三数理统计">三、数理统计</h1><ol type="1"><li><span class="math inline">\(E(\bar{\mathbf{X}})=\mu\)</span></li></ol><h1 id="四数字特征">四、数字特征</h1><p>特殊结论：</p><p>亚当公式（全期望公式）：</p><p><span class="math inline">\(E(X)=E(E(X\mid Y))\)</span></p><p>夏娃公式（总方差公式）：</p><p><span class="math inline">\(D(X)=E(D(X\mid Y))+D(E(X\midY))\)</span></p><p>丢出去公式：</p><p><span class="math inline">\(E(E(XY\mid Y))=YE(X\mid Y)\)</span></p><h1 id="五经典结论">五、经典结论</h1><ol type="1"><li>若 <span class="math inline">\(X\)</span> 的分布函数 $F_X(x)$<strong>严格单增加</strong>，则 <spanclass="math inline">\(Y=F_X(X)\)</span> 服从 <spanclass="math inline">\(U(0,1)\)</span> <span class="math display">\[\begin{align}F_Y(y) &amp;=P\{Y\le y\}=P\{F_X(X)\le y\}\\&amp;=P\{X\le F_X^{-1}(y)\}\\&amp;=F_X(F_X^{-1}(y))\\&amp;=y\end{align}\]</span></li></ol>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>概率论与数理统计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Math</tag>
      
      <tag>Probability</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高等数学 #1 几何物理应用</title>
    <link href="/2024/10/10/%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6_1_%E5%87%A0%E4%BD%95%E7%89%A9%E7%90%86%E5%BA%94%E7%94%A8/"/>
    <url>/2024/10/10/%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6_1_%E5%87%A0%E4%BD%95%E7%89%A9%E7%90%86%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="一元积分学几何应用">一元积分学几何应用</h1><h2 id="平面图形面积">平面图形面积</h2><p>（1）直角坐标系</p><p><span class="math inline">\(f(x),\ g(x),\ x=a,\ x=b\)</span>围城的平面图形面积 <span class="math display">\[\int_a^b|f(x)-g(x)|\,\mathrm{d}x\]</span> （2）极坐标系</p><p><span class="math inline">\(r_1(\theta),\ r_2(\theta),\\theta=\alpha,\ \theta=\beta\)</span> 围城的平面扇形面积 <spanclass="math display">\[\frac{1}{2}\int_\alpha^\beta|r_1^2(\theta)-r_2^2(\theta)|\,\mathrm{d}\theta\]</span></p><h2 id="旋转体体积">旋转体体积</h2><p>（1）曲线绕 <span class="math inline">\(x\)</span> 轴</p><p>解法：<span class="math inline">\(\text{Shell Method}\)</span> <spanclass="math display">\[\frac{\pi}{2}\int_a^bf^2(x)\,\mathrm{d}x\]</span> （2）曲线绕 <span class="math inline">\(y\)</span> 轴</p><p>解法：<span class="math inline">\(\text{Disc Method}\)</span> <spanclass="math display">\[2\pi\int_a^bx|f(x)|\,\mathrm{d}x\]</span> （3）曲线绕任意直线</p><p>解法： <span class="math display">\[V=\frac{\pi}{(A^2+B^2)^{\frac{3}{2}}}\int_a^b(A(x)+Bf(x)+C)^2|Af&#39;(x)-B|\,\mathrm{d}x\]</span> （4）区域绕任意直线（<strong>一般问题</strong>）</p><p>解法：<strong>古鲁金定理</strong>求体积，由此可以上升到<strong>二重积分</strong></p><p>等于该区域面积与几何中心经过的距离的乘积 <spanclass="math display">\[V=Sd_1\]</span> 即 <span class="math display">\[V=2\pi pS\]</span> 一般公式 <span class="math display">\[2\pi\iint_{D} r(x,y)\,\mathrm{d}\sigma\]</span></p><h2 id="旋转曲面侧面积">旋转曲面侧面积</h2><p>依据：曲线绕 <span class="math inline">\(x\)</span>轴旋转一周后，每个小区间会对应形成<strong>小环带</strong>，这个小环带的面积就是所需累计的微元</p><p>面积微元所含的是 <span class="math inline">\(\mathrm{d}s\)</span>而不是 <span class="math inline">\(\mathrm{d}x\)</span>，是因为<strong>微元法的基本原理</strong>，即不能保证误差为 <spanclass="math inline">\(dx\)</span> 高阶无穷小</p><p>（1）直角坐标系 <span class="math inline">\(y(x)\)</span> 绕 <spanclass="math inline">\(x\)</span> 轴转一圈</p><p><strong>古鲁金定理求表面积</strong>： <span class="math display">\[A=sd_2\]</span> 即 <span class="math display">\[A=2\pi ps\]</span></p><p><span class="math display">\[2\pi\int_a^b|y(x)|\,\sqrt{1+y&#39;(x)^2}\mathrm{d}x\]</span> （2）参数方程 <span class="math display">\[2\pi\int_\alpha^\beta |y(t)|\sqrt{x&#39;(t)^2+y&#39;(t)^2}\,\mathrm{d}t\]</span> （3）极坐标 <span class="math display">\[2\pi\int_\alpha^\beta|\rho(\theta)\sin\theta|\sqrt{\rho^2+\rho&#39;^2}\,\mathrm{d}\theta\]</span></p><h2 id="平面曲边梯形的形心">平面曲边梯形的形心</h2><p><span class="math display">\[\bar x=\frac{\iint_Dx\,\mathrm{d}\sigma}{\iint_D\mathrm{d}\sigma},\qquad \bary=\frac{\iint_D y\,\mathrm{d}\sigma}{\iint_D\mathrm{d}\sigma}\]</span></p><h2 id="平面曲线弧长">平面曲线弧长</h2><p>（1）直角坐标系 <span class="math display">\[S=\int_a^b\sqrt{1+f&#39;(x)^2}\,\mathrm{d}x\]</span> （2）参数方程 <span class="math display">\[S=\int_a^b\sqrt{x&#39;(t)^2+y&#39;(t)^2}\,\mathrm{d}t\]</span> （3）极坐标 <span class="math display">\[S=\int_a^b\sqrt{r(\theta)^2+r&#39;(\theta)^2}\,\mathrm{d}\theta\]</span></p><h1 id="一元积分学物理应用">一元积分学物理应用</h1><h2 id="变力沿直线做功">变力沿直线做功</h2><p>沿 <span class="math inline">\(x\)</span> 轴正向的力函数 <spanclass="math inline">\(y=F(x)(a\le x\le b)\)</span>，设物体从 <spanclass="math inline">\(a\)</span> 点到 <spanclass="math inline">\(b\)</span> 点时，变力 <spanclass="math inline">\(F(x)\)</span> 所做的功</p><p><span class="math display">\[W=\int_a^b F(x)\,\mathrm{d}x\]</span></p><h2 id="抽水做功">抽水做功</h2><p>微元法：将容器截面的一层水抽上来做功的累计 <spanclass="math display">\[W=\rho g\int_a^bxA(x)\,\mathrm{d}x\]</span></p><h2 id="静水压力">静水压力</h2><p><span class="math display">\[W=\rho g\int_a^b x[f(x)-g(x)]\,\mathrm{d}x\]</span></p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>高等数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构 简明教程</title>
    <link href="/2024/10/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/DataStructure/"/>
    <url>/2024/10/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/DataStructure/</url>
    
    <content type="html"><![CDATA[<!--more--><h1 id="一图">一、图</h1><h2 id="性质">性质</h2><ol type="1"><li>无向完全图边数：<spanclass="math inline">\(\frac{n(n-1)}{2}\)</span></li><li>无向图<strong>度与边</strong>的关系：<spanclass="math inline">\(TD=2|E|\)</span></li><li>有向图：<span class="math inline">\(|E|=ID=OD\)</span></li><li>邻接矩阵n次幂：<spanclass="math inline">\(\mathbf{A}^n_{[i][j]}\)</span> 表示路径长度为 n，i到 j 的路径的组合数。</li></ol><h2 id="存储结构">存储结构</h2><ol type="1"><li>邻接矩阵<ul><li>有向图</li><li>无向图</li></ul></li><li>邻接表<ul><li>有向图</li><li>无向图</li></ul></li><li>十字链表<ul><li>有向图</li></ul></li><li>邻接多重表<ul><li>无向图</li></ul></li></ol><h2 id="遍历算法">遍历算法</h2><p>定义：沿着某个顶点出发，通过边，访问图中的所有顶点，且仅访问一次。</p><p>核心：从一个顶点出发，可能沿着某条路径搜索又回到该顶点·，为了确保每个顶点只访问一次，所以需要辅助数组visited[] 标记结点是否已访问过。</p><ol type="1"><li><p>深度优先（DSF）</p><blockquote><p>是一个递归（回溯）算法，可以判断图是否有环</p></blockquote></li><li><p>广度优先（BSF）</p><blockquote><p>是一个迭代算法，利用队列先进先出来实现广度（深度）优先的遍历，注意节点应该在入队时进行访问，因为节点出队时候需要让邻居节点入队，为了使邻居不重复，要进行是否访问过判断。</p><p>如果出队时再进行访问，当上一层两个不同节点有一个相同的邻居，那么这个邻居会按照上一层节点访问按顺序入队两次</p><p>已经入队的节点还未被访问，有再次被重复访问的风险。</p></blockquote></li></ol><h2 id="特殊的图">特殊的图</h2><ol type="1"><li><p>稀疏图</p><blockquote><p>采用 <strong>邻接表</strong> 存储较好</p></blockquote></li><li><p>稠密</p><blockquote><p>采用 <strong>邻接矩阵</strong> 存储较好</p></blockquote></li></ol><h2 id="应用">应用</h2><h3 id="最小生成树">最小生成树</h3><p>算法利用的<strong>关键性质</strong>：设 <spanclass="math inline">\(G=(V,E)\)</span> 带权连通无向图，<spanclass="math inline">\(U\in V\)</span>，若 <spanclass="math inline">\((u,v)\)</span> 是一条权值最小的边，其中 <spanclass="math inline">\(u\in U,v\in V-U\)</span> 则必存在一颗包含 <spanclass="math inline">\((u,v)\)</span> 的最小生成树</p><ol type="1"><li>Prim 算法（加点）</li><li>Kruskal 算法（加边、并查集）</li><li>DFS 深度优先</li></ol><h3 id="最短路径">最短路径</h3><p>算法利用的<strong>关键性质</strong>：两点之间的最短路径也包含了路径上其他顶点间的最短路径</p><ol type="1"><li><span class="math inline">\(Dijkstra\)</span> 算法（类似Prim加点、更新距离）</li><li><span class="math inline">\(Floyd\)</span> 算法</li><li><span class="math inline">\(BFS\)</span> 广度优先</li></ol><h3 id="拓扑排序">拓扑排序</h3><p><span class="math inline">\(\text{TopologicSort}\)</span></p><p>性质：</p><p>若有向图的邻接矩阵为<strong>三角矩阵</strong>，则该图<strong>一定</strong>有拓扑序列</p><p>对象：有向无环图（<strong>AOV</strong>）</p><p>求解：</p><ol type="1"><li><p>常规：</p><ol type="1"><li>寻入度为0的顶点</li><li>删其出边</li><li>重复1、2，直到网空或不存在入度为0的点（必有环）</li></ol></li><li><p>DFS：</p><p>利用 DFS <strong>祖先顶点最后退栈的特性</strong></p><p>如果在退栈时输出，会是逆拓扑序列</p></li></ol><h3 id="关键路径">关键路径</h3><p>对象：带权有向无环图（<strong>AOE</strong> 网）</p><p>意义：求完成整个工程至少需要多长时间（最耗时的路径）</p><p>一些概念：</p><ol type="1"><li>关键活动：不能拖延的活动（最晚开始=最早开始）</li><li>关键路径：工程中，最长（最耗时）的路径（关键路径上的都是关键活动）</li><li>时间余量：<span class="math inline">\(l-e\)</span>普通活动可以拖延的时间</li></ol><p>几个参量：</p><ol type="1"><li><p><span class="math inline">\(v_e\)</span>（<strong>事件</strong>最早<strong>发生</strong>时间）</p></li><li><p><span class="math inline">\(v_l\)</span>（事件最晚发生时间）</p></li><li><p><span class="math inline">\(e\)</span>（<strong>活动</strong>早<strong>开始</strong>时间）</p></li><li><p><spanclass="math inline">\(l\)</span>（活动最晚开始时间）</p></li></ol><p>求法：</p><ol type="1"><li><p>拓扑排序求出 <spanclass="math inline">\(v_e\)</span>每个事件的最早发生时间（两点之间最长路径）</p><blockquote><p>源点和汇点不能拖延，<span class="math inline">\(v_e=v_l\)</span></p></blockquote></li><li><p>逆拓扑排序求 <span class="math inline">\(v_l\)</span>出每个事件最晚开始时间（点到汇点的最晚发生时间减去路径长度，最小的，若大于这个时间说明汇点会被拖延）</p></li><li><p>求 <span class="math inline">\(l\)</span>（活动最早开始时间）</p><blockquote><p>等于引出这个活动的点的最早发生时间</p></blockquote></li><li><p>求 <span class="math inline">\(e\)</span>（活动最晚开始时间）</p><blockquote><p>等于活动汇入点的最晚发生时间减去活动耗时。</p></blockquote></li></ol><h1 id="二树">二、树</h1><h2 id="性质-1">性质</h2><ol type="1"><li><p>二叉树<strong>度0结点与度2结点</strong>关系： <spanclass="math inline">\(n_0=n_2+1\)</span></p></li><li><p>树的<strong>顶点与边</strong>的关系：<spanclass="math inline">\(n=|E|+1\)</span></p></li><li><p>m 叉哈夫曼树的<strong>分支结点</strong>数 <spanclass="math inline">\(\frac{(n_0-1)}{(m-1)}\)</span></p></li><li><p>二叉哈夫曼<strong>非叶</strong>结点数 <spanclass="math inline">\(n_0-1\)</span></p></li><li><p>二叉哈夫曼<strong>结点总数</strong> <spanclass="math inline">\(2n_0-1\)</span></p></li><li><p>树转二叉树，<strong>右指针为空</strong>的结点数 <spanclass="math inline">\(n_{(非叶)}+1\)</span></p></li><li><p>有 n个结点的二叉树<strong>已知前序序列</strong>，求可能的二叉树个数（等价于以n 个不同元素进栈，不同的出栈序列个数）<spanclass="math inline">\(\frac{1}{n+1}C_{2n}^{n}\)</span></p></li><li><p>二叉哈夫曼树的 <strong>WPL(带权路径长度)</strong> 等于<strong>所有非叶权值的总和</strong></p></li><li><p>二叉树</p><ul><li><p>满二叉树</p></li><li><p>完全二叉树</p><ul><li>堆（Heap）</li></ul></li><li><p>二叉排序树</p><blockquote><p>BST，构建一颗BST，可以使查找、删除效率为 <spanclass="math inline">\(O(\log_2n)\)</span></p></blockquote></li><li><p>平衡二叉树</p><blockquote><p>AVT，被优化的二叉排序树</p></blockquote></li></ul></li><li><p>树</p><ul><li><p>双亲表示法</p></li><li><p>孩子表示法</p></li><li><p>孩子兄弟表示法</p><blockquote><p>双链表结构</p></blockquote></li></ul></li></ol><h2 id="二叉树的非递归遍历">二叉树的非递归遍历</h2><h3 id="先序非递归">先序非递归</h3><p>循环：</p><ol type="1"><li>一直向左遍历左子，直到左子为空。（在这个过程中，同时访问当前节点，并压栈）</li><li>遍历指针转向到栈顶（当前层次）的右子，并且弹栈（当前层的根，在步骤1，第一次遇到时，已经访问完成）。（返回步骤1）</li></ol><h3 id="中序非递归">中序非递归</h3><p>循环：</p><ol type="1"><li><p>一直向左遍历左子树，直到左子树空。（遍历过程中，不断压栈，记录了访问路径）</p></li><li><p>访问栈顶（第二次遇见时访问的）（左子空，说明是时候访问该节点），弹栈（说明当前层访问完了，理应弹出），遍历指针指向当前层次的右子。（返回步骤1）</p><blockquote><p>因为当前根节点被弹出，所以如果当转向的右子树为空，会返回到上一层的根节点，此时上一层根节点的左子已经访问完成，转向右子。刚好遍历指针被赋值为右子，而右子是空，表明上一个层次的左子空，所以分支又会回到2，执行右转。</p></blockquote></li></ol><h3 id="后序非递归">后序非递归</h3><p>循环：</p><ol type="1"><li><p>一直遍历左子树，直到左子树为空。（遍历过程中，不断压栈，记录根遍历路径）</p></li><li><p>看当前层的根是否存在右子，且未被访问过</p><ul><li><p>如果是，说明，右子还未遍历。则遍历指针右转</p></li><li><p>如果不是，则说明，左子、右子已经结束，应该访问根节点。弹栈弹出当前层的根并访问，并标记此根已访问（标志右子完成）</p><blockquote><p>不要忘记将当前的遍历指针置NULL，再返回上一层时，他标志着，上一层的左子已经遍历完毕。</p></blockquote></li></ul></li></ol><h2 id="树森林的遍历">树、森林的遍历</h2><ol type="1"><li><p>树的<strong>先根序列</strong>对应其二叉树的<strong>先序序列</strong></p></li><li><p>树的<strong>后根序列</strong>对应其二叉树的<strong>中序序列</strong></p></li><li><p>森林的<strong>先序序列</strong>对应其二叉树的<strong>先序序列</strong></p></li><li><p>森林的<strong>中序序列</strong>对应其二叉树的<strong>中序序列</strong></p><blockquote><p>称中序遍历是相对其二叉树而言的，也叫后序遍历，因为根确实是最后访问的</p></blockquote></li></ol><h1 id="三catalan-数">三、Catalan 数</h1><h2 id="计算">计算</h2><p><span class="math display">\[C_n={2n \choose n }-{2n \choose n-1}=\frac{1}{n+1}{2n \choose n}\]</span></p><h2 id="意义">意义</h2><ol type="1"><li><p>n个不同元素进栈（栈无限容量），有多少个合法的出栈序列</p><blockquote><p>计算总的：不考虑合法性，n进n出，总共2n步，2n步里面选n步出栈，共<spanclass="math inline">\({2n \choose n}\)</span> 种方案。</p><p>计算非法：非法组合（是在总组合里面）等价于对称 y=-1 ，折射后终点在(2n,-2)，即最后多出栈两次的无条件组合，即 <spanclass="math inline">\(2n\choose n-1\)</span></p><p>合法的：总的-非法</p></blockquote></li><li><p>n个结点的二叉树，有多少种</p><blockquote><p>先序遍历和中序遍历类似，即给定n个不同的元素进站，出栈顺序有 <spanclass="math inline">\(C_n\)</span> 种</p></blockquote></li></ol><h1 id="四查找">四、查找</h1><h2 id="结构">结构</h2><p>查找表：</p><ol type="1"><li>静态查找表</li><li>动态查找表</li></ol><p>查找法：</p><ol type="1"><li><p>顺序查找（线性查找）</p></li><li><p>分块查找（索引查找）</p><blockquote><p>n 个元素线性表，均匀分 b 块，每块 s个元素（索引表、块内都采用顺序查找） <span class="math display">\[\begin{aligned}ASL&amp;=L_1+L_2\\&amp;=\frac{b+1}{2}+\frac{s+1}{2}\\&amp;=\frac{s^2+2s+n}{2s}\end{aligned}\]</span> <spanclass="math inline">\(f’(s)=\frac{1}{2}-\frac{n}{2s^2}\)</span> 当 <spanclass="math inline">\(s=\sqrt{n}\)</span> 时，ASL 最小，<spanclass="math inline">\(ASL_{min}=\sqrt{n}+1\)</span></p></blockquote></li><li><p>折半查找</p><p>适用：<strong>有序</strong>的<strong>顺序表</strong></p><p>效率分析：构造判定树</p></li><li><p>树形查找</p><ul><li>二叉搜索树 （BST）</li><li>平衡二叉树（AVT）</li><li>红黑树</li><li>B-树</li><li>B+树</li></ul></li></ol><p>评价指标：</p><p>平均查找长度 <span class="math display">\[ASL=\sum_{i=1}^{n}P_iC_i\]</span></p><h2 id="折半查找">折半查找</h2><p><strong>判定树</strong>特性：</p><ol type="1"><li><p><span class="math inline">\(\text{mid}=\lfloor \frac{low+high}{2}\rfloor\)</span></p><p>右子树节点数-左子树节点数=0、1</p></li><li><p><span class="math inline">\(\text{mid}=\lceil\frac{low+high}{2}\rceil\)</span></p><p>左子树节点数-右子树节点数=0、1</p></li><li><p>一定是<strong>平衡二叉树</strong></p></li><li><p>只有最下层是不满的</p></li><li><p>n 个成功结点、n+1 失败结点（空链域）</p></li></ol><h2 id="树形查找">树形查找</h2><h3 id="二叉搜索树bst">二叉搜索树（BST）</h3><ol type="1"><li><p>查找</p><p>遍历 BST 进行比较，在树均衡的情况下查找效率达到 <spanclass="math inline">\(O(\log_2n)\)</span></p></li><li><p>构建</p><p>本质是查找过程，在数据本来有序情况下，退化成单边树（链表）</p></li><li><p>插入</p><p>插入本质是查找过程</p></li><li><p>删除</p><ul><li><p>叶子结点：直接删除</p></li><li><p>只有左子或右子的结点：<strong>直接</strong>让左子或右子<strong>代替</strong>它就行了</p></li><li><p>即有左子又有右子：找<strong>左子中最大者（或右子最小者）</strong>代替删除结点，然后在该左子最大（右子最小）结点<strong>原来位置处删除</strong>它</p><blockquote><p>最终于会转换为前两种情况</p></blockquote></li></ul><p>效率：（1）均衡情况下 <spanclass="math inline">\(O(\log_2n)\)</span>（2）最坏情况退化成链表，<spanclass="math inline">\(O(n)\)</span></p></li></ol><h3 id="平衡二叉树avl">平衡二叉树（AVL）</h3><p>named after <strong>Adelson Velsky</strong> and<strong>Landis</strong></p><h4 id="性质-2">性质</h4><p>前提：本身是一颗二叉搜索树</p><p>解决问题：解决了一般 BST 在极端情况下，退化成链表的情况</p><p>特性：引入了平衡因子（左子高-右子高），|（左子树高度-右子树高度）|≤1</p><p>高度为 <span class="math inline">\(h\)</span> 的 AVL树<strong>结点最少</strong>的情况：<spanclass="math inline">\(n_h=n_{h-2}+n_{h-1}+1\)</span> （显然 <spanclass="math inline">\(n_0=0,\quad n_1=1,\quad n_2=2\)</span>）</p><pre><code class=" mermaid">flowchart T_h--&gt;T_h-1T_h--&gt;T_h-2</code></pre><h4 id="结点失衡">结点失衡</h4><p>失衡情况</p><ol type="1"><li><p>LL型</p><p>冲突的原因：加入结点在失衡结点的<strong>左孩子</strong>的<strong>左子树</strong>上</p><p>特征：失衡结点平衡因子=2，左孩子的平衡因子=1</p><p>解决：失横结点<strong>直接右旋</strong></p></li><li><p>RR型</p><p>冲突的原因：加入结点在失衡结点的<strong>右孩子</strong>的<strong>右子树</strong>上</p><p>特征：失衡结点平衡因子=-2，左孩子的平衡因子=-1</p><p>解决：失横结点<strong>直接左旋</strong></p></li><li><p>LR型</p><p>冲突的原因：加入结点在失衡结点的<strong>左孩子</strong>的<strong>右子树</strong>上</p><p>特征：失衡结点平衡因子=2，左孩子的平衡因子=-1</p><p>解决：先<strong>左孩子左旋</strong>，转换成LL型，再失将衡节点<strong>右旋</strong></p></li><li><p>RL型</p><p>冲突的原因：加入结点在失衡结点的<strong>右孩子</strong>的<strong>左子树</strong>上</p><p>特征：失衡结点平衡因子=-2，左孩子的平衡因子=1</p><p>解决：先<strong>右孩子右旋</strong>，转换成LL型，再失将衡节点<strong>左旋</strong></p></li><li><p>左旋</p><p>左孩冲突变右孩</p></li><li><p>右旋</p><p>右孩冲突变左孩</p></li></ol><h3 id="红黑树red-black-tree">红黑树（Red-Black Tree）</h3><h4 id="性质-3">性质</h4><ol type="1"><li><p>是一颗二叉搜索树（<strong>左根右</strong>）</p></li><li><p>根和叶子结点是黑色（<strong>根叶黑</strong>）</p><p>注意：这里的叶子是补全的<strong>NULL结点</strong></p></li><li><p>不能出现连续的红色结点（<strong>不红红</strong>）</p></li><li><p>任意结点到叶子结点的所有路径上的黑色结点数目相同（<strong>黑路同</strong>）</p></li><li><p>最长路径不超过<strong>最短路径的2倍</strong></p></li></ol><h4 id="插入策略">插入策略</h4><p>插入的结点默认设置成<strong>红色的</strong>。（应为插入红色相比于黑色，对红黑树影响较小一点）</p><p>插入之后，红黑树的性质被破坏，分<strong>三种情况</strong>进行调整：</p><ol type="1"><li><p>插入的是根结点</p><blockquote><p>直接变黑</p></blockquote></li><li><p>插入结点的叔叔结点是红色</p><blockquote><p>对插入结点上层的结点，红变黑，黑变红，将爷爷结点看做插入结点，继续判断</p></blockquote></li><li><p>插入结点的叔叔结点是黑色</p><blockquote><p>根据（LL、LR、RR、RL）进行旋转操作，然后变色</p></blockquote></li></ol><h4 id="删除情况">删除情况</h4><p>与二叉搜索树的删除略同，删除后判定是否违反红黑树性质，若是，则调整</p><ol type="1"><li><p>只有左或者右子树情况，直接将代替后的<strong>孩子变黑</strong></p><ul><li>黑红左</li><li>黑红右</li></ul></li><li><p>叶子结点</p><ul><li><p>红（直接删除就行了，不会破坏<strong>黑路同</strong>）</p></li><li><p>黑（最复杂，删除后变成<strong>双黑结点</strong>）</p><blockquote><p>引入双黑表示，经过它的路径都少了一个黑结点，调整就是<strong>消除双黑</strong>的过程</p></blockquote></li></ul></li></ol><h5 id="删除的叶子结点是黑色">删除的叶子结点是黑色</h5><ol type="1"><li><p>兄弟是黑色</p><ul><li><p>兄弟孩子至少有一个红色：根据（LL、LR、RR、RL)先变色，后旋转，双黑变单黑</p><blockquote><p>变色规则：</p><ol type="1"><li>LL、RR型（red 变 sibling，sibling 变 parent，parent 变黑）</li><li>LR、RL型（r 变 p，p 变黑）</li></ol></blockquote></li><li><p>兄弟孩子全黑：兄弟变红，双黑上移（继续调整），若遇<strong>红或根</strong>变单黑（调整结束）</p></li></ul></li><li><p>兄弟是红色</p><blockquote><p>兄父变色，朝双黑旋转（保持双黑，继续调整）</p></blockquote></li></ol><h3 id="b-树多路平衡搜索树">B-树（多路平衡搜索树）</h3><p>硬盘特性：读取<strong>物理地址连续的多个字节</strong>操作，和<strong>读取单个字节</strong>的操作耗时是几乎无区别</p><p>性质：</p><ol type="1"><li><p>访问结点是在<strong>硬盘中</strong>进行，结点内的操作是在<strong>内存中</strong>进行的</p></li><li><p><strong>平衡</strong>（所以叶子节点在同一层）</p></li><li><p><strong>有序</strong>（结点内部有序，左子、根、右子有序）</p></li><li><p><strong>多路</strong></p><blockquote><p>m 阶 B树：</p><p>最多：m个分支，m-1 个元素</p><p>最少：根结点: 2个分子、1个元素</p><p>​ ：其他结点最少 <spanclass="math inline">\(\lceil\frac{m}{2}\rceil\)</span> 个分支、<spanclass="math inline">\(\lceil\frac{m}{2}\rceil-1\)</span>个元素（考虑失败结点）</p></blockquote></li></ol><h4 id="插入策略-1">插入策略</h4><p>插入过程：（插入的过程可能导致<strong>上溢出</strong>）</p><p>（1）查找到待插入的位置（必定落到叶子结点）</p><p>（2）判定是否产生上溢</p><p>​ 产生溢出后，做调整（中间元素 <spanclass="math inline">\(\lceil\frac{m}{2}\rceil\)</span>上移，两边分裂），如果有连锁反应，则继续调整</p><h4 id="删除策略">删除策略</h4><p>删除过程：（删除过程可能导致<strong>下溢出</strong>（注意考虑失败结点），需调整）</p><p>（1）类似二叉搜索树，删除<strong>非叶</strong>结点，转化为删除他的<strong>直接前驱或后继</strong> 问题</p><p>（2）删除<strong>叶结点</strong></p><p>​ 无溢出，则直接删除</p><p>​ 下溢出，兄弟是否够借？</p><p>​ 够借，父下来，兄上去</p><p>​ 不够，合并</p><h3 id="b树">B+树</h3><p>背景：使用 B-树 遍历所有元素太麻烦。</p><p>特性：</p><ol type="1"><li>叶结点层包含所有的元素（且有序，结点间有指针）</li><li>非叶节点部分相当于叶结点层的<strong>索引</strong>（多级索引结构）（一个元素对应一个子树m=m）</li><li>B+树兼顾了<strong>顺序查找</strong>（链表）、<strong>随机查找</strong>（多级索引）和<strong>范围查找</strong>（先随机找范围内第一个，然后顺序）</li></ol><h2 id="散列查找">散列查找</h2><p>散列函数：</p><ol type="1"><li>直接定地址法</li><li>除留余数法</li><li>数字分析法</li><li>平方取中法</li></ol><p>冲突处理：</p><ol type="1"><li><p>开放定址法（<span class="math inline">\(\text{OpeningAddressing}\)</span>） <span class="math display">\[H_i=(H(key)+d_i) \bmod m\]</span></p><ul><li><p>线性探测法（<span class="math inline">\(\text{LinearProbing}\)</span>）</p><p>增量序列：<spanclass="math inline">\(1,2,3,4,\cdots,m-1\)</span></p></li><li><p>平方探测法（<span class="math inline">\(\text{QuadraticProbing}\)</span>）</p><p>增量 <span class="math inline">\(d_i\)</span> 取：<spanclass="math inline">\(1,-1,2^2,-2^2,\cdots,k^2,-k^2(k\le\frac{m}{2})\)</span></p><p>条件：表长 <spanclass="math inline">\(m=4j+3\)</span>，才能将表全部探测完</p></li><li><p>伪随机序列探测法</p><p>增量取：伪随机数序列</p></li><li><p>再散列法</p></li></ul></li><li><p>拉链法（<spanclass="math inline">\(\text{Chaining}\)</span>）</p></li></ol><h1 id="五排序">五、排序</h1><h2 id="分类">分类</h2><ol type="1"><li><p>插入排序</p><p>（1）直接插入排序：将无序的子序列插入到有序的子序列，<strong>顺序查找</strong>插入的位置</p><p>（2）折半插入排序：<strong>折半查找</strong>插入的位置</p><p>（3）希尔排序：<strong>增量缩小</strong>，组内采用插入排序</p></li><li><p>比较排序</p><p>（1）冒泡排序：每趟<strong>通过冒泡的方式</strong>归位一个最大或最小的元素</p><p>（2）快速排序：每趟<strong>选择枢轴</strong>，归位枢轴后，递归处理子序列</p></li><li><p>选择排序</p><p>（1）简单选择排序：每趟<strong>简单选择</strong>一个最大的元素，将其归位</p><p>（2）堆排序：用<strong>堆结构</strong>来实现选择</p></li><li><p>归并排序（<span class="math inline">\(\text{MergeSort}\)</span>）：基于 <strong>Merge</strong> 操作的排序</p><p>（1）自顶向下（递归）</p><p>（2）自底向上（非递归）</p></li><li><p>基数排序（<span class="math inline">\(\text{RadixSort}\)</span>）：不基于比较的排序</p></li></ol><h2 id="堆排序">堆排序</h2><p>是一种选择排序，利用最大二叉堆的性质，每趟选择最大的元素归位。</p><p>二叉堆是一个<strong>完全二叉树</strong>，可以用<strong>顺序表</strong>一一映射。</p><p>堆排序的步骤：</p><p>（1）建堆 <span class="math inline">\(O(n)\)</span></p><p>从<strong>最后一个非叶节点</strong>开始依次<strong>向下调整</strong></p><p>（2）排序 <span class="math inline">\(O(n\log_2n)\)</span></p><p>每轮堆顶换到最后（<strong>归位</strong>），然后<strong>向下调整</strong></p><p>堆排序是一种不稳定的选择排序</p><h2 id="基数排序">基数排序</h2><p>流程：</p><p>最低位入桶，顺序拿出</p><p>再入桶，再拿出</p><h2 id="结论">结论</h2><p>（1）基于比较的排序，至少（确保排序成功）需要进行的两两关键字之间的比较次数<span class="math display">\[\lceil \log_{2}n!\rceil\]</span></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data</tag>
      
      <tag>Structure</tag>
      
      <tag>Computer</tag>
      
      <tag>Science</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编码 #0 Base64</title>
    <link href="/2024/10/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A0%81/%E7%BC%96%E7%A0%81_0_base64/"/>
    <url>/2024/10/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A0%81/%E7%BC%96%E7%A0%81_0_base64/</url>
    
    <content type="html"><![CDATA[<h1 id="base64">Base64</h1><blockquote><p>对字节流进行安全地传输</p><p><strong>base64的作用，是让8-bit字节流以6-bit一组，编码为字符串安全地通过7-bitASCII设备</strong></p></blockquote><h2 id="design">1. Design</h2><p>The particular set of 64 characters chosen to represent the 64-digitvalues for the base varies between implementations. The general strategyis to</p><p>choose 64 characters that are common to most encodings and that arealso printable. This combination leaves the data unlikely to be modifiedin transit</p><p>through information systems, such as email, that were traditionallynot 8-bit clean.For example, MIME's Base64 implementation uses<code>A</code>–<code>Z</code>, <code>a</code>–<code>z</code>, and</p><p><code>0</code>–<code>9</code> for the first 62 values. Othervariations share this property but differ in the symbols chosen for thelast two values; an example is UTF-7.</p><h2 id="base64-table-from-rfc-4648">2. Base64 table from RFC 4648</h2><table><thead><tr><th style="text-align: center;">Index</th><th style="text-align: center;">Binary</th><th style="text-align: center;">Char</th><th style="text-align: center;">Index</th><th style="text-align: center;">Binary</th><th style="text-align: center;">Char</th><th style="text-align: center;">Index</th><th style="text-align: center;">Binary</th><th style="text-align: center;">Char</th><th style="text-align: center;">Index</th><th style="text-align: center;">Binary</th><th style="text-align: center;">Char</th></tr></thead><tbody><tr><td style="text-align: center;">0</td><td style="text-align: center;">000000</td><td style="text-align: center;"><code>A</code></td><td style="text-align: center;">16</td><td style="text-align: center;">010000</td><td style="text-align: center;"><code>Q</code></td><td style="text-align: center;">32</td><td style="text-align: center;">100000</td><td style="text-align: center;"><code>g</code></td><td style="text-align: center;">48</td><td style="text-align: center;">110000</td><td style="text-align: center;"><code>w</code></td></tr><tr><td style="text-align: center;">1</td><td style="text-align: center;">000001</td><td style="text-align: center;"><code>B</code></td><td style="text-align: center;">17</td><td style="text-align: center;">010001</td><td style="text-align: center;"><code>R</code></td><td style="text-align: center;">33</td><td style="text-align: center;">100001</td><td style="text-align: center;"><code>h</code></td><td style="text-align: center;">49</td><td style="text-align: center;">110001</td><td style="text-align: center;"><code>x</code></td></tr><tr><td style="text-align: center;">2</td><td style="text-align: center;">000010</td><td style="text-align: center;"><code>C</code></td><td style="text-align: center;">18</td><td style="text-align: center;">010010</td><td style="text-align: center;"><code>S</code></td><td style="text-align: center;">34</td><td style="text-align: center;">100010</td><td style="text-align: center;"><code>i</code></td><td style="text-align: center;">50</td><td style="text-align: center;">110010</td><td style="text-align: center;"><code>y</code></td></tr><tr><td style="text-align: center;">3</td><td style="text-align: center;">000011</td><td style="text-align: center;"><code>D</code></td><td style="text-align: center;">19</td><td style="text-align: center;">010011</td><td style="text-align: center;"><code>T</code></td><td style="text-align: center;">35</td><td style="text-align: center;">100011</td><td style="text-align: center;"><code>j</code></td><td style="text-align: center;">51</td><td style="text-align: center;">110011</td><td style="text-align: center;"><code>z</code></td></tr><tr><td style="text-align: center;">4</td><td style="text-align: center;">000100</td><td style="text-align: center;"><code>E</code></td><td style="text-align: center;">20</td><td style="text-align: center;">010100</td><td style="text-align: center;"><code>U</code></td><td style="text-align: center;">36</td><td style="text-align: center;">100100</td><td style="text-align: center;"><code>k</code></td><td style="text-align: center;">52</td><td style="text-align: center;">110100</td><td style="text-align: center;"><code>0</code></td></tr><tr><td style="text-align: center;">5</td><td style="text-align: center;">000101</td><td style="text-align: center;"><code>F</code></td><td style="text-align: center;">21</td><td style="text-align: center;">010101</td><td style="text-align: center;"><code>V</code></td><td style="text-align: center;">37</td><td style="text-align: center;">100101</td><td style="text-align: center;"><code>l</code></td><td style="text-align: center;">53</td><td style="text-align: center;">110101</td><td style="text-align: center;"><code>1</code></td></tr><tr><td style="text-align: center;">6</td><td style="text-align: center;">000110</td><td style="text-align: center;"><code>G</code></td><td style="text-align: center;">22</td><td style="text-align: center;">010110</td><td style="text-align: center;"><code>W</code></td><td style="text-align: center;">38</td><td style="text-align: center;">100110</td><td style="text-align: center;"><code>m</code></td><td style="text-align: center;">54</td><td style="text-align: center;">110110</td><td style="text-align: center;"><code>2</code></td></tr><tr><td style="text-align: center;">7</td><td style="text-align: center;">000111</td><td style="text-align: center;"><code>H</code></td><td style="text-align: center;">23</td><td style="text-align: center;">010111</td><td style="text-align: center;"><code>X</code></td><td style="text-align: center;">39</td><td style="text-align: center;">100111</td><td style="text-align: center;"><code>n</code></td><td style="text-align: center;">55</td><td style="text-align: center;">110111</td><td style="text-align: center;"><code>3</code></td></tr><tr><td style="text-align: center;">8</td><td style="text-align: center;">001000</td><td style="text-align: center;"><code>I</code></td><td style="text-align: center;">24</td><td style="text-align: center;">011000</td><td style="text-align: center;"><code>Y</code></td><td style="text-align: center;">40</td><td style="text-align: center;">101000</td><td style="text-align: center;"><code>o</code></td><td style="text-align: center;">56</td><td style="text-align: center;">111000</td><td style="text-align: center;"><code>4</code></td></tr><tr><td style="text-align: center;">9</td><td style="text-align: center;">001001</td><td style="text-align: center;"><code>J</code></td><td style="text-align: center;">25</td><td style="text-align: center;">011001</td><td style="text-align: center;"><code>Z</code></td><td style="text-align: center;">41</td><td style="text-align: center;">101001</td><td style="text-align: center;"><code>p</code></td><td style="text-align: center;">57</td><td style="text-align: center;">111001</td><td style="text-align: center;"><code>5</code></td></tr><tr><td style="text-align: center;">10</td><td style="text-align: center;">001010</td><td style="text-align: center;"><code>K</code></td><td style="text-align: center;">26</td><td style="text-align: center;">011010</td><td style="text-align: center;"><code>a</code></td><td style="text-align: center;">42</td><td style="text-align: center;">101010</td><td style="text-align: center;"><code>q</code></td><td style="text-align: center;">58</td><td style="text-align: center;">111010</td><td style="text-align: center;"><code>6</code></td></tr><tr><td style="text-align: center;">11</td><td style="text-align: center;">001011</td><td style="text-align: center;"><code>L</code></td><td style="text-align: center;">27</td><td style="text-align: center;">011011</td><td style="text-align: center;"><code>b</code></td><td style="text-align: center;">43</td><td style="text-align: center;">101011</td><td style="text-align: center;"><code>r</code></td><td style="text-align: center;">59</td><td style="text-align: center;">111011</td><td style="text-align: center;"><code>7</code></td></tr><tr><td style="text-align: center;">12</td><td style="text-align: center;">001100</td><td style="text-align: center;"><code>M</code></td><td style="text-align: center;">28</td><td style="text-align: center;">011100</td><td style="text-align: center;"><code>c</code></td><td style="text-align: center;">44</td><td style="text-align: center;">101100</td><td style="text-align: center;"><code>s</code></td><td style="text-align: center;">60</td><td style="text-align: center;">111100</td><td style="text-align: center;"><code>8</code></td></tr><tr><td style="text-align: center;">13</td><td style="text-align: center;">001101</td><td style="text-align: center;"><code>N</code></td><td style="text-align: center;">29</td><td style="text-align: center;">011101</td><td style="text-align: center;"><code>d</code></td><td style="text-align: center;">45</td><td style="text-align: center;">101101</td><td style="text-align: center;"><code>t</code></td><td style="text-align: center;">61</td><td style="text-align: center;">111101</td><td style="text-align: center;"><code>9</code></td></tr><tr><td style="text-align: center;">14</td><td style="text-align: center;">001110</td><td style="text-align: center;"><code>O</code></td><td style="text-align: center;">30</td><td style="text-align: center;">011110</td><td style="text-align: center;"><code>e</code></td><td style="text-align: center;">46</td><td style="text-align: center;">101110</td><td style="text-align: center;"><code>u</code></td><td style="text-align: center;">62</td><td style="text-align: center;">111110</td><td style="text-align: center;"><code>+</code></td></tr><tr><td style="text-align: center;">15</td><td style="text-align: center;">001111</td><td style="text-align: center;"><code>P</code></td><td style="text-align: center;">31</td><td style="text-align: center;">011111</td><td style="text-align: center;"><code>f</code></td><td style="text-align: center;">47</td><td style="text-align: center;">101111</td><td style="text-align: center;"><code>v</code></td><td style="text-align: center;">63</td><td style="text-align: center;">111111</td><td style="text-align: center;"><code>/</code></td></tr><tr><td style="text-align: center;">Padding</td><td style="text-align: center;">=</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr></tbody></table><h2 id="encoding-decoding">3. Encoding &amp; Decoding</h2><p>24-bits一组，为1个<strong>编码块</strong>，也就是说1个编码块包含<strong>3个字节或者4个字符</strong>，若最后一个编码块<strong>不足24-bits</strong>，则补0将其补全，最后补的0用<code>=</code>解释</p><p>若最后一个编码块有1个<code>=</code>，则表示最多能解码2个字节；</p><p>若最后一个编码块有2个<code>=</code>，则表示最多能解码1个字节；</p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>编码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Computer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统 #0 应试笔记</title>
    <link href="/2024/10/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_0_%E5%BA%94%E8%AF%95%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/10/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_0_%E5%BA%94%E8%AF%95%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章操作系统概述">第一章、操作系统概述</h1><h2 id="定义">定义</h2><p>操作系统是计算机中的一个<strong>系统软件</strong>，它是这样一些程序模块的<strong>集合</strong>——它们管理和控制计算机系统中的硬件和软件资源，合理地组织计算机的工作流程，以便有效地利用这些资源为用户提供一个具有<strong>足够的功能</strong>，<strong>使用方便</strong>，<strong>可扩展</strong>，<strong>安全和可管理的</strong>工作环境，从而在计算机与其用户之间起到<strong>接口</strong>的作用。</p><h2 id="五大功能">五大功能</h2><ol type="1"><li>处理机管理（进程管理）</li><li>存储管理</li><li>设备管理</li><li>文件系统管理</li><li>用户接口</li></ol><h2 id="四个主要特点">四个主要特点</h2><ul><li>可靠性</li><li>安全性</li><li>可用性</li><li>可管理性</li></ul><h2 id="主要特征">主要特征</h2><ul><li>并发|Concurrency</li><li>共享|Sharing</li><li>虚拟|Virtual</li><li>异步|Asynchronism</li></ul><h2 id="发展史">发展史</h2><ul><li>批处理操作系统|Batch Processing</li><li>分时系统|Time-Sharing System</li><li>实时系统|Real-Time</li><li>通用操作系统|General Purpose</li><li>个人计算机操作系统|PC</li><li>网络操作系统</li><li>分布式操作系统</li></ul><h2 id="内核">内核</h2><ul><li><p>时钟管理</p></li><li><p>中断机制</p></li><li><p>原语</p></li><li><p>系统控制的数据结构及处理</p></li></ul><h1 id="第二章用户接口">第二章、用户接口</h1><h1 id="第三章进程管理">第三章、进程管理</h1><h2 id="进程基本概念">3.1 进程基本概念</h2><p>为了能够精确地描述和研究程序在系统中运行的情况，引入了进程的概念。</p><p>进程是<strong>处于执行状态中的程序</strong>，是现代操作系统一个<strong>基本运行单位</strong>。</p><h2 id="berstein-条件">3.2 Berstein 条件</h2><p>对于 <span class="math inline">\(S1,S2\)</span> 两条语句，如果有</p><ol type="1"><li><span class="math inline">\(R(S1)\cap W(S2)=\emptyset\)</span></li><li><span class="math inline">\(R(S2)\cap W(S1)=\emptyset\)</span></li><li><span class="math inline">\(W(S1)\cap W(S2)=\emptyset\)</span></li></ol><p>则 <span class="math inline">\(S1,S2\)</span> 可以并发执行</p><h2 id="进程的描述">3.3 进程的描述</h2><h3 id="进程的上下文">3.3.1 进程的上下文</h3><p><strong>定义：</strong>进程的<strong>物理实体</strong>与<strong>支持进程执行的物理环境</strong>的合称</p><h2 id="进程的状态以及切换">3.4 进程的状态以及切换</h2><h3 id="进程的基本状态">3.4.1 进程的基本状态</h3><ol type="1"><li><p>执行</p><blockquote><p>该进程已获得运行所必需的资源，它的程序正在处理机上 执行。</p></blockquote></li><li><p>阻塞</p><blockquote><p>进程正等待着某一事件的发生而暂时停止执行。这时，即使给它CPU控制权，它也无法执行。</p></blockquote></li><li><p>就绪</p><blockquote><p>进程已获得除CPU之外的运行所必需的资源，一旦得到CPU控制权，立即可以运行。</p></blockquote></li><li><p>挂起状态</p><blockquote><p>把处于阻塞状态（或就绪状态）的进程暂时交换到外存时的状态。</p></blockquote></li></ol><h2 id="线程">3.5 线程</h2><p><strong>定义：</strong>线程是比进程更小的活动单位，它是进程中的一个<strong>执行路径</strong>。</p><p><strong>线程的描述：</strong></p><ul><li><p>是进程内的基本调度单位；</p></li><li><p>也称为轻权进程（Light Weight Process，LWP）；</p></li><li><p>可以由操作系统内核控制，也可以由用户程序来控制，是程序中的一个单一的顺序控制流。</p></li><li><p>在多线程操作系统中，一个进程通常包括多个线程，即意味着一个程序内的多条语句同时执行。</p></li></ul><h3 id="进程与线程的区别">3.5.1 进程与线程的区别</h3><ol type="1"><li>进程为<strong>资源分配</strong>的基本单位，线程为操作系统的基本<strong>调度单位</strong>，而进程则为系统资源的拥有者。</li><li>当进程发生调度时，它拥有一个完整的虚拟地址空间；同一进程内的不同线程<strong>共享其所属进程的同一地址空间</strong>。</li><li>线程只由相关堆栈、寄存器和<strong>线程控制块（TCB）</strong>组成。</li><li><strong>进程切换</strong>时涉及到有关资源指针的保存以及地址空间的变化；同一进程内的各线程共享其所属进程的资源和地址空间，切换时无需保存资源，无地址空间变化。</li><li>进程的调度与切换由<strong>操作系统内核完成</strong>，线程的调度即可由操作系统完成，也可由用户完成。</li><li>在多线程操作系统中，线程是系统内的<strong>执行实体</strong>，而进程不是。</li><li>一个进程内的各个线程以及不同进程内的各个线程均可并发执行，在<strong>多处理机系统</strong>中它们可以被分派到不同的CPU上并行执行。</li></ol><h1 id="第四章处理机管理">第四章、处理机管理</h1><h2 id="分级调度">4.1 分级调度</h2><ol type="1"><li><p><strong>作业调度</strong></p><ul><li>高级调度或宏观调度</li><li>按照某种算法从后备作业队列中选择一个或多个作业装入内存</li><li>在作业运行结束后做善后处理</li><li>完成作业调度功能的程序称为<strong>作业调度程序</strong></li><li>作业调度程序 <strong>回收分配资源</strong>，善后处理</li></ul></li><li><p><strong>交换调度</strong></p><ul><li><p>中级调度</p></li><li><p>功能是在内、外存间进行信息交换</p></li><li><p>实现虚拟存储管理</p></li></ul></li><li><p><strong>进程调度</strong></p><ul><li>低级调度或微观调度</li><li>它 <strong>协调</strong> 和 <strong>控制</strong>各进程对处理机的使用</li><li>相应的进程调度程序称为 <strong>分派程序</strong> 或<strong>低级调度程序</strong></li><li>按照一定的准则合理的将处理机 <strong>动态地分配</strong>给处于就绪队列中的某个进程</li></ul></li><li><p>线程调度</p><ul><li>低级调度或微观调度</li><li><strong>用户级线程</strong> 和 <strong>核心级线程</strong>调度的方式是不同的</li><li>用户级线程由 <strong>线程库</strong> 进行管理和调度，称为进程<strong>局部调度</strong></li><li>核心级线程则由 <strong>系统内核</strong> 来调度，称为系统<strong>全局调度</strong></li></ul></li></ol><p><strong>4级调度</strong>的关系：</p><h2 id="调度算法">4.2 调度算法</h2><ol type="1"><li><p>FCFS调度算法</p></li><li><p><strong>优先级调度算法</strong></p></li><li><p>轮转调度</p><blockquote><p><strong>基本思想：</strong>将CPU的处理时间分成固定大小的<strong>时间片</strong>，将CPU轮流分配给各个进程，为各进程提供服务。</p><ul><li>一个进程被用时间片而未执行结束，则释放CPU，并插入到就绪队列的末尾</li><li>阻塞队列中的进程因被唤醒而插入到就绪队列的末尾，等待分配CPU。</li></ul><p><strong>缺点：</strong>进程切换频繁</p><p><strong>轮转调度法的分类：</strong>根据每一轮的时间片是否可变可分为：</p><ol type="1"><li>固定周期轮转法：时间片常数</li><li>可变周期轮转法：开始时计算时间片</li></ol><p>轮转调度法特别适合分时系统使用。</p><p><strong>时间片长度的选择：</strong></p><p>根据系统对响应时间的要求R和就绪队列中所允许的最大进程数N来确定的。它可表示为：<span class="math display">\[q=\frac{R}{N}\]</span> <strong>加入到就绪队列的进程有三种情况：</strong></p><ol type="1"><li>分给它的时间片用完，但进程还未完成。</li><li>当阻塞解除之后再回到就绪队列。</li><li>新创建进程进入就绪队列。</li></ol></blockquote></li><li><p>分级轮转调度</p><blockquote><p><strong>基本思想：</strong>根据进程 <strong>性质或优先级</strong>的不同将处于就绪状态的进程组成 <strong>两个或多个</strong>就绪队列，先调度高优先级就绪队列中的进程，再调度低优先级就绪队列中的进程。</p><p><strong>优缺点：</strong>实现简单，调度程序开销少，但不灵活。</p></blockquote></li><li><p>分级反馈轮转调度</p><blockquote><p><strong>基本思想：</strong></p><ol type="1"><li>根据对处理器的需求及占有情况把进程放入不同的就绪队列。</li><li>如果某个进程 <strong>占用了太多</strong>的处理器时间，降低该进程的优先级，插入较低优先级队列中。</li><li>将 <strong>长时间等待</strong>于较低优先级队列中的进程取出赋予较高的优先级，插入较高优先级队列中。</li></ol></blockquote></li><li><p><strong>最短作业优先调度</strong></p><blockquote><p><strong>基本思想：</strong>短作业或短进程优先进行调度CPU。</p><p><strong>特点：</strong>系统的吞吐量大，但处理时间长的作业可能长时间得不到服务。</p></blockquote></li><li><p><strong>响应比优先调度</strong></p><blockquote><p><strong>基本思想：</strong>该方法以响应比作为作业调度的优先级，响应比越高，作业得到调度的优先级就越高。</p><p><strong>响应比的定义Rp如下：</strong> <span class="math display">\[R_p=1+\frac{等待时间}{被要求执行的时间}\]</span> <strong>优点：</strong></p><ol type="1"><li>既考虑了作业到达的先后顺序</li><li>也适当照顾了短作业</li></ol><p><strong>缺点：</strong></p><ol type="1"><li>每次要调度作业时都要计算响应比</li><li>增加一定的系统开销</li></ol></blockquote></li></ol><h2 id="选择调度方式和评价调度算法的若干准则">4.3选择调度方式和评价调度算法的若干准则</h2><ol type="1"><li>CPU的利用率:运行时间与总时间之比</li><li>系统吞吐率：单位时间完成作业数</li><li>周转时间：提交到完成的时间</li><li>带权周转时间：周转时间与运行时间的比<br /></li><li>等待时间<br /></li><li>响应时间<br /></li><li>公平：均等机会得到调度<br /></li><li>对资源的均衡使用</li></ol><h2 id="实时调度算法">4.4 实时调度算法</h2><h3 id="实时操作系统的特点">4.4.1 实时操作系统的特点</h3><p>根据对 <strong>延迟</strong> 的约束要求可分为：</p><ol type="1"><li><strong>硬实时任务：</strong>如果系统对任务的响应时间超出了给定的时限（deadline）,将会引起灾难性后果</li><li><strong>软实时任务：</strong>允许系统对任务的响应具有一定的延迟。</li></ol><p>根据<strong>任务发生的时间</strong>特征实时任务分为：</p><ol type="1"><li><strong>周期性任务：</strong>周期内完成任务</li><li><strong>非周期性任务：</strong>在规定时限前开始或完成</li></ol><p><strong>实时操作系统基本特征：</strong></p><ol type="1"><li>支持多线程和可抢占式调度</li><li>有限等待时间和响应时间</li><li>可靠性高，健壮性强</li><li>操作系统的行为应该被用户所了解和掌握</li></ol><h3 id="实现实时调度的基本条件">4.4.2 实现实时调度的基本条件</h3><ol type="1"><li><p>提供必要的信息</p><blockquote><ol type="1"><li>就绪时间</li><li>开始时限和完成时限</li><li>处理时间</li><li>资源要求</li><li>优先级</li></ol></blockquote></li><li><p>系统处理能力强</p></li><li><p>采用 <strong>抢占式调度</strong> 机制</p></li><li><p>具有 <strong>快速</strong> 的任务切换机制</p></li></ol><h3 id="实时调度算法的分类">4.4.3 实时调度算法的分类</h3><p>按调度方式的不同：</p><ul><li>非抢占式<ul><li>轮转调度</li><li>优先调度</li></ul></li><li>抢占式<ul><li>基于时钟中断</li><li>立即抢占</li></ul></li></ul><h3 id="几种常用的实时调度算法">4.4.4 几种常用的实时调度算法</h3><ol type="1"><li><p><strong>时限调度算法</strong></p><blockquote><p><strong>基本思想：</strong>按用户的时限要求设置优先级，时限越近，要求赋予的优先级越高，应优先占有处理机。</p></blockquote></li><li><p><strong>频率单调调度算法</strong></p><blockquote><p>频率单调调度算法以任务发生的频率作为调度的准则，发生频率高的任务则具有较高的优先级。</p><p>对于有m（m&gt;1）个周期性的硬实时任务系统，每个任务的处理时间表示<spanclass="math inline">\(C_i\)</span>，周期时间表示<spanclass="math inline">\(T_i\)</span>，使用频率单调调度算法时的<strong>充分条件</strong> 是： <span class="math display">\[\frac{C_1}{T_1}+\frac{C_2}{T_2}+\cdots+\frac{C_n}{T_n}\leqm(2^{\displaystyle\frac{1}{m}}-1)\]</span>对于有m（m&gt;1）个周期性的硬实时任务系统，每个任务的处理时间表示Ci，周期时间表示Ti，使用频率单调调度算法时的<strong>必要条件</strong> 是： <span class="math display">\[C_i \leq T_i\]</span></p></blockquote></li></ol><h1 id="第五章存储管理">第五章、存储管理</h1><h2 id="存储管理的功能">5.1 存储管理的功能</h2><h3 id="内存的分配与回收">5.1.1 内存的分配与回收</h3><h3 id="地址转换">5.1.2 地址转换</h3><ol type="1"><li><p>静态地址重定位</p><blockquote><p><strong>完成时间：</strong>在程序执行之前由装配程序完成地址转换工作</p><p><strong>优点：</strong>不需要硬件支持</p><p><strong>缺点：</strong>无法实现虚拟存储器。程序和数据的共享难</p></blockquote></li><li><p>动态地址重定位</p><blockquote><p><strong>完成时间：</strong>程序执行过程中，将要访问的程序或数据的逻辑地址转换成内存地址</p><p><strong>所需资源：</strong>需要一个(或多个)基地址寄存器BR一个(或多个)程序逻辑地址寄存器VR。</p><p><strong>地址变换：</strong>MA（内存地址）=（BR）+（VR）</p><p><strong>优点：</strong></p><ul><li>可以对内存进行非连续分配</li><li>提供了实现虚拟存储器的基础</li><li>可以分存在不同内存区域，有利于程序段的共享</li></ul></blockquote></li></ol><h3 id="内存的信息共享与保护">5.1.3 内存的信息共享与保护</h3><p><strong>保护方法：</strong></p><ul><li><p>硬件法；如上下界保护法。</p><blockquote><p>为每个运行着的进程和数据段设置一对上下界寄存器。访问操作时，对起始地址和终止地址进行合法性检查。</p></blockquote></li><li><p>软件法；如保护键法。</p><blockquote><p>为每一个被保护存储块分配一个单独的保护键。</p></blockquote></li><li><p>软硬件结合法。</p><blockquote><p>是界限寄存器与CPU的用户态或核心态工作方式相结合的保护方式。</p></blockquote></li></ul><h3 id="内存的扩充">5.1.4 内存的扩充</h3><p><strong>目的：</strong>实现系统运行的作业大小只受内存容量和外存容量之和的限制</p><p><strong>实现：</strong></p><ol type="1"><li>程序的全部代码和数据存放在<strong>辅存</strong>中；</li><li>将程序当前执行所涉及的那部分程序代码放入<strong>主存</strong>中；</li><li>程序执行时，当所需信息不在主存，由操作系统和硬件相配合来完成主存从辅存中<strong>调入信息</strong>，程序继续执行。</li></ol><h2 id="覆盖和交换技术">5.2 覆盖和交换技术</h2><h3 id="覆盖技术">5.2.1 覆盖技术</h3><p><strong>基本思想：</strong></p><ul><li>把程序划分为若干个功能上相对独立的程序段；</li><li>按照程序的逻辑结构让那些<strong>不会同时执行</strong>的程序段共享同一块内存区。</li><li>这些程序段都被保存在<strong>外存</strong>中；</li><li>当有关程序段的先头程序段已经执行结束后，再把后续程序段调入内存<strong>覆盖</strong>前面的程序段。</li><li>用户看来好像内存扩大了，从而达到了内存扩充的目的。</li></ul><p><strong>实现：</strong></p><ol type="1"><li>程序员提供<strong>覆盖描述文件</strong>——程序员必须完成把一个程序划分成不同的程序段，并规定好它们执行和覆盖顺序</li><li>操作系统根据程序员提供的覆盖描述文件来完成程序段之间的覆盖。</li></ol><p>适用：覆盖技术大多由对操作系统的<strong>虚拟空间和内部结构</strong>很熟悉的程序员来使用。</p><h3 id="交换技术">5.2.2 交换技术</h3><p><strong>含义：</strong></p><ul><li>将内存某部分的程序或数据写入外存交换区</li><li>从外存交换区中调入指定的程序或数据到内存</li></ul><h2 id="分区存储管理">5.3 分区存储管理</h2><p><strong>基本思想：</strong>把用户区作为一个连续区或分成若干个连续区进行管理，当划分多个连续区时，可采用<strong>固定分区</strong> 方式或 <strong>可变分区</strong>方式进行管理。</p><h3 id="单分区存储管理">5.3.1 单分区存储管理</h3><p><strong>基本思想：</strong>用户区作为 <strong>一个</strong>连续分区分配给一个作业使用，任何时刻，主存只存在 <strong>一个</strong>作业</p><p><strong>特点：</strong></p><ul><li>设置一个界限寄存器记录用户区的起始地址。</li><li>每次只允许一个作业装入主存储器。</li><li>可以采用静态重定位的方式进行地址转换。</li></ul><h3 id="多分区存储管理">5.3.2 多分区存储管理</h3><p><strong>基本思想：</strong>把主存中的用户区划分成若干个连续区域，每个连续区中可装入一个作业。</p><h4 id="固定分区存储管理">5.3.2.1 固定分区存储管理</h4><p><strong>基本思想：</strong></p><ul><li>把主存的用户区域预先划分成若干个连续区。</li><li>每个连续区的大小可以相同，也可以不同。</li><li>划分好分区之后，个数和大小都不能改变</li><li>每个分区可用来装入一个作业。</li></ul><p><strong>使用的数据结构：</strong>主存分配表</p><table><thead><tr><th>分区号</th><th>起始位置</th><th>长度</th><th>占用标志</th></tr></thead><tbody></tbody></table><p><strong>地址转换：</strong>采用静态重定位的方式</p><h4 id="可变分区存储管理">5.3.2.2 可变分区存储管理</h4><p><strong>使用的数据结构：</strong></p><ol type="1"><li><p>已分配表</p><table><thead><tr><th>起始地址</th><th>长度</th><th>标志位</th></tr></thead><tbody></tbody></table></li><li><p>未分配表</p><table><thead><tr><th>起始地址</th><th>长度</th><th>标志位</th></tr></thead><tbody></tbody></table></li><li><p>空闲块链</p><blockquote><p>空闲块链是由链表实现的，链表中的每一个节点记录一个空闲块的大小和下一个空闲块的起始地址。</p></blockquote></li></ol><p><strong>分配算法：</strong></p><ol type="1"><li><p>最先适应</p><blockquote><p>每次分配时，总是顺序查找空闲区表，找到<strong>第一个能满足作业长度要求</strong> 的空闲区。</p><p>把空闲区按 <strong>首地址顺序从小到大</strong> 登记在空闲区表中。</p><p>每当有作业归还分区时，必须调整空闲区表</p></blockquote></li><li><p>最佳适应</p><blockquote><p>按作业要求挑选一个能满足作业要求的 <strong>最小</strong> 空闲区。</p><p>把空闲区按 <strong>大小顺序从小到大</strong> 登记在空闲区表中。</p><p>形成小空闲区（即“碎片”）无法使用的，影响了主存空间的使用率</p></blockquote></li><li><p>最坏适应</p><blockquote><p>总是挑选一个 <strong>最大</strong> 的空闲区分割一部分给作业使用。</p><p>空闲区表中的登记项可按空闲区 <strong>大小以递减顺序</strong> 排列</p></blockquote></li></ol><p><strong>地址转换：</strong></p><ul><li><p>采用动态重定位</p></li><li><p>硬件设置两个专用的控制寄存器：限长寄存器：存放作业所占分区的长度；基址寄存器:存放作业所占分区的起始地址</p></li></ul><p><strong>作业的装入方式：</strong></p><ol type="1"><li>一头装入</li><li>两头装入</li></ol><h2 id="页式存储管理">5.4 页式存储管理</h2><p><strong>基本原理：</strong></p><ul><li><p>把主存分成大小相等 “块”，逻辑空间分成与块大小的“页“。</p></li><li><p>逻辑地址组成：页号和页内地址逻辑地址是一维的</p></li></ul><h3 id="分类">5.4.1 分类</h3><ol type="1"><li><p><a href="#5.4.3%20静态页式存储管理">静态页式存储</a></p></li><li><p><a href="#5.4.4%20动态页式存储管理">动态页式存储</a></p></li></ol><h3 id="使用的数据结构">5.4.2 使用的数据结构</h3><h4 id="页表">5.4.2.1 页表</h4><p>一个<strong>进程</strong>，维护一个页表，用来记录一个进程所占用内存的情况。</p><p>页表项目数 = 进程的页数</p><p>结构：</p><table><thead><tr><th style="text-align: center;">页号（page）</th><th style="text-align: center;">块号（page frame）</th></tr></thead><tbody></tbody></table><h4 id="请求表">5.4.2.2 请求表</h4><p>整个<strong>系统</strong>，维护一个请求表，用来记录所有进程<strong>申请/占用</strong> 内存的情况</p><p>记录项目是<strong>进程</strong></p><p>结构：</p><table><thead><tr><th style="text-align: center;">进程号</th><th style="text-align: center;">请求块数</th><th style="text-align: center;">页表起始地址</th><th style="text-align: center;">页表长度</th></tr></thead><tbody></tbody></table><h4 id="存储块表">5.4.2.3 存储块表</h4><p>整个<strong>系统</strong>，维护一个存储块表，用来记录内存各个块的<strong>占用/空闲</strong> 情况</p><p>记录项目是<strong>内存块</strong></p><p>表示方法</p><h5 id="位示图法">1）位示图法</h5><p>在内存空间中划分一个固定区域，这个区域的每个bit表示一个内存块的状态。</p><h5 id="空闲块表">2）空闲块表</h5><p>每一项记录一组 <strong>连续</strong> 的空闲区域</p><p>结构：</p><table><thead><tr><th>首块号</th><th>连续空闲块数</th></tr></thead><tbody></tbody></table><h5 id="空闲块链">3）空闲块链</h5><p>节点结构：</p><ol type="1"><li>连续空闲区域总块数</li><li>下一个连续空闲区首块位置</li></ol><p>头节点：</p><p>​ 首个连续空闲区首块位置</p><h3 id="静态页式存储管理">5.4.3 静态页式存储管理</h3><p>在进程<strong>开始执行之前</strong>，将该进程程序段和数据段按页<strong>全部装入</strong>内存。</p><h4 id="分配">分配</h4><p>检查位示图中的空闲块数是否满足该进程的要求？</p><p>若不满足，进程等待；</p><p>若满足，则根据需求从位示图找出标记0的块，并置1。</p><p>从空闲块总数中减去本次分配的块数。</p><p>按位计算块号（块号 = 字号*字长+位号）</p><p>把进程装入这些块中。</p><p>建立一张页表。</p><h4 id="回收">回收</h4><p>按页表查找对应的块号</p><p>归还这些块：</p><p>​ 计算块在位示图中的位置（字号=块号/字长）（位号 = 块号 mod 字长）</p><p>​ 将该bit置0</p><p>​ 空闲块数+1</p><h4 id="地址转换-1">地址转换</h4><p>按逻辑地址查到 <strong>页号</strong></p><p>在页表中查到 <strong>块号</strong></p><p>计算公式：<span class="math inline">\(绝对地址 = 块号 \times 块长 +页内地址\)</span></p><p>在多道程序设计的系统时，为了保证每个进程按照该进程的页表进行地址转换。</p><p>需要增加一个硬件——<strong>页表控制寄存器</strong>，页表始址存入基址寄存器，页表长度送入限长寄存器。</p><p>当调度程序选中某个进程占用处理机的时，通过 <strong>请求表</strong>查找该进程的页表起始地址和长度，送入页表控制寄存器。</p><h3 id="动态页式存储管理">5.4.4 动态页式存储管理</h3><p>将进程信息作为副本放在磁盘上存储，在进程执行时，将进程信息<strong>部分页面</strong>调入主存。</p><p>若执行时，所访问页面已在主存中，则按静态页式存储管理的方式进行地址转换；</p><p>若访问的页面不在主存中，则产生一个<strong>缺页中断</strong>，由操作系统将页面调入主存。</p><p>在装入进程时，就应该知道哪些页被装入了主存，哪些页没有被装入。</p><p>为此<strong>改进的页表结构</strong>如下：</p><table><thead><tr><th>页号</th><th>页面号</th><th>标志位</th><th>外存地址</th><th>改变位</th></tr></thead><tbody></tbody></table><p>当在进程的执行中，要访问某页时，地址转换机构去查找页表，若该页号标志位为1，则表示在主存；若为0，则表示不在主存</p><h4 id="页面置换">5.4.4.1 页面置换</h4><p>当主存中无空闲块时，为了装入一个页而必须按某种算法从已在主存的页中选择一页，将它暂时调出主存，让出主存空间，用来存放所需装入的页面</p><ol type="1"><li><p>随机置换算法</p><blockquote><p>随机地选择某个用户的页面并将其换出。</p></blockquote></li><li><p>轮转置换算法</p><blockquote><p>轮流换出用户区内的一个可以被换出的页。</p></blockquote></li><li><p><strong>先进先出置换算法</strong></p><blockquote><ul><li>选择最先装入主存储器的那一页调出</li><li>把驻留在主存中时间最长的那一页调出。</li></ul></blockquote></li><li><p><strong>最近最少用置换算法</strong></p><blockquote><ul><li>基于程序执行的局部性；</li><li>访问到某些数据和指令时可能在一段时间里还经常会访问它们，不应该把这些页面调出。</li><li>某个内存页在最近一段时间里没有被访问过，则在最近的将来也可能暂时不会被访问，可以选择这些页面调出。</li></ul></blockquote></li><li><p>最近不常用置换</p><blockquote><ul><li>为每一页设置一个计数器，每当访问一页时，就把该页对应的计数器加1；</li><li>操作系统确定一个周期T，在周期T的时间内，若没有发生缺页中断，则把所有的计数器清“0”，开始一个新的周期重新计数。</li><li>若在周期T的时间内发生了缺页中断，则选择计数值最小的那页调出(它是最近一段时间内最不常用的页)，同时把所有的计数器清“0”；</li><li>算法的实现要花很大的开销，并且要确定一个合适的周期T也是困难的。</li></ul></blockquote></li><li><p>CLOCK置换算法</p><blockquote><ol type="1"><li><p>简单的Clock置换算法</p><blockquote><ul><li><p>为每一页设置一位访问位，内存中的所有页面都通过链接指针链接成一个循环队列。当某页被访问时，其访问位被置1。</p></li><li><p>如果访问位为0，就选择该页换出，若为1，则重新将它置0，暂不换出，再按照FIFO算法检查下一个页面。</p></li></ul><p>规则:</p><ol type="1"><li>首次装入：置1</li><li>刚使用过：置1</li><li>查找过：置0</li><li>遇到第一个0：替换</li><li>指针指向下一个</li></ol></blockquote></li><li><p>改进的Clock置换算法</p><blockquote><p>考虑页面的使用情况，增加一个因素，置换代价。</p><p>由访问位A和修改位M可以组合成四种类型页面：</p><p>1类（A=0，M=0）：表示该页最近既未被访问，又未被修改，是最佳淘汰页；</p><p>2类（A=0，M=1）：表示该页最近未被访问，但被修改，并不是很好的淘汰页；</p><p>3类（A=1，M=0）：表示该页最近已被访问，但未被修改，有可能再被访问；</p><p>4类（A=1，M=1）：表示该页最近被访问且被修改，有可能再被访问；</p><p>执行步骤：</p><ol type="1"><li>扫描循环队列，寻找第1类页面（ A=0，M=0），将它淘汰，不改变访问位A。</li><li>如果（1）步骤失败，开始第二轮扫描，寻找第2类页面（A=0，M=1），将它淘汰，改变访问位A=0。</li><li>如果（2）步骤失败，改变所有页访问位A=0，然后重复步骤（1），必要时重复步骤（2）。</li></ol></blockquote></li></ol></blockquote></li><li><p>页面缓冲算法</p><blockquote><p>该算法规定将一个被淘汰的页放入两个链表中的一个：</p><p>①如果页面未被修改，就特将它直接放入空闲链表中；</p><p>②如果页面被修改，便放入已修改页面的链表中。</p><p>须注意的是，这时页面在内存中并不做物理上的移动，而只是将页表中的表项移到上述两个链表之一中。</p><p>既可改善分页系统的性能，又可采用一种较简单的置换策略。</p></blockquote></li><li><p>最佳置换算法</p><blockquote><p>当要装入一个新页而必须调出一个页面时，所选择的调出页应该是以后再也不使用的页或者是距当前最长时间以后才使用的页。</p></blockquote></li></ol><h2 id="段式和段页式存储">5.5 段式和段页式存储</h2><h1 id="第六章文件管理">第六章、文件管理</h1><p>文件系统主要对以文件形式存放在 <strong>外部存储器</strong>上的信息进行管理。</p><p>包括：</p><ul><li>如何以文件形式组织信息；</li><li>如何通过文件名对存储在存储介质上的文件进行操作；</li><li>如何实现文件的共享、保护和保密；</li><li>如何提高文件系统的可靠性；</li><li>如何对外部存储空间进行有效管理。</li></ul><h2 id="文件">6.1 文件</h2><ol type="1"><li><p>什么是文件</p><blockquote><p>文件是在逻辑上具有完整意义的信息集合，它有一个名字以供标识，文件名是以字母开头的字母数字串。</p></blockquote></li></ol><h1 id="第七章设备管理">第七章、设备管理</h1><h3 id="磁盘的驱动调度">7.7.2 磁盘的驱动调度</h3><h4 id="移臂调度">7.7.2.1 移臂调度</h4><ol type="1"><li>先来先服务</li><li>最短寻找时间优先</li><li>扫描调度（电梯调度）</li><li>循环扫描算法</li><li>NStepScan调度算法</li><li>FSCAN调度</li></ol><h4 id="旋转调度">7.7.2.2 旋转调度</h4><h1 id="第八章进程的互斥同步死锁">第八章、进程的互斥、同步、死锁</h1>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Computer</tag>
      
      <tag>Science</tag>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高等数学 #0 应试笔记</title>
    <link href="/2024/10/10/%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6_0_%E5%BA%94%E8%AF%95%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/10/10/%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6_0_%E5%BA%94%E8%AF%95%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="一一元微积分">一、一元微积分</h1><h2 id="最优问题极值">最优问题（极值）</h2><p>一元函数极值问题：</p><ol type="1"><li><p>必要条件（费马引理）</p><p>从极值定义，推出必要条件。</p><p>若一阶导存在，则一阶导必为0</p></li><li><p>充分条件（第二充分条件）</p><p>是极值，也就是说在一个领域内，<spanclass="math inline">\(f(x)-f(x_0)\)</span> 不变号。</p><p>可以用泰勒公式在该领域内展开： <span class="math display">\[f(x)=f(x_0)+f&#39;(x_0)(x-x_0)+\frac{f&#39;&#39;(x_0)(x-x_0)^2}{2}+R(x-x_0)\]</span> 将 <span class="math inline">\(f(x_0)\)</span> 移动到等号左边<span class="math display">\[f(x)-f(x_0)=(x-x_0)^2(\frac{f&#39;&#39;(x_0)}{2}+\frac{R(x-x_0)}{(x-x_0)^2})\]</span></p></li></ol><p>极值点的<strong>充分条件</strong>：</p><p>（1）第一充分条件：<strong>两边强</strong></p><p>在 <span class="math inline">\(U(x_0)\)</span> 内，<spanclass="math inline">\((x,x_0)\)</span> 内 <spanclass="math inline">\(f&#39;(x)\lt0\)</span>；<spanclass="math inline">\((x_0,x)\)</span> 内 <spanclass="math inline">\(f&#39;(x)\gt 0\)</span> 则 <spanclass="math inline">\(f(x_0)\)</span>为极小值</p><p><span class="math inline">\((x,x_0)\)</span> 内 <spanclass="math inline">\(f&#39;(x)\gt 0\)</span>；<spanclass="math inline">\((x_0,x)\)</span> 内 <spanclass="math inline">\(f&#39;(x)\lt 0\)</span> 则 <spanclass="math inline">\(f(x_0)\)</span>为极大值</p><p>（2）第二充分条件：<strong>点强</strong></p><p><span class="math inline">\(f&#39;(x_0)=0\)</span> ，<spanclass="math inline">\(f&#39;&#39;(x_0)\gt0\)</span> 为极小值，<spanclass="math inline">\(f&#39;&#39;(x_0)\lt 0\)</span> 为极大值</p><p>（3）第三充分条件：</p><p><spanclass="math inline">\(f^{m}(x_0)=0,m=\{1,2,\cdots,n-1\}\)</span>，<spanclass="math inline">\(f^n(x_0)\ne 0\)</span></p><p><span class="math inline">\(n\)</span>是<strong>偶数</strong>则是极值</p><ol type="1"><li><span class="math inline">\(f^n(x_0)\gt 0\)</span> ，极小值</li><li><span class="math inline">\(f^n(x_0)\lt0\)</span> ，极大值</li></ol><p><span class="math inline">\(n\)</span> 是奇数则不是极值 <spanclass="math display">\[f(x)-f(x_0)=\frac{f^{(n)}(x_0)(x-x_0)^n}{n!}+O((x-x_0)^n)\]</span> 如果 <span class="math inline">\(n\)</span> 是奇数</p><p>如果 <span class="math inline">\(f^{(n)}(x_0)\gt0\)</span></p><p><span class="math inline">\((x,x_0),\quad (x-x_0)^n\lt0\Rightarrowf(x)-f(x_0)\lt0\)</span>；</p><p><span class="math inline">\((x_0,x),\quad (x-x_0)^n\gt0\Rightarrowf(x)-f(x_0)\gt0\)</span></p><p><span class="math inline">\(f(x)-f(x_0)\)</span> 在 <spanclass="math inline">\(x_0\)</span>两端变号了，是单调的，<strong>不是极值</strong></p><p>多元函数极值问题：</p><ol type="1"><li><p>必要条件:</p><p>由极值定义，若偏导存在，则必为0，即梯度为0，<spanclass="math inline">\(\nabla f=\mathbf 0\)</span></p></li><li><p>充分条件</p><p>领域内，多元泰勒展开： <span class="math display">\[f(X)=f(X_0)+\nabla f\cdot\Delta X+\frac{1}{2} (\DeltaX)^\top\mathbf{H}_f\Delta X\]</span> 推出 <span class="math inline">\(f(X)-f(X_0)\)</span>不变号的条件，即为极值充分条件。</p><p>判定 <span class="math inline">\(\mathbf{H}_f\)</span> 的正定性用<span class="math inline">\(\text{Sylvester&#39;s Criterion}\)</span>判别法（顺序主子式判定）</p></li></ol><h2 id="局部意义下最优逼近">局部意义下，最优逼近</h2><p>定理：</p><p>如果一个函数在<strong>局部</strong>具有<strong>高阶逼近</strong>的性质，那么这个能用来逼近的多项式只能是泰勒多项式。（唯一性）</p><p><span class="math display">\[a_k=\frac{f^{(k)}(x_0)}{k!}\]</span></p><h2 id="整体意义下最优逼近">整体意义下，最优逼近</h2><p>函数内积： <span class="math display">\[\langle f,g\rangle=\int_a^b f(t)g(t)dt\]</span> 函数范数： <span class="math display">\[\|f\|=\sqrt{\langle f,f\rangle}\]</span></p><p>两个函数距离的度量：(正体差异程度的度量) <spanclass="math display">\[\text{dis}(f,g)=\|f-g\|=\sqrt{\langlef-g,f-g\rangle}=\sqrt{\int_a^b(f(t)-g(t))^2dt}\]</span></p><p>傅里叶多项式：（最优逼近）</p><p>设 <span class="math inline">\(f(x)\)</span> 是在 <spanclass="math inline">\([-l,l]\)</span> 上的周期函数 <spanclass="math display">\[\mathcal{P}_n=\text{span}\{1,\cos\frac{\pi}{l}x,\sin\frac{\pi}{l}x,\cos\frac{2\pi}{l}x,\sin\frac{2\pi}{l}2x,\cdots,\cos\frac{n\pi}{l}x,\sin\frac{n\pi}{l}x\}\]</span></p><p><span class="math display">\[f(x)\sim a_0+\sum_{k=1}^n a_k\cos\frac{\pi}{l}kx +b_k\sin\frac{\pi}{l}kx\]</span></p><p><span class="math display">\[a_k=\frac{\langle\cos\frac{\pi}{l}kx,f(x)\rangle}{\langle\cos\frac{\pi}{l}kx,\cos\frac{\pi}{l}kx\rangle}\]</span></p><h2 id="凹凸性">凹凸性</h2><p>拐点充分条件</p><p>（1）第一充分条件</p><p>在去心邻域内 <spanclass="math inline">\(U(x_0)\)</span>，二阶导存在，且二阶导变号。则为拐点</p><p>（2）第二充分条件</p><p>在 <span class="math inline">\(x_0\)</span> 处三阶可导，且 <spanclass="math inline">\(f&#39;&#39;(x_0)=0,\quad f&#39;&#39;&#39;(x_0)\ne0\)</span>，则为拐点</p><p>（3）第三充分条件</p><p>在 <span class="math inline">\(x_0\)</span> 处 <spanclass="math inline">\(n\)</span> 阶可导，且<spanclass="math inline">\(f^{(m)}(x_0)=0,m=\{2,3,\cdots,n-1\},\quadf^{(n)}(x_0)\ne0\)</span>，则当 <span class="math inline">\(n\)</span>是奇数阶时，该点是拐点</p><h2 id="斜渐进线">斜渐进线</h2><p>依据： <span class="math display">\[\lim_{x\to \infty} [f(x)-(ax+b)]=0\]</span></p><p>求法： <span class="math display">\[\lim_{x\to\infty}\frac{f(x)}{x}=a,\quad\lim_{x\to\infty}f(x)-ax=b\]</span></p><h2 id="曲率">曲率</h2><p>意义：曲线弯曲程度的度量</p><p>定义：<span class="math inline">\(\alpha\)</span> 是切线的角度，<spanclass="math inline">\(s\)</span> 是弧 <span class="math display">\[K=\lim_{\Delta s\to0}\frac{\Delta \alpha}{\Deltas}=\frac{\mathrm{d}\alpha}{\mathrm{d}s}\]</span> 设一个光滑（二阶可导）曲线 <spanclass="math inline">\(y(x)\)</span> <span class="math display">\[\tan\alpha=y&#39;\]</span> 对 <span class="math inline">\(x\)</span> 求导 <spanclass="math display">\[\sec^2x\frac{\mathrm{d\alpha}}{\mathrm{d}x}=y&#39;&#39;\]</span> 则 <span class="math display">\[\begin{align}\mathrm{d}\alpha&amp;=\frac{y&#39;&#39;}{\sec^2x}\mathrm{d}x\\&amp;=\frac{y&#39;&#39;}{1+\tan^2x}\mathrm{d}x\\&amp;=\frac{y&#39;&#39;}{1+(y&#39;)^2}\mathrm{d}x\end{align}\]</span> 又因为弧微分 <span class="math display">\[\mathrm{d}s=\sqrt{1+(y&#39;)^2}\mathrm{d}x\]</span> 于是 <span class="math display">\[K=\frac{\mathrm{d}\alpha}{\mathrm{d}s}=\frac{y&#39;&#39;}{[1+(y&#39;)^2]^{\frac{3}{2}}}\]</span></p><p>对于一个圆，有半径角度弧长关系 <span class="math display">\[\Delta\alpha=\frac{\Delta s}{r}\]</span> 则 <span class="math display">\[K=\frac{\mathrm{d}\alpha}{\mathrm{d}s}=\frac{1}{r}\]</span></p><p>定理：已知函数 <span class="math inline">\(y=f(x)\)</span> 在 <spanclass="math inline">\(x_0\)</span> 处有二阶导数，且 <spanclass="math inline">\(f&#39;&#39;(x)\ne0\)</span>，则在此点有曲率圆，即密切圆</p><p>曲率半径： <span class="math display">\[r=\frac{[1+f&#39;^2(x)]^{\frac{3}{2}}}{|f&#39;&#39;(x)|}\]</span></p><h2 id="平面图形面积">平面图形面积</h2><p>（1）极坐标系下 <span class="math display">\[\frac{1}{2}\int^\beta_\alpha r^2(\theta)\mathrm{d}\theta\]</span></p><p>面微元推导：视微元为小扇形，用扇形面积公式计算 <spanclass="math display">\[\Delta A_i=\frac{lr}{2}=\frac{r^2(\theta)}{2}\]</span></p><h2 id="旋转体体积">旋转体体积</h2><p>（1）绕 x 轴旋转</p><p>解法：<span class="math inline">\(\text{Disc Integral}\)</span> <spanclass="math display">\[\int_a^b\pi y^2(x)\,\mathrm{d}x\]</span></p><p>（2）绕 y 轴旋转</p><p>解法：<span class="math inline">\(\text{Shell Integral}\)</span></p><p>对长方体微元积分 <span class="math display">\[\mathrm{d}V_y=2\pi x|y(x)|\mathrm{dx}\]</span> 则 <span class="math display">\[2\pi\int_a^b x|y(x)|\,\mathrm{d}x\]</span></p><p>（3）绕<strong>直线</strong>旋转</p><p><span class="math display">\[\frac{\pi}{(A^2+B^2)^\frac{3}{2}}\int_a^b(Ax+Bf(x)+C)^2|Af&#39;(x)-B|\,\mathrm{d}x\]</span></p><p>（4）古鲁金定理 <span class="math inline">\(\text{Pappus-GuldinusTheorem}\)</span></p><p>定理一：<strong>平面曲线</strong>绕轴旋转，求侧面积 <spanclass="math display">\[S=2\pi p\cdot l\]</span> <span class="math inline">\(p\)</span>是曲线重心到轴的距离，<span class="math inline">\(l\)</span>是线段长度</p><p>定理二：<strong>平面图形</strong>绕轴旋转，求体积 <spanclass="math display">\[V=2\pi p\cdot S\]</span></p><p>平面区域绕不穿过它的轴旋转，所构成的旋转体体积，可以视为一个二重积分。<span class="math display">\[\mathrm{d}V=2\pi r(x,y)\mathrm{d}\sigma\]</span></p><p><span class="math display">\[V=2\pi\iint_D r(x,y)\,\mathrm{d}\sigma\]</span></p><h2 id="积分技巧">积分技巧</h2><p>换元技巧：</p><ol type="1"><li><p>欧拉代换</p></li><li><p>对称代换</p><p>对于特殊的有理分式，进行<strong>对称代换</strong>，令 <spanclass="math inline">\(u=x^\alpha\pm\frac{1}{x^\alpha}\)</span> ，则<spanclass="math inline">\(\mathrm{d}u=\alpha(x^{\alpha-1}\mp\frac{1}{x^{\alpha+1}})\)</span></p></li><li><p>反向乘积求导公式与反向商的求导公式</p></li><li><p>部分分数法（因式分解、拆开）</p></li><li><p>半角代换</p><blockquote><p>任何有理函数都能积分，则三角函数形式的有理分式，通过半角代换也一定能积分。</p></blockquote><p><span class="math display">\[\sin x=\frac{2u}{1+u^2},\quad \cos x=\frac{1-u^2}{1+u^2},\quad u=\tan\frac{x}{2}\]</span></p></li></ol><h2 id="微元法">微元法</h2><p>假设在某一实际问题中，对于给定的连续函数 <spanclass="math inline">\(f(x)\)</span> ，量 <spanclass="math inline">\(Q\)</span> 有如下特点</p><p>（1）一方面 <span class="math inline">\(Q\)</span> 是由区间 <spanclass="math inline">\([a,b]\)</span> 所决定的常量，记作 <spanclass="math inline">\(Q([a,b])\)</span>。另一方面，考虑右端点变动的区间<span class="math inline">\([a,x]\)</span>，<spanclass="math inline">\(Q([a,x])\)</span> 又依赖于 <spanclass="math inline">\(x\)</span> 成为变量，也就是说它是 <spanclass="math inline">\(x\)</span> 的函数，简记为 <spanclass="math inline">\(Q(x)\)</span></p><p>（2）对于<span class="math inline">\([a,b]\)</span>的每个子区间，<span class="math inline">\(Q\)</span>都有确定的值，并且关于区间有可加性</p><p>（3）部分量近似 <span class="math inline">\(\Delta Q_i=f(\xi_i)\Deltax_i\)</span></p><p>为了计算 <span class="math inline">\(Q\)</span>将其表示为定积分。</p><p>关键是 <span class="math inline">\(Q\)</span> 的微分，得满足 <spanclass="math inline">\(\Delta Q-\mathrm{d}Q\)</span> 是高阶无穷小</p><h1 id="二微分中值定理">二、微分中值定理</h1><h2 id="罗尔定理">罗尔定理</h2><p>适用题目：根的存在性证明</p><p>解法：</p><p>（1）构造函数法（分析法） <span class="math display">\[\begin{array}{lcr}f&#39;(\xi)&amp; + &amp;f(\xi)&amp;=&amp;0\\f&#39;(\xi)&amp; + &amp;nf(\xi)&amp;=&amp;0\\f&#39;(\xi)&amp; + &amp;p&#39;(x)f(\xi)&amp;=&amp;0\\nf&#39;(\xi)&amp; + &amp;f(\xi)&amp;=&amp;0\\nf&#39;(\xi)&amp; + &amp;p&#39;(x)f(\xi)&amp;=&amp;0\\\frac{nf&#39;(x_1)}{f(x_1)}&amp;=&amp;\frac{mf&#39;(x_2)}{f(x_2)}\end{array}\]</span> （2）确定区间法</p><p>（3）寻找等值点法</p><h2 id="拉格朗日中值定理">拉格朗日中值定理</h2><p>适用题目：结论涉及<strong>函数增量</strong>与区间内某一点的导数的等式关系，或是函数值与函数值之间的不等关系</p><p>解法</p><p>1）设置辅助函数</p><p>​ （1）分析法</p><p>​ （2）待定系数法</p><p>​ （3）不定积分法</p><p>2）确定区间法</p><h2 id="柯西中值定理">柯西中值定理</h2><p>适用题目：结论涉及<strong>两个不同函数的增量</strong>或<strong>函数值与导数值之间关系</strong>的等式与不等式命题</p><h2 id="泰勒公式">泰勒公式</h2><p>适用题目：条件涉及二阶以及二阶以上导数，结论涉及<strong>多个函数值间</strong>或<strong>函数值与各阶导数值间的等式或不等式</strong>关系</p><p>三种题型：</p><p>1）隐含三点内容题型</p><p>​ （1）展开几阶</p><p>​ （2）在哪点展开</p><p>​ （3）展开后 <span class="math inline">\(x\)</span> 取什么值</p><p>2）带有极限条件的题型</p><p>3）局部泰勒公式题型（带皮亚诺余项的泰勒公式）</p><h1 id="三多元微分学">三、多元微分学</h1><h2 id="实值多元函数">实值多元函数</h2><p>（1）微分</p><ol type="1"><li><p>全微分</p><blockquote><p>梯度与变化量的点积。</p></blockquote></li></ol><p>（2）导数</p><ol type="1"><li><p>偏导数（scalar）</p><blockquote><p>多元函数沿坐标轴方向的变化率</p></blockquote></li><li><p>方向导数（scalar）</p><blockquote><p>多元函数的值沿某一方向 <spanclass="math inline">\(\vec{\tau}\)</span>的变化率，即<strong>梯度在该方向上的投影</strong>。梯度与该方向单位矢量的点乘。</p></blockquote><p><span class="math display">\[\frac{\partial f}{\partial\vec{\tau}}=\nablaf\cdot\vec{\tau}=(f_x,f_y)\cdot(\cos\alpha,\cos\beta)\]</span></p></li><li><p>全导数（vector 梯度向量）</p><blockquote><p>几何意义：全导数的范数，等于该导数点的切平面与定义域平面夹角的正切值。</p><p>也是<strong>等高线的切线的法向量</strong></p></blockquote></li></ol><p>（3）切平面的二面角（斜率的刻化）</p><p>设一个二元函数 <span class="math inline">\(z=f(x,y)\)</span>显示给出。</p><p>比如</p><p><span class="math inline">\(z=z_0+A(x-x_0)+B(y-y_0)\)</span></p><p>可以写成，显然 <span class="math inline">\(\begin{pmatrix}-A&amp; -B&amp;1\end{pmatrix}=\begin{pmatrix}-z&#39;(x)&amp; -z&#39;(y)&amp;1\end{pmatrix}\)</span> <span class="math display">\[z=z_0+\begin{bmatrix}A &amp; B\end{bmatrix}\cdot\begin{bmatrix}x-x_0 \\ y-y_0\end{bmatrix}\]</span></p><ol type="1"><li><p>切点法向量 <span class="math display">\[\vec{\tau}=(-z_x^{&#39;},-z_y^{&#39;},1)\]</span></p></li><li><p>二面角余弦 <span class="math display">\[\cos\theta=\frac{\vec{\tau}\cdot\vec{k}}{\|\vec{\tau}\|\times\|\vec{k}\|}=\frac{1}{\sqrt{z^2_x+z^2_y+1}}\]</span></p></li><li><p>二面角正切值 <span class="math display">\[\tan\theta=\sqrt{\tan^2\theta}=\sqrt{\sec^2\theta-1}=\sqrt{\frac{1}{\cos^2\theta}-1}=\sqrt{z^2_x+z^2_y}\]</span></p></li><li><p>与梯度的关系（梯度大小即最大变化率） <spanclass="math display">\[\|\nabla z(x,y)\|=\|(z_x,z_y)\|=\sqrt{z^2_x+z^2_y}=\tan\theta\]</span></p></li><li><p>梯度与等高线垂直</p></li></ol><p>（4）法向量</p><p>若曲面隐式给出 <span class="math inline">\(F(x,y,z)=0\)</span>，这表示一个等值面，显然，<span class="math inline">\(\nabla F\)</span>与该<strong>等值面</strong>垂直，即梯度 <spanclass="math inline">\(\nabla F\)</span> 就是该曲面的法向量。</p><h3 id="多元函数泰勒公式">多元函数泰勒公式</h3><p><span class="math display">\[f(\hat x_0+\hat h)=f(\hatx_0)+\sum_{k=1}^{\infty}\frac{1}{k!}(\sum_{i=1}^nh_i\frac{ \partial }{\partial x_i})^kf|_{\hat x=\hat x_0}\]</span></p><p>推导：</p><ol type="1"><li><p>将 <span class="math inline">\(\hat x_0\)</span> 的变化 ，限定在<span class="math inline">\(\hat h\)</span> 这条直线上。</p></li><li><p>将直线参数化 <span class="math inline">\(\hat x=\hatx_0+t\times\hat h\)</span></p></li><li><p>最后的函数复合 <span class="math inline">\(g(t)=f(\hatx(t))\)</span> 是一个一元函数</p></li><li><p>将一元函数泰勒展开 <span class="math display">\[g(t)=g(t_0)+\sum_{k=1}\frac{1}{k!}g^{(k)}(t_0)(t-t_0)^k\]</span></p></li><li><p>形式化展开 导数系数 <span class="math display">\[\begin{align}g^{(k)}(t)&amp;=(\frac{\partial f}{\partial x_1}\frac{dx_1}{dt}+\cdots+\frac{\partial f}{\partial x_n}\frac{dx_n}{dt})^k\\&amp;=(\frac{\partial f}{\partial x_1}h_1+\cdots+\frac{\partialf}{x_n}h_n)^k\\&amp;=(\frac{\partial }{\partial x_1}h_1+\cdots+\frac{\partial}{x_n}h_n)^kf|_{x(t)=t_o}\end{align}\]</span></p></li></ol><h3 id="极值问题">极值问题</h3><h5 id="定义条件极值">定义：条件极值</h5><p><span class="math display">\[x_0\in\mathbb{R}^n,\hspace{1em}\delta_0&gt;0,\hspace{1em}f:U(x_0,\delta_0)\rightarrow\mathbb{R},\hspace{1em}G:U(x_0,\delta_0)\rightarrow\mathbb{R}^m,\hspace{1em}m&lt;n\]</span></p><p>若 <span class="math display">\[\left.\begin{align}\forall x\in U(x_0,\delta_0)\\G(x)=0 \\\end{align}\right\}\Rightarrow f(x)\ge f(x_0) \quad or \quad f(x)\le f(x_0)\]</span> 则称 <span class="math inline">\(x_0\)</span> 是 <spanclass="math inline">\(f(x)\)</span> 在约束条件 <spanclass="math inline">\(G(x)=0\)</span> 条件下的条件极值</p><h5 id="定义必要条件">定义：必要条件</h5><p><spanclass="math inline">\(x_0\in\mathbb{R}^n,\hspace{1em}\delta_0&gt;0,\hspace{1em}f:U(x_0,\delta_0)\rightarrow\mathbb{R},\hspace{1em}G:U(x_0,\delta_0)\rightarrow\mathbb{R}^m,\hspace{1em}m&lt;n\)</span></p><p>且 f,G 都在 <span class="math inline">\(U(x_0,\delta_0)\)</span>可导，<span class="math inline">\(rank(G&#39;(x_0))=m\)</span> ，则<span class="math inline">\(x_0\)</span> 是 f(x) 在 G(x)=0下的条件极值点</p><p><span class="math inline">\(\Rightarrow G(x_0)=0,\hspace{1em}\exists\hat{\lambda_0}\quadf&#39;(x_0)+\hat{\lambda_0}G&#39;(x_0)=0\)</span></p><h2 id="向量值多元函数">向量值多元函数</h2><p>设映射 <span class="math inline">\(F: \mathring{U}(\mathbfx_0,\delta) \rightarrow \mathbb{R}^m\)</span> ，<spanclass="math inline">\(\mathbf{x}\in \mathbb{R}^n\)</span></p><p>如果存在常数矩阵 <span class="math inline">\(\mathbf{A}_{m\timesn}\)</span>，使得</p><p><span class="math inline">\(\Delta y=F(\mathbf{x_0}+\Delta\mathbf{x})-F(\mathbf{x}_0)=\mathbf{A}\Delta\mathbf{x}+R(\Delta \mathbfx)\)</span></p><p>当 <span class="math inline">\(\lim_{\Delta \mathbfx\rightarrow0}\frac{\|R(\Delta\mathbfx)\|}{\|\Delta\mathbf{x}\|}=0\)</span></p><p>则称 <span class="math inline">\(F(\mathbf x)\)</span> 在 <spanclass="math inline">\(\mathbf{x}_0\)</span> 处可微。</p><p>这个常数矩阵就是雅可比矩阵， <spanclass="math inline">\(\mathbf{J}_F\)</span>这个线性映射是在可微点的最佳线性逼近。 <span class="math display">\[\displaystyle \mathbf {f} (\mathbf {x} )=\mathbf {f} (\mathbf {p})+\mathbf {J} _{\mathbf {f} }(\mathbf {p} )(\mathbf {x} -\mathbf {p})+o(\|\mathbf {x} -\mathbf {p} \|)\]</span></p><p>小结：</p><p>向量值多元函数可微 <spanclass="math inline">\(\Leftrightarrow\)</span>每一个分量的多元函数可微</p><p><span class="math inline">\(\text{Jocbian}\)</span>矩阵就是向量值多元函数的全导数。</p><h1 id="四多元积分学">四、多元积分学</h1><h2 id="对称性">对称性</h2><ol type="1"><li><p>关于 y 轴对称</p></li><li><p>关于 x 轴对称</p></li><li><p>关于 y=x 直线对称</p></li><li><p>关于原点对称</p><blockquote><p>椭圆</p></blockquote></li></ol><h2 id="三重积分">三重积分</h2><ol type="1"><li><p>直角坐标系</p><ul><li>投影穿线法（先一后二）</li><li>定限界面法（先二后一）</li></ul></li><li><p>柱面坐标系</p><p>换元：<spanclass="math inline">\((x,y,z)\rightarrow(r,\phi,z)\)</span></p></li><li><p>球坐标系</p><p>本质上是换元 $$ {</p><span class="math display">\[\begin{aligned}x&amp;=x(r,\phi,\theta)\\y&amp;=y(r,\phi,\theta)\\z&amp;=z(r,\phi,\theta)\end{aligned}\]</span><p>. $$ 测度：<spanclass="math inline">\(\mathrm{d}v=r^2\sin{\phi}\mathrm{d}r\mathrm{d}\phi\mathrm{d}\theta\)</span></p></li><li><p>换元法（将积分区域做变换）</p></li></ol><h2 id="对弧长的曲线积分">对弧长的曲线积分</h2><p>背景意义：<strong>线质量</strong></p><p>内蕴：<strong>一维流形</strong></p><p><strong>关键</strong>：弧微分的计算</p><p>已知参数式 <span class="math display">\[\left\{\begin{aligned}x&amp;=x(t)\\y&amp;=y(t)\\z&amp;=z(t)\end{aligned}\right.\]</span></p><p>微小情况下<strong>以直代曲</strong></p><p><span class="math display">\[\|\widehat{t+\Delta t}\|=\|\mathbf x(t+\Delta t)-\mathbf x(t)\|\]</span></p><p><span class="math display">\[\begin{bmatrix}x(t+\Delta t)-x(t)\\y(t+\Delta t)-y(t)\\z(t+\Delta t)-z(t)\\\end{bmatrix}=\begin{bmatrix}x&#39;(t)\mathrm{d}t\\y&#39;(t)\mathrm{d}t\\z&#39;(t)\mathrm{d}t\\\end{bmatrix}=\begin{bmatrix}x&#39;(t)\\y&#39;(t)\\z&#39;(t)\\\end{bmatrix}\mathrm{d}t\]</span></p><p><span class="math display">\[\left\|\begin{bmatrix}x&#39;(t)\\y&#39;(t)\\z&#39;(t)\\\end{bmatrix}\mathrm{d}t\right\|=\sqrt{x&#39;(t)^2+y&#39;(t)^2+z&#39;(t)^2}\mathrm{d}t\]</span></p><p>计算：</p><ol type="1"><li><p>平面（二维）</p><ul><li><p>直角显式 <span class="math display">\[\int_L f(x,y)\,\mathrm{d}s=\int_Lf(x,y(x))\sqrt{1+y&#39;(x)^2}\,\mathrm{d}x\]</span></p></li><li><p>直角隐式</p></li><li><p>极坐标显示 <span class="math display">\[\int_Lf(x,y)\,\mathrm{d}s=\int_{\theta_1}^{\theta_2}f(r(\theta)\cos\theta,r(\theta)\sin\theta)\sqrt{r^2(\theta)+r&#39;(\theta)^2}\,\mathrm{d}\theta\]</span></p></li><li><p><strong>参数式</strong> <span class="math display">\[\left\{\begin{aligned}x&amp;=x(t)\\y&amp;=y(t)\end{aligned}\right.\]</span></p><p><span class="math display">\[\int_L f(x,y)\,\mathrm{ds}=\int_a^bf(x(t),y(t))\sqrt{x&#39;(t)^2+y&#39;(t)^2}\,\mathrm{d}t\]</span></p></li></ul></li><li><p>空间（三维中的曲线）</p><ul><li><p>空间曲线<strong>一般式</strong> <span class="math display">\[\left\{\begin{aligned}G(x,y,z)=0\\F(x,y,z)=0\end{aligned}\right.\]</span>利用对称性计算，注意计算时可以将一般式直接带入被积函数</p></li><li><p><strong>参数式</strong> <span class="math display">\[\int_C f(x, y, z) \, ds\]</span> 参数化曲线 <span class="math display">\[\mathbf{r}(t) = (x(t), y(t), z(t)), \quad a \leq t \leq b\]</span> 计算弧微分 <span class="math display">\[ds = \left\|\frac{d\mathbf{r}}{dt}\right\| \, dt =\sqrt{\left(\frac{dx}{dt}\right)^2 + \left(\frac{dy}{dt}\right)^2 +\left(\frac{dz}{dt}\right)^2} \, dt\]</span> 转成定积分 <span class="math display">\[\int_C f(x, y, z) \, \mathrm{d}s = \int_a^b f(x(t), y(t), z(t))\sqrt{\left(\frac{dx}{dt}\right)^2 + \left(\frac{dy}{dt}\right)^2 +\left(\frac{dz}{dt}\right)^2} \, \mathrm{d}t\]</span></p></li></ul></li></ol><p>（1）直角坐标 <span class="math display">\[\left\{\begin{aligned}x&amp;=x(t)\\y&amp;=y(t)\\z&amp;=z(t)\end{aligned}\right.\]</span> （2）极坐标 <span class="math display">\[\left\{\begin{aligned}x&amp;=r(\theta(t))\cos(\theta(t))\\y&amp;=r(\theta(t))\sin(\theta(t))\\\end{aligned}\right.\]</span> （3）柱面坐标 <span class="math display">\[\left\{\begin{aligned}x&amp;=r(\theta(t))\cos(\theta(t))\\y&amp;=r(\theta(t))\sin(\theta(t))\\z&amp;=z\end{aligned}\right.\]</span> （4）球坐标 <span class="math display">\[\left\{\begin{aligned}x&amp;=r(\theta(t))\sin \phi(t)\cos\theta(t)\\y&amp;=r(\theta(t))\sin \phi(t)\sin\theta(t)\\z&amp;=r(\theta(t))\cos\phi(t)\end{aligned}\right.\]</span></p><h2 id="对坐标的曲线积分">对坐标的曲线积分</h2><h3 id="计算">计算</h3><p>（1）平面（二维） <span class="math display">\[\int_{L} P(x,y)\,\mathrm{d}x+Q(x,y)\,\mathrm{d}y\]</span> 基本方法：参数法 <span class="math display">\[\int_{B}^{A}[P(x(t),y(t))+Q(x(t),y(t))y&#39;(t)]\,\mathrm{d}t\]</span> 封闭曲线：格林公式</p><ol type="1"><li>自选路径（最佳）</li><li>凑微分法（最快）</li><li>非封闭化封闭，然后用格林公式</li><li>基本方法（引参定限）</li></ol><p>若 <span class="math inline">\(\frac{\partial P}{\partialy}\ne\frac{\partial Q}{\partial x}\)</span> ，只能采用 3、4方法</p><p>（2）空间（三维） <span class="math display">\[\int_{\Gamma}P(x,y,z)\,\mathrm{d}x+Q(x,y,z)\,\mathrm{d}y+R(x,y,z)\,\mathrm{d}z\]</span> 基本方法：参数法 <span class="math display">\[\int_{B}^{A}[P(x(t),y(t),z(t))+Q(x(t),y(t),z(t))\cdoty&#39;(t)+R(x(t),y(t),z(t))\cdot z&#39;(t)]\,\mathrm{d}t\]</span> 封闭曲线：开尔文-斯托克斯（<spanclass="math inline">\(Stokes&#39;theorem\)</span>）公式</p><h2 id="对面积的曲面积分">对面积的曲面积分</h2><h3 id="面微元推导">面微元推导</h3><p><span class="math display">\[\left\{\begin{aligned}x&amp;=x(s,t)\\y&amp;=y(s,t)\\z&amp;=z(s,t)\end{aligned}\right.\]</span></p><p>三个点 <span class="math inline">\(A=(s,t),\quad B=(s+\Deltas,t),\quad C=(s,t+\Delta t)\)</span></p><p>以 A 为起点，作两段弧 <spanclass="math inline">\(\overset{\LARGE{\frown}}{AB},\quad\overset{\LARGE{\frown}}{AC}\)</span></p><p>微观极限下（弧等于线段），在直角坐标下用向量表示 <spanclass="math inline">\(\overrightarrow{AB},\quad\overrightarrow{AC}\)</span><span class="math display">\[\overrightarrow{AB}=\begin{bmatrix}x(s+\Delta s,t)-x(s,t)\\y(s+\Delta s,t)-y(s,t)\\z(s+\Delta s,t)-z(s,t)\\\end{bmatrix}=\begin{bmatrix}\frac{\partial x}{\partial s}\\\frac{\partial y}{\partial s}\\\frac{\partial z}{\partial s}\\\end{bmatrix}\mathrm{d}s=\frac{\partial\mathbf{x}}{\partial s}\mathrm{d}s\]</span></p><p><span class="math display">\[\overrightarrow{AC}=\begin{bmatrix}x(s,t)-x(s,t+\Delta t)\\y(s,t)-y(s,t+\Delta t)\\z(s,t)-z(s,t+\Delta t)\\\end{bmatrix}=\begin{bmatrix}\frac{\partial x}{\partial t}\\\frac{\partial y}{\partial t}\\\frac{\partial z}{\partial t}\\\end{bmatrix}\mathrm{d}t=\frac{\partial\mathbf{x}}{\partial t}\mathrm{d}t\]</span></p><p><span class="math display">\[\mathrm{d}\sigma=\|\overrightarrow{AB}\times\overrightarrow{AC}\|=\left|\frac{\partial\mathbf{x}}{\partials}\times\frac{\partial\mathbf{x}}{\partialt}\right|\mathrm{d}s\mathrm{d}t\]</span></p><h3 id="计算方法">计算方法</h3><p>因为第一型曲面积分是二重积分的推广，计算的本质也就是将其转换成二重积分</p><ol type="1"><li><p><strong>显示</strong>曲面（<spanclass="math inline">\(z=f(x,y)\)</span>） <span class="math display">\[\left\{\begin{aligned}x&amp;=x\\y&amp;=y\\z&amp;=z(x,y)\end{aligned}\right.\]</span></p><p><span class="math display">\[\iint_{\Sigma}f(x,y,z)\,\mathrm{d}\sigma=\iint_{\Sigma}f(x,y,z(x,y))\sqrt{1+(z&#39;_x)^2+(z&#39;_y)^2}\,\mathrm{d}x\mathrm{d}y\]</span></p><p>这样的计算方法其实是，将<strong>参数化空间</strong>选在了 <spanclass="math inline">\(xOy\)</span>面（投影法），<strong>测度</strong>恰好形式上等于将 <spanclass="math inline">\(\mathrm{d}\sigma\)</span> 投影到 <spanclass="math inline">\(xOy\)</span> 面上</p><p><spanclass="math inline">\(\mathrm{d}\sigma\cos\theta=\mathrm{d}x\mathrm{d}y\)</span></p><p>曲面的二面角从法向量找。</p></li><li><p><strong>隐式</strong>曲面（<spanclass="math inline">\(F(x,y,z)=0\)</span>）</p><blockquote><p>找<strong>法向量</strong>，计算投影角（二面角）</p><p>隐式方程 <span class="math inline">\(F\)</span>的<strong>梯度</strong>就是其对应隐函数的法向量</p></blockquote></li><li><p>参数式（<strong>核心</strong>） <span class="math display">\[\left\{\begin{aligned}x&amp;=x(s,t)\\y&amp;=y(s,t)\\z&amp;=z(s,t)\end{aligned}\right.\]</span></p><p><span class="math display">\[\iint_{\Sigma} f(x,y,z)\,\mathrm{d}S=\iint_{\Sigma}f(\mathbfx(s,t))\left|\frac{\partial\mathbf x}{\partials}\times\frac{\partial\mathbf x}{\partial t}\right|\,\mathrm{d}s\mathrm{d}t\]</span></p></li></ol><h2 id="对坐标的曲面积分">对坐标的曲面积分</h2><p><span class="math display">\[\iint_{\Sigma}P(x,y,z)\,\mathrm{d}y\mathrm{d}z+Q(x,y,z)\,\mathrm{d}x\mathrm{d}z+R(x,y,z)\,\mathrm{d}x\mathrm{d}y\]</span></p><h3 id="计算-1">计算</h3><p>（1）拆开法（基本方法）：拆开成3个<strong>二重积分</strong>算，分别投影到各自面平面上<span class="math display">\[\iint_{D_{xy}}R(x,y,z)\pm\mathrm{d}x\mathrm{d}y\]</span></p><p>（2）合一法：<strong>合成投影</strong>到一个平面上，如都合一成 <spanclass="math inline">\(\mathrm{d}x\mathrm{d}y\)</span> <spanclass="math display">\[\iint_{\Sigma}[P(x,y,z)\frac{\partial z}{\partialx}+Q(x,y,z)\frac{\partial z}{\partialy}+R(x,y,z)]\,\mathrm{d}x\mathrm{d}y\]</span></p><p>（3）化为<strong>第一型面积分</strong>： <spanclass="math display">\[\iint_{\Sigma}P(x,y,z)\cos\alpha+Q(x,y,z)\cos\beta+R(x,y,z)\cos\gamma\,\mathrm{d}\sigma\]</span> （4）对于封闭曲面：<strong>高斯公式</strong></p><h2 id="梯度定理">梯度定理</h2><p>梯度的二型线积分</p><p>对于任何标量场的梯度场是无旋场，也就是保守场（<spanclass="math inline">\(\mathbf{curl}\ \mathbf A=0\)</span>） <spanclass="math display">\[\nabla\times\nabla{f}=\mathbf{0}\]</span> 有（做功=<strong>势函数</strong>之差） <spanclass="math display">\[\int_{P[\mathbf p\rightarrow\mathbf q]}\nabla{f(\mathbfr)}\,\mathrm{d}\mathbf{r}=f(\mathbf{p})-f(\mathbf{q})\]</span></p><h1 id="五微分方程">五、微分方程</h1><h2 id="一阶方程">一阶方程</h2><p>​ （1）变量可分离型 <span class="math display">\[P(y)\mathrm{d}y=Q(x)\mathrm{d}x\]</span> ​ （2）齐次方程 <span class="math display">\[y&#39;=\phi(\frac{y}{x})\]</span> ​ 右端是0次齐次式，则是齐次方程，该方程一定能变量分离</p><p>​ （3）一阶线程微分方程 <span class="math display">\[y&#39;+P(x)y=Q(x)\]</span> ​ （4）可化为齐次 <span class="math display">\[y&#39;=f(\frac{a_1x+b_1y+c_1}{a_2x+b_2y+c_2})\]</span> ​ 1）<span class="math inline">\(c_1=c_2=0\)</span></p><p>​ 2）<span class="math inline">\(c_1^2+c_2^2\ne0\)</span></p><p>​ 1.重合</p><p>​ 2.平行</p><p>​ 3.相交</p><p>​ （5）伯努利方程 <span class="math display">\[y&#39;+P(x)y=Q(x)y^{(n)}\]</span> ​<strong>伯努利方程的解法</strong>给我们的提示：对与非线性的方程可以先消去右端的非线性因子，再通过换元变成一阶线性微分方程求解</p><p>​ （6）高阶可降阶型</p><p>​ 1）<span class="math inline">\(y&#39;&#39;=f(x)\)</span></p><p>​ 解法：<strong>连续积分</strong></p><p>​ 2）<span class="math inline">\(y&#39;&#39;=f(x,y&#39;)\)</span></p><p>​ 解法：<strong>直接换元降阶</strong> <spanclass="math inline">\(y&#39;=p,\quad y&#39;&#39;=p&#39;\)</span></p><p>​ 3）<span class="math inline">\(y&#39;&#39;=f(y,y&#39;)\)</span></p><p>​ 解法：<strong>将 <span class="math inline">\(y\)</span>作为中间变量</strong> <span class="math inline">\(y&#39;=p,\quady&#39;&#39;=\frac{\mathrm{d}p}{\mathrm{d}y}\cdot\frac{\mathrm{d}y}{\mathrm{d}x}\)</span></p><h2 id="高阶方程">高阶方程</h2><p>函数线性无关的判别？</p><p>（1）二阶常系数线性常微分方程 <span class="math display">\[y&#39;&#39;+py&#39;+qy=f(x)\]</span> （2）高阶常系数线性常微分方程</p><p>（3）欧拉方程 <span class="math inline">\(\text{Euler&#39;sequation}\)</span> <span class="math display">\[x^ny^{(n)}+x^{n-1}y^{(n-1)}+\cdots+xy=Q(x)\]</span></p><p>解法：变量代换 <span class="math inline">\(x=e^t,\quad \lnx=t\)</span> <span class="math display">\[\frac{d^ky}{dx^k}=\frac{1}{x^k}D(D-1)\cdots (D-k+1)y\]</span> 可将 <span class="math inline">\(x^k\)</span>变系数因子消去，则变为一般的常系数线性微分方程</p><p>（4）非欧拉方程的变系数</p><h3 id="非齐次特解求法">非齐次特解求法</h3><p>（1）待定系数法</p><p>（2）常数变易法</p><p>（3）<span class="math inline">\(\text{Heaviside}\)</span> 算子法</p><h2 id="全微分方程">全微分方程</h2><p>定义：两个在区域 <span class="math inline">\(D\)</span>上面的两个<strong>连续</strong>的函数 <spanclass="math inline">\(M(x,y)\)</span> 和 <spanclass="math inline">\(N(x,y)\)</span>，且<strong>具有连续的一阶偏导</strong>数，那么以下形式<strong>一阶常微分方程</strong><span class="math display">\[M(x,y)\mathrm{d}x+N(x,y)\mathrm{d}y=0\]</span>称为<strong>全微分方程</strong>，当且仅当（充要条件）存在一个连续可微的函数<span class="math inline">\(F\)</span> 称为<strong>势函数</strong>，使得<span class="math display">\[\frac{\partial F}{\partial x}=M(x,y),\quad\frac{\partial F}{\partialy}=N(x,y)\]</span></p><p>势函数存在（<strong>充要条件</strong>），当且仅当 <spanclass="math inline">\(\frac{\partial M}{\partial y}=\frac{\partialN}{\partial x}\)</span></p><p>必要性（平凡）：若势函数存在，M、N可导，导出来连续，根据克莱罗定理，则 <spanclass="math inline">\(F&#39;_{xy}=F&#39;_{yx}\)</span></p><p>充分性：</p><p>（1）对 <span class="math inline">\(M(x,y)\)</span> 偏积分 <spanclass="math display">\[F(x,y)=\int M(x,y)\,\mathrm{d}x+C(y)\]</span> （2）解 <span class="math inline">\(C(y)\)</span>，式子两端对<span class="math inline">\(y\)</span> 求偏导 <spanclass="math display">\[N(x,y)=\frac{\partial}{\partial y}\int M(x,y)\,\mathrm{d}x+C&#39;(y)\]</span> （3）证 <span class="math inline">\(C&#39;(y)\)</span>可解，也就是证它<strong>只与 <span class="math inline">\(y\)</span>有关</strong>，即证它的对 <span class="math inline">\(x\)</span>的偏导数为0</p><p>由 <span class="math display">\[C&#39;(y)=N(x,y)-\frac{\partial}{\partial y}\int M(x,y)\,\mathrm{d}x\]</span> 则式子右端对 x 求偏导 <span class="math display">\[\frac{\partial N}{\partial x}-\frac{\partial }{\partial x}\frac{\partial}{\partial y}\int M(x,y)\,\mathrm{d}x\]</span> 因为 <span class="math inline">\(M\)</span>一阶偏导连续（<span class="math inline">\(\intM(x,y)\mathrm{d}x\)</span> 二阶混合偏导连续），则交换积分次序 <spanclass="math display">\[\frac{\partial N}{\partial x}-\frac{\partial }{\partial y}\frac{\partial}{\partial x}\int M(x,y)\,\mathrm{d}x=\frac{\partial N}{\partialx}-\frac{\partial M}{\partial y}=0\]</span></p><p>（4） <span class="math display">\[C(y)=\int (N(x,y)-\frac{\partial}{\partial y}\intM(x,y)\,\mathrm{d}x)\,\mathrm{d}y\]</span> ### 求法</p><ol type="1"><li><p>凑微分（最快）</p></li><li><p>不定积分法（基本方法，即充分性证明法）</p></li><li><p>定积分法（快，线积分法） <span class="math display">\[\int^{(x,y)}_{(x_0,y_0)} M(x,y)\,\mathrm{d}x+N(x,y)\,\mathrm{d}y\]</span> 首先他是积分与路径无关（保守场），为什么？（<spanclass="math inline">\(\frac{\partial M}{\partial y}=\frac{\partialN}{\partial x}\)</span>），选路折线简单路径 <spanclass="math display">\[\int^x_{x_0}M(x,y_0)\,\mathrm{d}x+\int_{y_0}^yN(x,y)\,\mathrm{d}y\]</span> 令<spanclass="math inline">\((x_0,y_0)=(0,0)\)</span></p></li><li><p>积分因子法</p></li></ol><h1 id="六无穷级数">六、无穷级数</h1><ol type="1"><li><p>p 级数（常用、关键）</p><blockquote><p>类似的 <span class="math inline">\(\frac{1}{n\ln n}\)</span>，积分判别法可知，发散</p></blockquote></li><li><p>调和级数</p><p><spanclass="math inline">\(\frac{1}{c}=\frac{1}{2}(\frac{1}{a}+\frac{1}{b})\)</span></p></li><li><p>几何级数（何时收敛？）</p></li><li><p>自然级数</p><p><span class="math inline">\(\sum\frac{1}{n!}\)</span></p></li></ol><h2 id="审敛法">审敛法</h2><ol type="1"><li><p>正项级数</p><blockquote><p>收敛原则（充要条件）：部分和数列 <spanclass="math inline">\(S_n\)</span> 有界（单调有界原则）</p></blockquote><ul><li><p>不等式比较法</p><blockquote><p>大收则小收，小散则大散（推出有界或无界）</p></blockquote></li><li><p>极限形式比较法（无穷小比阶）</p></li><li><p>达郎贝尔<strong>比值</strong>法（Ratio test）（d'Alembert）</p><blockquote><p>取极限研究 <span class="math inline">\(n \gt N\)</span>时的性态，根据极限保号性、压缩映射构造收敛<strong>等比数列</strong>，回到比较法</p><p><span class="math inline">\(\lim\frac{u_{n+1}}{u_n}=\rho,\quad u_n\ltC(\frac{\rho+1}{2})^n\)</span></p></blockquote></li><li><p>柯西<strong>根值</strong>法</p><blockquote><p>同上</p></blockquote></li><li><p>柯西<strong>积分</strong>法</p></li></ul></li><li><p>交错项级数</p><blockquote><p>莱布尼茨判别法，两个条件：</p><p>（1）<span class="math inline">\(a_n\)</span> 单调不增</p><p>（2）<span class="math inline">\(\lim_{n\rightarrow\infty}a_n=0\)</span></p></blockquote></li><li><p>任意项级数</p><blockquote><p>加绝对值，研究 <spanclass="math inline">\(\sum_{n=1}^{\infty}|a_n|\)</span></p></blockquote><p>（1）绝对收敛</p><p>（2）条件收敛</p></li><li><p>以上都失效后</p><p>（1）定义法，求 <span class="math inline">\(\lim S_n\)</span>（数列极限问题）</p><p>（2）<span class="math inline">\(a_n\)</span><strong>展开</strong>成带皮亚诺余项的泰勒多项式</p></li></ol><h2 id="特殊的无穷小">特殊的无穷小</h2><p>当 <span class="math inline">\(n\rightarrow \infty\)</span> 时 <spanclass="math display">\[\ln n\lt n^k(k\gt 0)\lt a^n(a\gt1)\lt n!\lt n^n\]</span> 由 <span class="math inline">\(x^k(k\gt1)\)</span>的任取性可知</p><p><span class="math inline">\(\alpha(x)=\frac{1}{\ln x}\)</span>为<strong>没有最低阶的低阶无穷小</strong></p><p><span class="math inline">\(\beta(x)=\frac{1}{a^x}\)</span>为<strong>没有最高阶的高阶无穷小</strong></p><h2 id="数项级数">数项级数</h2><p>求数项级数和 <span class="math inline">\(\Sigmaa_n\)</span>的4种方法</p><p>（1）计算部分和序列极限 <span class="math inline">\(\limS_n\)</span></p><p>（2）求出相应的幂级数的和函数 <spanclass="math inline">\(S(x)\)</span>，代入值计算</p><p>（3）利用 <span class="math inline">\(f(x)\)</span>的幂级数展开式</p><p>（4）利用 <span class="math inline">\(f(x)\)</span>的傅里叶级数展开式</p><h2 id="幂级数">幂级数</h2><h3 id="注意项">注意项</h3><p>（1）通过将级数化为正项级数，再由比值或者根值法求出的 <spanclass="math inline">\(R=\frac{1}{\rho}\)</span>是<strong>充分非必要条件</strong></p><blockquote><p>即已知收敛半径 R 不能得出 <span class="math inline">\(\lim\frac{a_{n+1}}{a_n}=\frac{1}{R}\)</span></p></blockquote><p>（2）若级数 <span class="math inline">\(\sum a_nx^n,\quad\sumb_nx^n\)</span> 收敛半径 <span class="math inline">\(R_1\neR_2\)</span>，则 <span class="math inline">\(\Sigmaa_nx^n+b_nx^n\)</span> 的收敛半径 <spanclass="math inline">\(R=\min\{R_1,R_2\}\)</span></p><p>但 <span class="math inline">\(R_1=R_2=R&#39;\)</span>时，两个级数相加的收敛半径<strong>不一定</strong>是 <spanclass="math inline">\(R&#39;\)</span></p><h3 id="abel-定理">Abel 定理</h3><p>（1）若幂级数 <span class="math inline">\(\sum a_nx^n\)</span> ，在<span class="math inline">\(x_0\)</span> 处收敛，则在<spanclass="math inline">\((-|x_0|,|x_0|)\)</span>内闭<strong>绝对一致收敛</strong></p><blockquote><p>证：</p><p>取 <span class="math inline">\([a,b]\subset(-|x_0|,|x_0|),\quad x\in[a,b]\)</span></p><p>已知 <span class="math inline">\(\Sigma a_n x_0^n\)</span> 收敛，则<span class="math inline">\(\lim a_nx_0^n=0\)</span>，收敛数列有界性，则<span class="math inline">\(|a_nx_0^n|\le M\)</span> <spanclass="math display">\[|a_nx^n|=|a_nx_0^n||\frac{x^n}{x_0^n}|\ltMr^n=M\frac{\max\{|a|,|b|\}}{|x_0|}^n\]</span></p></blockquote><p>（2）若幂级数 <span class="math inline">\(\sum a_nx^n\)</span>，在<span class="math inline">\(x_1\)</span> 处发散，则在 <spanclass="math inline">\(|x|\gt|x_1|\)</span> 内发散（逆否命题）</p><p>（3）若幂级数 <span class="math inline">\(\sum a_nx^n\)</span> ，在<span class="math inline">\(x_2\)</span>处<strong>条件收敛</strong>，则收敛半径为 <spanclass="math inline">\(|x_2|\)</span></p><h3 id="函数展开成幂级数">函数展开成幂级数</h3><p>方法：</p><p>（1）直接法</p><p>直接法，需要求 <span class="math inline">\(f^{(n)}(x)\)</span>的通项，需要找规律，一般相较困难，并且需要求 <spanclass="math inline">\(\lim R_n(x)=0\)</span></p><p>（2）间接法（基本方法）</p><p>理论依据：</p><ol type="1"><li>若函数在 <span class="math inline">\(x_0\)</span>出能展开成幂级数，则必定唯一</li><li>函数的本质是对应关系（做替换）</li></ol><p>再利用：已知的几个初等函数的幂级数展开，通过幂级数性质，四则运算，逐项求导，逐项积分，展开</p><h3 id="幂级数求和函数">幂级数求和函数</h3><p>一般方法</p><ol type="1"><li>求收敛域</li><li>在收敛域内利用无穷级数<strong>代数性质</strong>，利用初等展开式公式</li></ol><p>（1）利用无穷<strong>等比级数求和公式</strong></p><p>​先导后积、先积后导，<strong>中间步骤</strong>出现类似于等比级数的样子，然后用等比级数和函数公式求和。</p><p>（2）利用五个<strong>初等函数</strong> <spanclass="math inline">\(e^x,\sin x,\cos x,\ln(1+x),(1+x)^\alpha\)</span>的麦克劳林（<spanclass="math inline">\(\text{Maclaurin}\)</span>）级数公式求和</p><p>​ 分母中出现 <span class="math inline">\(\frac{1}{n!}\)</span>这种形式，只能往 <span class="math inline">\(e^x\)</span> 和 <spanclass="math inline">\((1+x)^\alpha\)</span> 的级数去凑</p><p>​ 中间过程注意，级数下标保持正确。</p><p>（3）利用解常微分方程初值问题的特解方法</p><h2 id="傅里叶级数">傅里叶级数</h2><blockquote><p>现代数学的发源地，黎曼积分的引入（研究傅里叶级数的敛散性）、抽象函数空间（内积空间）、康托集合论、勒贝格积分（黎曼积分的推广）</p></blockquote><h3 id="支撑知识">支撑知识</h3><p>（1）函数空间 <span class="math display">\[\mathscr{C}[a,b]=\{f|f是[a,b]上的连续函数\}\]</span> （2）空间上距离（度量） <span class="math display">\[\text{dis}(f,g)=\max\{|f(x)-g(x)|\}\]</span> 求一个 <span class="math display">\[\hat g=\arg\min_{g}\{\text{dis}(f,g)\},\quad g\in \mathscr{C}[a,b]\]</span> （3）内积空间 <span class="math display">\[(\mathcal{L},\langle  x,y \rangle),\quad x,y\in\mathcal{L},\quad \langlex,y\rangle\in \mathbb{R}\]</span> 性质：</p><ol type="1"><li>对称性 <span class="math inline">\(\langle x,y\rangle=\langley,x\rangle\)</span></li><li>双线性性 <span class="math inline">\(\langleax_1+bx_2,y\rangle=a\langle x_1,y\rangle+b\langlex_2,y\rangle\)</span></li><li>正定性 <span class="math inline">\(\langle x,x\rangle\ge0\)</span></li><li>柯西-施瓦茨不等式 <span class="math inline">\(\langlex,y\rangle\le\sqrt{\langle x,x\rangle}\times\sqrt{\langley,y\rangle}\)</span></li></ol><p>（4）长度 <span class="math display">\[\|x\|=\sqrt{\langle x,x\rangle}\]</span> 性质：</p><ol type="1"><li>三角不等式</li><li>正交</li><li>勾股定理</li></ol><p>（5）标准正交基 <span class="math display">\[\|x_i\|=1,\quad x_i\perp x_j\]</span></p><p>（6）沿着普通正交基展开（解线性方程组） <span class="math display">\[x=A^{-1}b\\x=\frac{Adj(A)}{|A|}b\]</span> 求 <span class="math inline">\(x_j\)</span> 就是根据 <spanclass="math inline">\(Cramel\)</span> 法则，将A中的 第<spanclass="math inline">\(j\)</span> 列替换成 b, 然后沿着 <spanclass="math inline">\(j\)</span> 列展开替换后的行列式 再除以 <spanclass="math inline">\(|A|\)</span></p><p>这样，求第 <span class="math inline">\(j\)</span>个未知数，具有<strong>耦合性</strong></p><p>（7）沿着正交基展开（具有<strong>解耦性</strong>） <spanclass="math display">\[\alpha_1x_1+\alpha_2x_2+\cdots+\alpha_nx_n=b\]</span> 求 <span class="math inline">\(x_j\)</span>，则将等式两边同时内积 <spanclass="math inline">\(\langle\alpha_j,左\rangle=\langle\alpha_j,右\rangle\)</span><span class="math display">\[x_j=\frac{\langle\alpha_j,b\rangle}{\langle\alpha_j,\alpha_j\rangle}\]</span> （8）沿着标准正交组（正交矩阵，解耦性） <spanclass="math display">\[x=A^{-1}b=A^{T}b\]</span> （9）最优逼近（代数求法）</p><p>求 <span class="math display">\[\hat x=\arg\min_{x\in\mathcal{L}}{\|\beta-x\|}\]</span></p><p>（10）最优逼近（几何求法）（子空间投影）</p><p>求 <span class="math inline">\(\beta\)</span>在某个子空间上的最优逼近 <span class="math inline">\(\hat x\)</span></p><blockquote><p>就是 <span class="math inline">\(\beta\)</span>在子空间上的投影，<span class="math inline">\(\hatx=\mathrm{Proj}_{\mathcal{L}}\beta\)</span>，最优解是系数向量，</p><p>充分性可由三垂线定理得到</p></blockquote><p>已知 <span class="math inline">\(\beta,A\)</span> <spanclass="math display">\[\beta-(\alpha_1x_1+\cdots\alpha_n x_n)\perp\alpha_j(j=1,\cdots n)\]</span> 联立n 个方程 <span class="math display">\[\langle\alpha_1,\beta-(\alpha_1x_1+\cdots\alpha_n x_n)\rangle=0\\\langle\alpha_2,\beta-(\alpha_1x_1+\cdots\alpha_n x_n)\rangle=0\\\vdots\\\langle\alpha_n,\beta-(\alpha_1x_1+\cdots\alpha_n x_n)\rangle=0\\\]</span> 计算内积，化简 <span class="math display">\[\langle\alpha_1,\beta\rangle-x_1\langle\alpha_1,\alpha_1\rangle=0\\\langle\alpha_2,\beta\rangle-x_2\langle\alpha_2,\alpha_2\rangle=0\\\vdots\\\langle\alpha_n,\beta\rangle-x_n\langle\alpha_n,\alpha_n\rangle=0\\\]</span> （11）Bessel 不等式（类似勾股定理） <spanclass="math display">\[\|\beta-\hat x\|^2+\|\hat x\|^2=\|\beta\|^2\\\|\hat x\|^2\le\|\beta\|^2\\\|\alpha_1\|^2|k_1|^2+\cdots+\|\alpha_n\|^2|k_n|^2\le\|\beta\|^2\]</span></p><h3 id="函数内积空间">函数内积空间</h3><p>（1）平方可积空间 <span class="math display">\[\mathscr{L}^2[a,b]=\{f|f是[a,b]上平方可积的函数\}\]</span> （2）具备内积 <span class="math display">\[\langle f,g\rangle=\int_a^b f(x)g(x)\mathrm{d}x,\quad\in\mathbb{R}\]</span> （3）定义长度 <span class="math display">\[\|f\|=\sqrt{\langle f,f\rangle}=\sqrt{\int_a^b f(x)^2\mathrm{d}x}\]</span> （4）定义距离（差异度） <span class="math display">\[\|f-g\|\]</span> （5）最佳逼近 <span class="math display">\[\hat g=\arg\min_{g\in \mathcal{P}_n}\{\|f-g\|\}\]</span> 这个解就是傅里叶多项式</p><p>（6）考虑子空间（三角多项式的全体）</p><p><strong>一个正交函数系（关键）</strong> <span class="math display">\[span\{1,\cos \frac{\pi}{l}kx,\sin\frac{\pi}{l}kx\},\quad k=1,2,\cdotsn,\quad \mathcal{L}^2[-l,l]\]</span> 以该系构造多项式 <span class="math display">\[\mathcal{P}_n=\{\sum_{k=0}^{n}(a_k\cos\frac{\pi}{l}kx+b_k\sin\frac{\pi}{l} kx)|a_k,b_k\in\mathbb{R}\},\quad\mathcal{P}_n\subset \mathscr{L}^2\]</span> 实际上有<span class="math inline">\(2n+1\)</span> 个基函数<span class="math display">\[\mathcal{P}_n=a_0\cdot1+\sum_{k=1}^{n}(a_k\cos\frac{\pi}{l}kx+b_k\sin\frac{\pi}{l}kx)\]</span> 这组基的正交性，显然</p><p>解偶性求系数： <span class="math display">\[a_k=\frac{\langle\cos\frac{\pi}{l}kx,f(x)\rangle}{\langle\cos\frac{\pi}{l}kx,\cos\frac{\pi}{l}kx\rangle},\quadb_k=\frac{\langle\sin\frac{\pi}{l}kx,f(x)\rangle}{\langle\sin\frac{\pi}{l}kx,\sin\frac{\pi}{l}kx\rangle}\]</span> 特别的 <span class="math display">\[a_0=\frac{\langle\cos\frac{\pi}{l}kx,f(x)\rangle}{2l}\]</span></p><h3 id="狄利克雷收敛定理">狄利克雷收敛定理</h3><p><span class="math inline">\(f(x)\)</span> 以 <spanclass="math inline">\(2l\)</span> 为周期，且在<spanclass="math inline">\([-l,l]\)</span> 上可积</p><p>则将 <span class="math inline">\(f(x)\)</span> 按正弦函数展开 <spanclass="math display">\[f(x)\sim\frac{a_0}{2}+\sum_{k=1}^\infty(a_k\cos\frac{\pi}{l}kx+b_k\sin\frac{\pi}{l}kx)\]</span> 则其级数在 <span class="math inline">\([-l,l]\)</span>上收敛，记其和函数 <span class="math inline">\(S(x)\)</span> <spanclass="math display">\[S(x)=\begin{cases}f(x),&amp; x\text{ is continuous}\\\displaystyle\frac{f(x-0)+f(x+0)}{2},&amp; x\text{ is uncontinuous}\\\displaystyle\frac{f(-l+0)+f(l-0)}{2},&amp; x=\pm l\end{cases}\]</span></p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>高等数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Math</tag>
      
      <tag>Calculus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络 #0 应试笔记</title>
    <link href="/2024/10/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_0_%E5%BA%94%E8%AF%95%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/10/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_0_%E5%BA%94%E8%AF%95%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="一物理层">一、物理层</h1><h1 id="二数据链路层">二、数据链路层</h1><h2 id="三个基本问题">2.1 三个基本问题</h2><ul><li>封装成帧</li><li>透明传输</li><li>差错检测</li></ul><h2 id="点对点信道">2.2 点对点信道</h2><h3 id="ppp-协议">PPP 协议</h3><h4 id="特点">特点</h4><ol type="1"><li>简单</li><li>封装成帧</li><li>透明性</li><li>多种网络层协议</li><li>多种类型链路</li><li>差错检测</li><li>检测连接状态</li><li>最大传送单元</li><li>网络层地址协商</li><li>数据压缩协商</li></ol><h4 id="组成">组成</h4><ol type="1"><li>一个将 IP 数据报封装到串行链路的方法</li><li>一个用来建立、配置和测试数据链路连接的链路控制协议 LCP</li><li>一套网络控制协议 NCP</li></ol><h4 id="格式">格式</h4><table><thead><tr><th>字段</th><th>长度</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>F</td><td>1B</td><td>0x7E</td><td>标志</td></tr><tr><td>A</td><td>1B</td><td>0xFF</td><td>地址字段，暂无用途</td></tr><tr><td>C</td><td>1B</td><td>0x03</td><td>控制字段，暂无用途</td></tr><tr><td>协议</td><td>2B</td><td></td><td>网络层所用的协议</td></tr><tr><td>数据部分</td><td>小于MTU</td><td></td><td>数据信息字段</td></tr><tr><td>FSC</td><td>2B</td><td></td><td>CRC帧检验FSC序列</td></tr><tr><td>F</td><td>1B</td><td>0x7E</td><td>标志</td></tr></tbody></table><h4 id="字节填充">字节填充</h4><p>当PPP协议进行异步传输时，采用字节填充</p><ol type="1"><li><p>把信息字段中出现的每一个 0x7E 转变成两字节序列（0x7D0x5E）</p></li><li><p>若信息字段中出现了一个 0x7D 字节，则转变成 0x7D 0x5D</p></li><li><p>若信息字段中出现了ASCII 码控制字符，例如 0x03，则转变为 0x7D0x23</p></li></ol><h4 id="零比特填充">零比特填充</h4><p>PPP协议用在 SONET/SDH 链路时，使用同步传输，采用零比特填充</p><p>原理：发送端扫描信息字段，发现有5个连续的1，立即填充一个0</p><h2 id="广播信道">2.3 广播信道</h2><h3 id="共享传输媒体">2.3.1 共享传输媒体</h3><ol type="1"><li><p>静态划分信道</p><p>频分复用、TDM、CDM等</p></li><li><p>动态媒体接入控制（多点接入 MA）</p><ul><li><p>随机接入</p><p>用户随机地发送消息，会产生碰撞</p></li><li><p>受控接入</p><p>用户不能随机发送消息</p></li></ul></li></ol><h3 id="csmacd-协议">2.3.2 CSMA/CD 协议</h3><p>Carrier-Sense Multiple Access with Collision Detection载波监听多路访问/碰撞检测，是一种传输介质访问控制（MAC）方法。</p><h4 id="截断二进制指数退避算法">2.3.2.1 截断二进制指数退避算法</h4><ol type="1"><li><p>协议规定了基本争用时间为 <spanclass="math inline">\(2\tau\)</span>，具体时间是 51.2 微秒</p></li><li><p>从离散整数集合 <spanclass="math inline">\([0,1,\cdots,2^k-1]\)</span>，随机取出一个数记为r，重传应推后的时间就是争用期的 r 倍 <span class="math display">\[k=\min\{重传次数,10\}\]</span></p></li><li><p>当重传次数达16次仍不能成功时，则丢弃该帧，并向高层报告</p></li></ol><h3 id="mac帧">2.3.3 MAC帧</h3><h4 id="dix-ethernet-v2-标准">DIX Ethernet V2 标准</h4><table><thead><tr><th>字段</th><th>大小</th></tr></thead><tbody><tr><td>目的地址</td><td>6B</td></tr><tr><td>源地址</td><td>6B</td></tr><tr><td>类型</td><td>2B</td></tr><tr><td>数据</td><td>46-1500B</td></tr><tr><td>FCS</td><td>4B</td></tr></tbody></table><h4 id="类型">类型</h4><table><thead><tr><th>值</th><th>含义</th></tr></thead><tbody><tr><td>0x0800</td><td>IPV4</td></tr><tr><td>0x0806</td><td>ARP</td></tr><tr><td>0x8100</td><td>IPV6</td></tr></tbody></table><h2 id="扩展的以太网">2.4 扩展的以太网</h2><h3 id="转发器中继器">2.4.1 转发器（中继器）</h3><p>Repeater，物理层扩展</p><h3 id="集线器">2.4.2 集线器</h3><p>Hub是物理层的扩展，将多条以太网双绞线或者光纤集合连接在同一段物理介质下</p><p>连接的设备都处于同一网段下，同一冲突域</p><p>用电子器件模拟实际电缆工作，从逻辑上还是总线结构</p><p>半双工的通信方式采用CSMA/CD的冲突检测方法</p><p>每一个数据包都被发送到集线器的每一个端口</p><h3 id="网桥">2.4.3 网桥</h3><p>Network Bridge，有内部数据库</p><ul><li>网桥能够识别数据链路层中的数据帧，并将这些数据帧临时存储于内存，再重新生成信号作为一个全新的数据帧转发给相连的另一个网段（networksegment）。由于能够对数据帧拆包、暂存、重新打包（称为存储转发机制store-and-forward），网桥能够连接不同技术参数传输速率的数据链路，如连接10BASE-T与100BASE-TX。</li><li>数据帧中有一个位叫做FCS，用来通过CRC方式校验数据帧中的位。网桥可以检查FCS，将那些损坏的数据帧丢弃。</li><li>网桥在向其他网段转发数据帧时会做冲突检测控制。</li><li>网桥还能通过地址自学机制和过滤功能控制网络的流量，具有OSI第2层网络交换机功能。这称为transparentbridge，由DEC在1980年代发明。其机制是网桥内部有一个数据库，最初没有数据。当网桥从一个网段收到一个数据帧，就会在数据库中登记（或者更新）数据帧的源地址属于这个网段，并检查数据包的目的地址。如果目的地址在数据库中属于另外一个网段，则网桥向该网段转发该数据帧；如果目的地址在数据库中没有记录，则网桥向除了源地址所在之外的其他所有网段转发（flood）该数据帧。</li><li>桥接器仅仅在不同网络之间有数据传输的时候才将数据转发到其他网络，不是像集线器那样对所有数据都进行广播。对于以太网，“桥接”这一术语正式的含义是指符合IEEE802.1D标准的设备，即“网络切换”。桥接器可以分割网段，不似集线器仍是在为同一碰撞域，所以对带宽耗损较小。因桥接器透过其内之MAC表格，让发送帧不会通过，所以其称之为数据链接层操作之网络组件，可隔离碰撞。</li></ul><h3 id="交换机">2.4.4 交换机</h3><p>Network Switch，相当于多端口的网桥（NetworkBridge），有内部数据库，提供多端口的二层桥接是以太网交换机的核心功能</p><p>（1）特点</p><ol type="1"><li>独占媒体，无碰撞传输</li><li>硬件转发</li><li>存储转发</li></ol><p>（2）工作方式</p><p>当一台交换机安装配置好之后，其工作过程如下：</p><ul><li>收到某网段（设为A）MAC地址为X的计算机发给MAC地址为Y的计算机的数据包。交换机从而记下了MAC地址X在网段A。这称为学习（learning）。</li><li>交换机还不知道MAC地址Y在哪个网段上，于是向除了A以外的所有网段转发该数据包。这称为泛洪（flooding）。</li><li>MAC地址Y的计算机收到该数据包，向MAC地址X发出确认包。交换机收到该包后，从而记录下MAC地址Y所在的网段。</li><li>交换机向MAC地址X转发确认包。这称为转发（forwarding）。</li><li>交换机收到一个数据包，查表后发现该数据包的来源地址与目的地址属于同一网段。交换机将不处理该数据包。这称为过滤（filtering）。</li><li>交换机内部的MAC地址-网段查询表的每条记录采用时间戳记录最后一次访问的时间。早于某个阈值（用户可配置）的记录被清除。这称为老化（aging）。</li></ul><h2 id="协议">2.5 协议</h2><h3 id="vlanieee-802.1q">2.5.1 VLAN（IEEE 802.1Q）</h3><h3 id="以太网ieee-802.3">2.5.2 以太网（IEEE 802.3）</h3><h3 id="wi-fiieee-802.11">2.5.3 Wi-Fi（IEEE 802.11）</h3><h1 id="三网络层">三、网络层</h1><h2 id="mindmap">MindMap</h2><pre><code class=" mermaid">mindmap))网络层(((IP)(ICMP)[差错报告报文]3终点不可达11时间超过12参数问题5改变路由[询问报文]回送请求和回答时间戳请求和回答(路由选择协议)[内部网关协议]RIPOSPF五类报文HelloDDLSRLSULSA七种状态[外部网关协议]BGP</code></pre><h2 id="网际协议-ip">网际协议 IP</h2><h3 id="格式-1">格式</h3><table><thead><tr><th>字段</th><th>长度（bit）</th></tr></thead><tbody><tr><td>协议版本</td><td>4</td></tr><tr><td>首部长度</td><td>4</td></tr><tr><td>区分服务</td><td>8</td></tr><tr><td>总长度</td><td>16</td></tr><tr><td>标识</td><td>16</td></tr><tr><td>标志</td><td>3</td></tr><tr><td>片偏移</td><td>13</td></tr><tr><td>生存时间</td><td>8</td></tr><tr><td>协议</td><td>8</td></tr><tr><td>首部校验和</td><td>16</td></tr><tr><td>源地址</td><td>32</td></tr><tr><td>目的地址</td><td>32</td></tr></tbody></table><h3 id="协议类型">协议类型</h3><table><thead><tr><th>字段值</th><th>含义</th></tr></thead><tbody><tr><td>1</td><td>ICMP</td></tr><tr><td>2</td><td>IGMP</td></tr><tr><td>4</td><td>IP</td></tr><tr><td>6</td><td>TCP</td></tr><tr><td>8</td><td>EGP</td></tr><tr><td>9</td><td>IGP</td></tr><tr><td>17</td><td>UDP</td></tr><tr><td>41</td><td>IPv6</td></tr><tr><td>50</td><td>ESP</td></tr><tr><td>89</td><td>OSPF</td></tr></tbody></table><h2 id="网际控制报文协议-icmp">网际控制报文协议 ICMP</h2><h2 id="互联网路由选择协议">互联网路由选择协议</h2><h1 id="四传输层">四、传输层</h1><h2 id="mindmap-1">MindMap</h2><pre><code class=" mermaid">mindmap))传输层(((UDP: 面向报文的)[首部：8字节]源端口目的端口长度校验和[二进制反码校验](TCP: 面向字节的)[首部：20字节]源端口目的端口序号确认号数据偏移保留标志窗口校验和紧急指针[传输效率](传输时机)MSS应用程序指定: PSH,URG计时器(Ngle算法)(糊涂窗口综合症)[拥塞控制]慢开始拥塞避免快重传快恢复</code></pre><h1 id="五应用层">五、应用层</h1>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Computer</tag>
      
      <tag>Science</tag>
      
      <tag>Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计组应试笔记 #1 CRC</title>
    <link href="/2024/10/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%BB%84_1_CRC/"/>
    <url>/2024/10/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%BB%84_1_CRC/</url>
    
    <content type="html"><![CDATA[<h1 id="一什么是crc">一、什么是CRC</h1><p><strong>Cyclic Redundancy Check</strong>，循环冗余校验。</p><h1 id="二计算步骤">二、计算步骤</h1><blockquote><p>计算校验位的计算步骤</p></blockquote><ol type="1"><li>展开多项式得到CRC除数</li><li>原始数据串末端添0</li><li>从左往右，按位异或</li></ol><h2 id="展开多项式得到crc除数">1)展开多项式，得到CRC除数</h2><p>如多项式：<span class="math inline">\(x^4+x+1\)</span></p><p>展开之后：<spanclass="math inline">\(1*x^4+0*x^3+0*x^2+1*x+1*x^0\)</span></p><p>取系数，得到除数：<code>10011</code></p><h2 id="原始数据末端添0">2)原始数据末端添0</h2><p>根据多项式最高阶，在原始数据末端添0</p><p>例如</p><p>原始数据<code>1101011011</code>+<code>0000</code></p><h2 id="从左往右按位异或">3)从左往右，按位异或</h2><p>将添零后的原始数据作为被除数，CRC和作为除数</p><p>进行模二除法</p><p>将得到的余数，按多项式位数-1的位数补零。</p><p>得到校验码<code>1110</code></p><p>最终的CRC码：<code>1101011011+1110</code></p><h1 id="三校验">三、校验</h1><p>将 <code>数据项+校验码</code>作为被除数，除以选定的多项式，</p><p>余数如果为0，则校验成功。</p><h1 id="四纠错">四、纠错</h1><p>计算机可以通过计算，预先知道，第一位出错对应的余数<spanclass="math inline">\(R(x)\)</span></p><p>如果计算机收到一串有错的CRC码，则将重复执行：</p><ol type="1"><li>将余数末端补一个0，除以<spanclass="math inline">\(G(x)\)</span>，得余数<spanclass="math inline">\(R(x)\)</span></li><li>CRC码循环左移</li><li>判断余数是否是计算机已知第一位出错所对应的余数，若是，则纠错并回到步骤一，若不是，则回到步骤一。</li></ol><p>当余数回到最初的余数值，原数据信息已纠错，并且回到正确的位置。</p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机组成原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CO</tag>
      
      <tag>Computer Science</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计组应试笔记 #2 Cache</title>
    <link href="/2024/10/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%BB%84_2_Cache/"/>
    <url>/2024/10/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%BB%84_2_Cache/</url>
    
    <content type="html"><![CDATA[<h1 id="一cache-与主存映射">一、cache 与主存映射</h1><ul><li>直接映射</li><li>全相联映射</li><li>组相联映射</li></ul><h2 id="直接映射">1、直接映射</h2><h2 id="全相联映射">2、全相联映射</h2><h2 id="组相联映射">3、组相联映射</h2><h1 id="二cache-替换算法">二、cache 替换算法</h1><ul><li>FIFO</li><li>LRU</li></ul><h1 id="三未命中策略">三、未命中策略</h1><ol type="1"><li>CPU与主存有数据通路，未命中cpu直接读字</li><li>未命中，辅助器件将块从主存加载到cache，cpu再从cache里面读。</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机组成原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CO</tag>
      
      <tag>Computer Science</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript #1 基础</title>
    <link href="/2024/10/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JavaScript/"/>
    <url>/2024/10/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JavaScript/</url>
    
    <content type="html"><![CDATA[<h1 id="js基本数据类型">JS基本数据类型</h1><h2 id="一基本数据类型">一、基本数据类型</h2><ol type="1"><li>String</li><li>Number</li><li>Boolean</li><li>Undefined</li><li>Null</li></ol><h2 id="二引用数据类型">二、引用数据类型</h2><blockquote><p>Object(Array、Date、RegExp、Function)</p></blockquote><hr /><h1 id="async-await">async &amp; await</h1><ul><li><p><strong>await</strong> 关键字作用：</p><blockquote><p>等待后面的 <strong>promise</strong> 对象的 <strong>resolve</strong>状态，若后面为非 <strong>promise</strong>对象，会将其用<code>Promise.resolve()</code>转换。</p><p>监听到 <strong>resolve</strong> 状态之后，将<strong><em>await下面的语句</em></strong> 推送到<em>微队列</em>；若无语句，则将 <strong><em>async函数结束操作</em></strong> 推送到 <em>微队列</em></p></blockquote></li></ul><hr /><h2 id="例题">例题</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">asy1</span>(<span class="hljs-params"></span>)&#123;<br>    <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>)<br><br>    <span class="hljs-keyword">await</span> <span class="hljs-title function_">asy2</span>()<br><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>)<br><br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">asy2</span>(<span class="hljs-params"></span>)&#123;<br><br>    <span class="hljs-keyword">await</span> <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>)<br>        &#125;)<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span>)<br>    &#125;,<span class="hljs-number">0</span>)<br><br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">asy3</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">6</span>)<br>    &#125;)<br>&#125;<br><br><span class="hljs-title function_">asy1</span>()<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">7</span>)<br><br><span class="hljs-title function_">asy3</span>()<br><br><span class="hljs-comment">//输出结果 1,7,6,2,4,3</span><br></code></pre></td></tr></table></figure><hr /><ul><li><p>如何判断一个函数是否是 <strong><em>async</em></strong> 函数？</p><blockquote><p>解决办法：</p><p>async函数的原型是 <strong>AsyncFunction</strong></p><p>async函数中有个Symbol.toStringTag，<code>func[Symbol.toStringTag]='AsyncFunction'</code></p></blockquote></li></ul><hr /><h1 id="拷贝">拷贝</h1><ul><li><h2 id="浅拷贝">浅拷贝</h2><blockquote><p>浅拷贝会将对象的每个属性进行依次复制，但当属性是一个引用类型时，实际复制的是一个其引用，当指向的引用发生改变时，也会随之变化。</p></blockquote></li><li><h2 id="深拷贝">深拷贝</h2><blockquote><p>深拷贝复制变量的值，对于引用数据类型，则递归至基本类型，再进行复制。</p><p>深拷贝的对象与原对象是完全隔离的，互不影响。</p></blockquote></li><li><h2 id="区别">区别</h2><blockquote><p>在有指针的情况下，浅拷贝只是增加了一个新的指针指向一个已存在的内存，而深拷贝则是增加一个新指针，并且申请一个新的内存，这个新指针指向新内存。</p></blockquote></li></ul><hr /><h1 id="相等">相等</h1><ul><li><h3 id="宽松相等">宽松相等 ==</h3><blockquote><p>宽松相等会在进行比较之前将两边操作数进行<strong>强制类型转换</strong>，故只要操作数值相同，就返回<strong>true</strong></p></blockquote></li><li><h3 id="严格相等">严格相等 ===</h3><blockquote><p>严格相等<strong>不进行强制类型转换</strong></p></blockquote></li></ul><hr /><h1 id="模块化标准">模块化标准</h1><ul><li><h3 id="commonjs-社区标准">CommonJS 社区标准</h3><blockquote><p><strong>CommonJS</strong>是2009年，由JavaScript社区提出的一个模块化标准，后被<strong>Node.js</strong> 实现。</p></blockquote><p>导出方式有<strong>三种</strong>：</p><ol type="1"><li><strong>module.exports对象</strong></li></ol><p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>=&#123;<br>    变量<span class="hljs-number">1</span>,<br>     变量<span class="hljs-number">2</span><br> &#125;<br></code></pre></td></tr></table></figure></p><ol start="2" type="1"><li><strong>exports对象</strong></li></ol><p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">exports</span>.<span class="hljs-property">var1</span>=var1<br><span class="hljs-built_in">exports</span>.<span class="hljs-property">var2</span>=var2<br></code></pre></td></tr></table></figure></p><ol start="3" type="1"><li><strong>this对象</strong></li></ol><p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">this</span>.<span class="hljs-property">var1</span>=var1<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">var2</span>=var2<br></code></pre></td></tr></table></figure></p><blockquote><p>这三个对象，初始时都指向一个 <strong>module.exports={} </strong>空对象</p></blockquote><p>导入方式：</p><p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> impo=<span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;/test.js&quot;</span>)<br></code></pre></td></tr></table></figure></p><blockquote><p>导入函数 <code>require()</code> 最终返回的是<code>mudole.exports</code> 对象</p></blockquote><p><strong>注意！</strong>CommonJS中的导入是对原始值的<strong>拷贝</strong>，改变被导入模块中的值不会影响当前模块的值。而<strong>ESM</strong>中，导入是对原始值的<strong>引用</strong>。</p></li><li><h3 id="es-module-官方标准">ES Module 官方标准</h3><blockquote><p><strong>ES Module</strong> 是ES6时提出的官方标准。</p></blockquote><p>导出</p><ol type="1"><li>命名导出</li><li>默认导出</li></ol></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机技术</category>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Technology</tag>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java #1 基础</title>
    <link href="/2024/10/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/"/>
    <url>/2024/10/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/</url>
    
    <content type="html"><![CDATA[<h1 id="一历史">一、历史</h1><h2 id="历史版本">1.1 历史版本</h2><ol type="1"><li><p><strong>JDK Alpha 和 Beta</strong></p></li><li><p><strong>JDK 1.0</strong></p><blockquote><p><strong>Released: January 23, 1996</strong></p></blockquote></li><li><p><strong>JDK 1.1</strong></p><blockquote><p><strong>Released: February 19, 1997</strong></p></blockquote></li><li><p><strong>J2SE 1.2</strong></p><blockquote><p><strong>Released: December 8, 1998</strong></p><p><strong>Codename: Playground</strong></p><p>The release on December 8, 1998 and subsequent releases through J2SE5.0 were rebranded retrospectively <strong>Java 2</strong> and theversion name "J2SE" replaced JDK to distinguish the base platform fromJ2EE and J2ME.</p><p>This was a very significant release of Java as it tripled the size ofthe Java platform to 1520 classes in 59 packages.</p></blockquote></li><li><p><strong>J2SE 1.3</strong></p><blockquote><p><strong>Released: May 8, 2000</strong></p><p><strong>Codename: Kestrel</strong></p></blockquote></li><li><p><strong>J2SE 1.4</strong></p><blockquote><p><strong>Released: February 6, 2002</strong></p><p><strong>Codename: Merlin</strong></p></blockquote></li><li><p><strong>J2SE 5.0</strong></p><blockquote><p><strong>Released: September 30, 2004</strong></p><p><strong>Codename: Tiger</strong></p><p>The release on September 30, 2004 was originally numbered 1.5, whichis still used as the internal version number.</p><p>The number was changed to "better reflect the level of maturity,stability, scalability and security of the J2SE"</p><p>Both version numbers "1.5.0" and "5.0" are used to identify thisrelease of the Java 2 Platform Standard Edition.</p><p>Version "5.0" is the product version, while "1.5.0" is the developerversion.</p><p>This correspondence continued through later releases (Java 6 = JDK1.6, Java 7 = JDK 1.7, and so on).</p></blockquote></li><li><p><strong>Java SE 6</strong></p><blockquote><p><strong>Released: November 11, 2006</strong></p><p><strong>Codename: Mustang</strong></p><p>As of the version released on December 11, 2006, Sun replaced thename "J2SE" with <strong>Java SE</strong> and dropped the ".0" from theversion number.</p><p>Internal numbering for developers remains 1.6.0.</p></blockquote></li><li><p><strong>Java SE 7</strong></p><blockquote><p><strong>Released: July 28, 2011</strong></p><p><strong>Codename: Dolphin</strong></p><p>Lambda (Java's implementation of lambda functions), Jigsaw (Java'simplementation of modules), and part of Coin were dropped from Java 7,and released as part of Java 8</p></blockquote></li><li><p><strong>Java SE 8</strong></p><blockquote><p><strong>Released: March 18, 2014</strong></p><p>Java 8 was released on March 18, 2014, and included some featuresthat were planned for Java 7 but later deferred.</p></blockquote></li></ol><h1 id="二基础">二、基础</h1><h2 id="java-基本类型">2.1 Java 基本类型</h2><blockquote><p>[!NOTE]</p><p>从 Java 7开始，可以给数字字面量加下划线，编译器会去除这些下划线。</p></blockquote><p>Java 有<strong>8</strong>种基本类型（primitive type）</p><ul><li><p><strong>整型</strong></p><ol type="1"><li>int</li><li>long</li><li>short</li><li>byte</li></ol></li><li><p><strong>浮点型</strong></p><ol type="1"><li>float</li><li>double</li></ol></li><li><p><strong>字符型</strong></p><ul><li><p>char</p><blockquote><p>[!NOTE]</p><p>转义序列 <code>\u</code>除了可以出现在单双引号内，还可以出现在其外，Unicode转义序列会在解析代码之前得到处理</p></blockquote></li></ul></li><li><p><strong>布尔型</strong></p><ul><li><p>boolean</p><blockquote><p>[!WARNING]</p><p>C++ 中值 0 相当于 false，非 0 值相当于 true</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>( x=<span class="hljs-number">0</span> )<br></code></pre></td></tr></table></figure><p>C++ 可以通过编译运行，而 Java 中整型表达式不能转换成布尔值</p></blockquote></li></ul></li></ul><h2 id="字符串">2.2 字符串</h2><blockquote><p>[!NOTE]</p><p>java 没有提供内置的字符串数据类型，但是标准库提供了一个预定义类<code>String</code>，每一个用双引号引起来的字符串都是该类的一个对象。</p></blockquote><h3 id="子串">子串</h3><p>String 类提供了一个方法<code>substring</code>，第二个参数是不想复制的第一个位置，优点是容易计算子串长度。</p><h3 id="拼接">拼接</h3><ol type="1"><li>静态方法<code>String.join()</code>：将多个字符串用界定符拼接起来</li><li>实例方法 <code>repeat()</code>：重复拼接字符串该实例，由 Java11提供</li></ol><h3 id="不可变字符串">不可变字符串</h3><blockquote><p>[!IMPORTANT]</p><p>优点：编译器可以让字符串共享，在复制一个字符串变量时，原始字符串和复制字符串共享相同的字符</p></blockquote><blockquote><p>[!NOTE]</p><p>ANSI C++ 定义了 String类型，也可以自动进行内存分配和回收，但可以修改字符串中的单个字符。</p></blockquote><h3 id="检测字符串是否相等">检测字符串是否相等</h3><ol type="1"><li>实例方法 <code>equals()</code>，判断两个字符串是否相等</li><li>忽略大小写 <code>equalsIgnoreCase()</code></li><li>实例方法 <code>compareTo()</code></li></ol><blockquote><p>[!WARNING]</p><p><code>==</code>只能确定两个字符串是否放在同一位置上，事实上，只有字符串字面量是共享的</p><p><code>+</code> 和 <code>substring</code> 得到的都不是共享的</p><p>但在 c++ 中，重载了运算符 <code>==</code>，可以用它进行相等性测试</p></blockquote><blockquote><p>[!NOTE]</p><p>C 程序员用 <code>==</code> 进行字符串内容相等性检测，而是用<code>strcmp()</code> 函数，java 的 <code>compareTo</code>方法完全类似于它。</p></blockquote><h3 id="构建字符串">构建字符串</h3><p>每次字符串拼接时，都会构建一个新的 <code>String</code>对象，既耗时，又费空间</p><p><code>StringBuilder</code> 类（在 Java 5 引入）可以避免这个问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">StringBuilder builder=<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>builder.add(ch);<br>builder.add(str);<br>String completedString=builder.toString();<br></code></pre></td></tr></table></figure><h2 id="输入输出流">输入输出流</h2>]]></content>
    
    
    <categories>
      
      <category>计算机技术</category>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Technology</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高等数学 #2 Quadrics</title>
    <link href="/2024/10/10/%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6_2_%E4%BA%8C%E6%AC%A1%E6%9B%B2%E9%9D%A2/"/>
    <url>/2024/10/10/%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6_2_%E4%BA%8C%E6%AC%A1%E6%9B%B2%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="二次曲面">二次曲面</h1><p>对于 <span class="math inline">\(\mathbf{x} \in\mathbb{R}^3\)</span>，有二次曲面一般式：</p><p><span class="math display">\[{\displaystyle \langle A\mathbf {x} ,\mathbf {x} \rangle +\langle\mathbf {b} ,\mathbf {x} \rangle +c=0}\]</span></p><p>（1）椭圆锥面</p><p>（2）圆锥面 <span class="math display">\[x^2+y^2-z^2=0\]</span> （3）椭球面 <span class="math display">\[\frac{x^2}{a^2}+\frac{y^2}{b^2}+\frac{z^2}{c^2}=1\]</span></p><p>（4）球面 <span class="math display">\[x^2+y^2+z^2=R\]</span> （5）单叶双曲面 <span class="math display">\[x^2+y^2-z^2=1\]</span> （6）双叶双曲面 <span class="math display">\[x^2-y^2-z^2=1\]</span></p><p>（7）椭圆抛物面 <span class="math display">\[ax^2+by^2=z\]</span></p><p>（8）双曲抛物面（马鞍面） <span class="math display">\[x^2-y^2=z\]</span></p><h1 id="柱面">柱面</h1><h1 id="旋转曲面">旋转曲面</h1>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>高等数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高等数学 #3 Sequence</title>
    <link href="/2024/10/10/%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6_3_%E6%95%B0%E5%88%97/"/>
    <url>/2024/10/10/%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6_3_%E6%95%B0%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p>（1）收敛数列与其子列的关系 <span class="math display">\[\lim_{n\to\infty} a_n=b\Rightarrow \lim_{n\to \infty} a_{n_k}=b,\quadn,k=1,2,\cdots\]</span> 证明： <span class="math display">\[\lim_{n\to\infty}a_n=b\iff(\forall \epsilon\gt0)(\exists N\gt 0)(n\gtN\to |a_n-b|\lt\epsilon)\]</span> 设 <span class="math inline">\(K=N\)</span>，则当 <spanclass="math display">\[k\gt K\]</span> 时，即 <span class="math display">\[n_k\gt n_K=n_N\ge N\]</span> 则 <span class="math display">\[(\forall\epsilon \gt0)(\exists K\gt 0)(k\gtK\to|a_{n_k}-b|\lt\epsilon)\iff \lim_{k\to\infty}a_{n_k}=b\]</span></p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>高等数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Math</tag>
      
      <tag>Sequence</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高等数学 #4 Homogenous Function</title>
    <link href="/2024/10/10/%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6_4_%E9%BD%90%E6%AC%A1%E5%87%BD%E6%95%B0/"/>
    <url>/2024/10/10/%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6_4_%E9%BD%90%E6%AC%A1%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="homogenous-function">Homogenous Function</h1><p><span class="math inline">\(f:V\to W,\quad V,W\subset\mathrm{F}\)</span> 如果有</p><p><span class="math inline">\(f(kv)=k^nf(v)\)</span></p><h1 id="欧拉定理">欧拉定理</h1><p><span class="math inline">\(\text{Euler&#39;s Theorem}\)</span></p><p>若 <span class="math inline">\(k\)</span> 次齐次函数 <spanclass="math inline">\(f:\mathbb{R}^n \to \mathbb{R}\)</span> 是可导的。<span class="math display">\[\mathbf{x}\cdot\nabla f(\mathbf{x})=kf(\mathbf{x})\]</span></p><p>证明：</p><p>下面等式两边对 <span class="math inline">\(\alpha\)</span> 求导 <spanclass="math display">\[f(\alpha\mathbf{x})=\alpha^k f(\mathbf{x})\]</span> 则 <span class="math display">\[\frac{\partial f(\alpha\mathbf{x})}{\partial x_1}\frac{\mathrm{d}\alphax_1}{\mathrm{d}\alpha}+\cdots+\frac{\partialf(\alpha\mathbf{x})}{\partial x_n}\frac{\mathrm{d}\alphax_n}{\mathrm{d}\alpha}=k\alpha^{k-1}f(\mathbf{x})\\x_1\frac{\partial f(\alpha\mathbf{x})}{\partialx_1}+\cdots+x_n\frac{\partial f(\alpha\mathbf{x})}{\partialx_n}=k\alpha^{k-1}f(\mathbf{x})\]</span> 令 <span class="math inline">\(\alpha=1\)</span>，则 <spanclass="math display">\[\mathbf{x}\cdot\nabla f(\mathbf{x})=kf(\mathbf{x})\]</span></p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>高等数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Shell 笔记</title>
    <link href="/2024/07/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Shell/"/>
    <url>/2024/07/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Shell/</url>
    
    <content type="html"><![CDATA[<h1 id="shell-历史">Shell 历史</h1><ol type="1"><li><p>Ken Tompson Shell</p><p><code>sh</code>是第一个 Unix Shell</p></li><li><p>Bourne Shell</p></li><li><p>Bourne Again Shell</p><blockquote><p>/bin/bash</p></blockquote></li><li><p>C Shell</p><p>是一种比 Bourne Shell更适合的变种 Shell，它的语法与 C语言很相似。</p><blockquote><p>/usr/bin/csh</p></blockquote></li><li><p>Korn Shell</p><p>集合了 C Shell 和 Bourne Shell 的优点并且和 Bourne Shell完全兼容。</p><blockquote><p>/usr/bin/ksh</p></blockquote></li></ol><h1 id="变量">变量</h1><h2 id="定义">定义</h2><p>变量名和等号之间不能有空格</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">your_name=<span class="hljs-string">&quot;Louis&quot;</span><br></code></pre></td></tr></table></figure><p>除了显式地直接赋值，还可以用语句给变量赋值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> $(<span class="hljs-string">&#x27;ls /etc&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="使用变量">使用变量</h2><p>使用一个定义过的变量，只要在变量名前面加美元符号，花括号是可选的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;your_name&#125;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$your_name</span><br></code></pre></td></tr></table></figure><h2 id="只读变量">只读变量</h2><p>使用 readonly命令可以将变量定义为只读变量，只读变量的值不能被改变。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">myUrl=<span class="hljs-string">&quot;test&quot;</span><br><span class="hljs-built_in">readonly</span> myUrl<br></code></pre></td></tr></table></figure><h2 id="删除变量">删除变量</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">unset</span> variable_name<br></code></pre></td></tr></table></figure><h2 id="类型">类型</h2><ol type="1"><li><p>字符串</p><ul><li>单引号字符串，只会输出字符串内的原内容，单引号里面的单引号可以拼接字符窜</li><li>双引号字符串</li></ul></li><li><p>整数</p><p>使用 <strong>declare</strong> 或 <strong>typeset</strong>命令来声明整数变量。</p><p>如果尝试将非整数值赋给它，Shell会尝试将其转换为整数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">declare</span> -i myint=1<br></code></pre></td></tr></table></figure></li><li><p>数组</p><ul><li><p>整数索引数组</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">my_array=(1 2 3 4 5)<br></code></pre></td></tr></table></figure></li><li><p>关联数组</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">declare</span> -A associative_array<br>associative_array[<span class="hljs-string">&quot;name&quot;</span>]=<span class="hljs-string">&quot;John&quot;</span><br>associative_array[<span class="hljs-string">&quot;age&quot;</span>]=30<br></code></pre></td></tr></table></figure></li></ul></li><li><p>环境变量</p></li><li><p>特殊变量</p><ul><li><code>$0</code> ：脚本名称</li><li><code>$1,$2...</code>：脚本参数</li><li><code>$#</code>：脚本参数数量</li><li><code>$?</code>：上一条命令退出状态</li></ul></li></ol><h2 id="字符串">字符串</h2><h3 id="字符串长度">字符串长度</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;#my_str&#125;</span><br></code></pre></td></tr></table></figure><h3 id="提取字符串">提取字符串</h3><p>输出从 1 开始的 4 个字符</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;my_str:1:4&#125;</span><br></code></pre></td></tr></table></figure><h1 id="比较命令">比较命令</h1><h2 id="test">test</h2><p>$[...] 用于数值计算</p><ol type="1"><li>比较整数<ul><li>-eq</li><li>-ne</li><li>-gt</li><li>-lt</li></ul></li><li>比较字符串</li><li>比较文件<ul><li>-e：文件是否存在</li><li>-f：文件是否存在且为普通文件</li><li>-d：文件是否存在且为目录</li></ul></li></ol><h2 id="section">[</h2><p>与test 命令相似</p>]]></content>
    
    
    <categories>
      
      <category>计算机技术</category>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Technology</tag>
      
      <tag>Shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Verilog 笔记</title>
    <link href="/2024/07/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Verilog/"/>
    <url>/2024/07/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Verilog/</url>
    
    <content type="html"><![CDATA[<h1 id="特性">特性</h1><h2 id="三种建模方式">三种建模方式</h2><ol type="1"><li>行为级描述——使用过程化结构描述</li><li>数据流描述——使用连续赋值语句建模</li><li>结构化方式——使用门和模块例化语句描述</li></ol><h2 id="两类数据类型">两类数据类型</h2><pre><code class=" mermaid">mindmap))数据类型(((wire)(reg)[integer][real][time][paramater]</code></pre><ol type="1"><li><p>线网（wire）——物理元件之间的连线</p></li><li><p>寄存器（reg）——数据存储元件</p><ul><li><p>integer</p><blockquote><p>声明时不用指明位宽，位宽和编译器有关，一般为32 bit。reg型变量为无符号数，而 integer 型变量为有符号数。</p></blockquote></li><li><p>real</p><blockquote><p>实数用关键字 real来声明，可用十进制或科学计数法来表示。实数声明不能带有范围，默认值为0。如果将一个实数赋值给一个整数，则只有实数的整数部分会赋值给整数。</p></blockquote></li><li><p>time</p><blockquote><p>Verilog 使用特殊的时间寄存器 time型变量，对仿真时间进行保存。其宽度一般为 64 bit，通过调用系统函数 $time获取当前仿真时间。</p></blockquote></li><li><p>paramater</p><blockquote><p>常用于定义常数</p></blockquote></li><li><p>数组</p></li><li><p>存储器</p></li><li><p>字符串</p></li></ul></li></ol><p>Verilog 支持可变的向量域选择</p><p><strong>Verillog 还支持指定 bit位后固定位宽的向量域选择访问。</strong></p><ul><li><strong>[bit+: width]</strong> : 从起始 bit 位开始递增，位宽为width。</li><li><strong>[bit-: width]</strong> : 从起始 bit 位开始递减，位宽为width。</li></ul><h1 id="连续赋值">连续赋值</h1><p>连续赋值语句是 Verilog 数据流建模的基本语句，用于对 wire型变量进行赋值。：</p><p>格式如下</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">assign     LHS_target <span class="hljs-operator">=</span> RHS_expression  ；<br></code></pre></td></tr></table></figure><p>LHS（left hand side） 指赋值操作的左侧，RHS（right handside）指赋值操作的右侧。</p><p>assign 为关键词，任何已经声明 wire 变量的连续赋值语句都是以 assign开头，例如：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">wire      Cout, A, <span class="hljs-keyword">B </span>;<br>assign    Cout  = A &amp; <span class="hljs-keyword">B </span><span class="hljs-comment">;     //实现计算A与B的功能</span><br></code></pre></td></tr></table></figure><p>需要说明的是：</p><ul><li>LHS_target 必须是一个标量或者线型向量，而不能是寄存器类型。</li><li>RHS_expression的类型没有要求，可以是标量或线型或存器向量，也可以是函数调用。</li><li>只要 RHS_expression表达式的操作数有事件发生（值的变化）时，RHS_expression就会立刻重新计算，同时赋值给 LHS_target。</li></ul><p>Verilog 还提供了另一种对 wire 型赋值的简单方法，即在 wire型变量声明的时候同时对其赋值。wire型变量只能被赋值一次，因此该种连续赋值方式也只能有一次。例如下面赋值方式和上面的赋值例子的赋值方式，效果都是一致的。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">wire</span>      A, <span class="hljs-keyword">B</span> <span class="hljs-comment">;</span><br><span class="hljs-symbol">wire</span>      Cout = A &amp; <span class="hljs-keyword">B</span> <span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h1 id="时延">时延</h1><p>连续赋值时延一般可分为普通赋值时延、隐式时延、声明时延。</p><pre><code class=" mermaid">mindmap))时延(([普通时延][隐式时延][声明时延]</code></pre><p>下面 3 个例子实现的功能是等效的，分别对应 3种不同连续赋值时延的写法。</p><p>（1）普通时延，A&amp;B计算结果延时10个时间单位赋值给Z<strong>wire</strong> Z, A, B ; <strong>assign</strong> #10 Z = A &amp;B ;</p><p>（2）隐式时延，声明一个wire型变量时对其进行包含一定时延的连续赋值。<strong>wire</strong> A, B; <strong>wire</strong> #10 Z = A &amp; B;</p><p>（3）声明时延，声明一个wire型变量是指定一个时延。因此对该变量所有的连续赋值都会被推迟到指定的时间。除非门级建模中，一般不推荐使用此类方法建模。<strong>wire</strong> A, B; <strong>wire</strong> #10 Z ;<strong>assign</strong> Z =A &amp; B</p><h2 id="惯性时延">惯性时延</h2><p>在上述例子中，A 或 B 任意一个变量发生变化，那么在 Z得到新的值之前，会有 10 个时间单位的时延。如果在这 10 个时间单位内，即在Z 获取新的值之前，A 或 B 任意一个值又发生了变化，那么计算 Z 的新值时会取A 或 B当前的新值。所以称之为惯性时延，即信号脉冲宽度小于时延时，对输出没有影响。</p><h1 id="过程结构">过程结构</h1><p>（1）initial 语句</p><p>initial 语句从 0 时刻开始执行，只执行一次，多个 initial块之间是相互独立的。</p><p>如果 initial 块内包含多个语句，需要使用关键字 begin 和 end组成一个块语句。</p><p>如果 initial 块内只要一条语句，关键字 begin 和 end可使用也可不使用。</p><p>initial 理论上来讲是不可综合的，多用于初始化、信号检测等。</p><p>（2）always 语句</p><p>与 initial 语句相反，always 语句是重复执行的。always 语句块从 0时刻开始执行其中的行为语句；当执行完最后一条语句后，便再次执行语句块中的第一条语句，如此循环反复。</p><p>由于循环执行的特点，always语句多用于仿真时钟的产生，信号行为的检测等。</p><h1 id="过程赋值">过程赋值</h1><p>过程性赋值是在 initial 或 always语句块里的赋值，赋值对象是寄存器、整数、实数等类型。</p><p>这些变量在被赋值后，其值将保持不变，直到重新被赋予新值。</p><p>连续性赋值总是处于激活状态，任何操作数的改变都会影响表达式的结果；过程赋值只有在语句执行的时候，才会起作用。这是连续性赋值与过程性赋值的区别。</p><p>Verilog 过程赋值包括 2 种语句：阻塞赋值与非阻塞赋值。</p>]]></content>
    
    
    <categories>
      
      <category>计算机技术</category>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Technology</tag>
      
      <tag>Verilog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编语言 #0 学习笔记</title>
    <link href="/2024/06/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96_0_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/06/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96_0_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="组成部分">组成部分</h1><ol type="1"><li><p>汇编指令</p><p>对应机器码，机器码助记符</p></li><li><p>伪指令</p><p>无机器码，由编译器执行</p></li><li><p>其他符号</p><p>如 +、-、*、/，无机器码，由编译器识别</p></li></ol><h1 id="内存地址空间">内存地址空间</h1><table><thead><tr><th>地址</th><th>描述</th><th>大小</th></tr></thead><tbody><tr><td>00000-9FFFF</td><td>主存地址空间</td><td>640KB</td></tr><tr><td>A0000-BFFFF</td><td>显存地址空间</td><td>128KB</td></tr><tr><td>C0000-FFFFF</td><td>各类ROM空间</td><td>256KB</td></tr></tbody></table><p>总：2^20B=1MB</p><h1 id="寄存器">寄存器</h1><p>14个寄存器，寄存器16位</p><table><thead><tr><th>分类</th><th>寄存器</th><th>全称</th><th>描述</th></tr></thead><tbody><tr><td>主寄存器</td><td>AX</td><td>Accumulator</td><td>累加器</td></tr><tr><td></td><td>BX</td><td>Base</td><td>基址</td></tr><tr><td></td><td>CX</td><td>Count</td><td>计数</td></tr><tr><td></td><td>DX</td><td>Data</td><td>数据</td></tr><tr><td>变址寄存器</td><td>SI</td><td>Source Index</td><td>源变址</td></tr><tr><td></td><td>DI</td><td>Destination Index</td><td>目的变址</td></tr><tr><td></td><td>SP</td><td>Stack Pointer</td><td>堆栈指针</td></tr><tr><td></td><td>BP</td><td>Base Pointer</td><td>基址指针</td></tr><tr><td>程序计数器</td><td>IP</td><td>Instruction Pointer</td><td>指令指针</td></tr><tr><td>段寄存器</td><td>CS</td><td>Code Segment</td><td>代码段</td></tr><tr><td></td><td>SS</td><td>Stack Segment</td><td>堆栈段</td></tr><tr><td></td><td>DS</td><td>Data Segment</td><td>数据段</td></tr><tr><td></td><td>ES</td><td>Extra Segment</td><td>附加段</td></tr><tr><td>状态寄存器</td><td>PSW</td><td></td><td>标志</td></tr></tbody></table><h1 id="标志寄存器">标志寄存器</h1><p>也叫 PSW 程序状态字</p><table><thead><tr><th>寄存器</th><th>描述</th><th>1标志</th><th>0标志</th><th>位序</th></tr></thead><tbody><tr><td>CF</td><td>进位标志（无符号数运算）</td><td>CY</td><td>NC</td><td>0</td></tr><tr><td>PF</td><td>奇偶标志</td><td>PE</td><td>PO</td><td>2</td></tr><tr><td>AF</td><td>辅助标志</td><td>AC</td><td>NA</td><td>4</td></tr><tr><td>ZF</td><td>零标志</td><td>ZR</td><td>NZ</td><td>6</td></tr><tr><td>SF</td><td>符号标志（有符号数运算）</td><td>NG</td><td>PL</td><td>7</td></tr><tr><td>TF</td><td>跟踪标志</td><td>单步中断</td><td>关</td><td>8</td></tr><tr><td>IF</td><td>中断标志</td><td>EI，可中断</td><td>NI，屏蔽中断</td><td>9</td></tr><tr><td>DF</td><td>方向标志</td><td>DN</td><td>UP</td><td>10</td></tr><tr><td>OF</td><td>溢出标志（有符号数运算）</td><td>OV</td><td>NV</td><td>11</td></tr></tbody></table><h1 id="给出物理地址的方法">给出物理地址的方法</h1><p>问题：8060PC机，字长16位，CPU一次性能处理的数据最宽16位，寄存器只有16位，但地址线有20位</p><p>解决方法：物理地址=段地址x16+偏移地址</p><h1 id="加电启动和复位">加电启动和复位</h1><p>8086 CPU 加电启动或复位后，CS=FFFFH，IP=0000H</p><p>所以 8086 CPU 第一条指令是 FFFF0H</p><h1 id="mov-指令">MOV 指令</h1><p>可完成以下9种操作</p><table><thead><tr><th>目的</th><th>源</th></tr></thead><tbody><tr><td>通用寄存器</td><td>通用寄存器</td></tr><tr><td></td><td>段寄存器</td></tr><tr><td></td><td>内存</td></tr><tr><td></td><td>立即数</td></tr><tr><td>段寄存器</td><td>通用寄存器</td></tr><tr><td></td><td>内存</td></tr><tr><td>内存</td><td>通用寄存器</td></tr><tr><td></td><td>段寄存器</td></tr><tr><td></td><td>立即数</td></tr></tbody></table><h1 id="修改-csip">修改 CS:IP</h1><p>8086 CPU 无法通过 <strong>传送指令</strong> 修改 CS:IP</p><p>可以通过 <strong>转移指令</strong> 修改</p><h1 id="dx-与-address">DX 与 [address]</h1><p>8086 CPU 不支持将数据直接传送入段寄存器，必须用寄存器中转。</p><h1 id="栈机制">栈机制</h1><p>8086 CPU 提供 push 和 pop 指令，实际上为内存传送指令</p><table><thead><tr><th>指令</th><th>操作对象</th></tr></thead><tbody><tr><td>push</td><td>寄存器|内存单元</td></tr><tr><td>pop</td><td>寄存器|内存单元</td></tr></tbody></table><p>提供 SS 和 SP 寄存器作为，栈段和栈指针。</p><p>push ax 实现过程：</p><ol type="1"><li>SP=SP-2，SS:SP指向当前栈顶元素的前一个元素，以当前栈顶前面的单元作为新栈顶</li><li>将 ax 的内容送入 SS:SP 指向的内存单元处，SS:SP 此时指向新栈顶</li></ol><p>栈顶超界问题：8086 CPU未提供栈上下界寄存器，只记录栈顶，栈空间大小由我们自己管理。</p><h1 id="汇编器对指令中-idata-解析">汇编器对指令中 [idata] 解析</h1><p>在汇编源程序中，如果指令中出现 [idata]必须显示指出段寄存器（段前缀），才能表示内存单元，否则会被解析为立即数</p><p>如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov ax,[idata]<br></code></pre></td></tr></table></figure><p>等同于</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov ax,idata<br></code></pre></td></tr></table></figure><p>显示指出段寄存器，表示内存单元</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov ax,ds:[idata]<br></code></pre></td></tr></table></figure><p>[bx] 不用显示指出段寄存器，表示内存单元</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov ax,[bx]<br></code></pre></td></tr></table></figure><p>而在Debug 中，指令中 [idata] 会被解析成内存单元</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov ax,[idata]<br></code></pre></td></tr></table></figure><h1 id="一段安全的空间">一段安全的空间</h1><p><code>0:200~0:2ff</code>这段空间一般不会被系统和其他合法程序的使用</p><h1 id="源程序中的标号处理">源程序中的标号处理</h1><pre><code class=" mermaid">mindmap))标号((  段标号  数据段标号  代码段标号</code></pre><p>（1）mov指令对标号（无论是数据标号，还是代码段标号）的直接引用的含义是，取标号表示的内存单元的值，而不是标号代表的偏移地址值</p><p>下面两条指令等同，段地址默认为 数据标号（变量）所对应的数据段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov ax,var1<br>mov ax,[var1]<br></code></pre></td></tr></table></figure><p>通过 offset 和 seg 能分别取到标号的 偏移地址和段地址。</p><p>（2）mov 指令对段标号的直接引用的含义是，取段标号所代表的段地址</p><p>（3）转移指令对代码段标号的直接引用的含义是，取代码段标号表示的偏移地址</p><h1 id="灵活的定位内存地址方法">灵活的定位内存地址方法</h1><h2 id="bxidata">1. [bx+idata]</h2><p>也可以写成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov ax,idata[bx]<br></code></pre></td></tr></table></figure><h2 id="si-和-di">2. SI 和 DI</h2><p>SI 和 DI 是 8086 CPU 中，功能与 bx 差不多的寄存器，但 SI 和 DI不能拆分为两个8位的寄存器使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov ax,[di+idata]<br>mov ax,idata[si]<br>mov ax,[bx+idata]<br></code></pre></td></tr></table></figure><h2 id="bxsi-和-bxdi">3. [bx+si] 和 [bx+di]</h2><p>[bx+si] 与 [bx+di] 功能类似</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov ax,[bx+si]<br></code></pre></td></tr></table></figure><p>可以写成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov ax,[bx][si]<br></code></pre></td></tr></table></figure><h2 id="bxsiidata-和-bxdiidata">4. [bx+si+idata] 和 [bx+di+idata]</h2><p>[bx+si+idata] 与 [bx+di+idata] 功能类似</p><p>下例代码每句功能相同</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov ax, [bx+si+200]<br>mov ax,[200+bx+si]<br>mov ax,200[bx][si]<br>mov ax,[bx].200[si]<br>mov ax,[bx][si].200<br></code></pre></td></tr></table></figure><h2 id="bp">5. BP</h2><p>只要在 [...] 使用<strong>BP</strong>，若段地址没有显示给出，默认段地址都在<strong>SS</strong> 中</p><h1 id="寻址方式">寻址方式</h1><h2 id="面向操作数的">面向操作数的</h2><h3 id="立即数寻址">立即数寻址</h3><h2 id="面向寄存器寻址">面向寄存器寻址</h2><h3 id="寄存器寻址">寄存器寻址</h3><p>操作数在某个寄存器中</p><h2 id="面向内存的寻址">面向内存的寻址</h2><h3 id="直接寻址">1. 直接寻址</h3><table><thead><tr><th>寻址方式</th><th>含义</th><th></th></tr></thead><tbody><tr><td>[idata]</td><td>EA=idata，SA=[ds]</td><td></td></tr></tbody></table><h3 id="寄存器间接寻址">2. 寄存器间接寻址</h3><table><thead><tr><th>寻执方式</th><th>含义</th></tr></thead><tbody><tr><td>[bx]</td><td>EA=[bx]，SA=[ds]</td></tr><tr><td>[si]</td><td>EA=[si]，SA=[ds]</td></tr><tr><td>[di]</td><td>EA=[di]，SA=[ds]</td></tr><tr><td>[bp]</td><td>EA=[bp]，SA=[ds]</td></tr></tbody></table><h3 id="寄存器相对寻址基址寻址间址寻址">3.寄存器相对寻址（基址寻址、间址寻址）</h3><table><thead><tr><th>寻执方式</th><th>含义</th></tr></thead><tbody><tr><td>[bx+idata]</td><td>EA=[bx]+idata，SA=[ds]</td></tr><tr><td>[si+idata]</td><td>EA=[si]+idata，SA=[ds]</td></tr><tr><td>[di+idata]</td><td>EA=[di]+idata，SA=[ds]</td></tr><tr><td>[bp+idata]</td><td>EA=[bp]+idata，SA=[ds]</td></tr></tbody></table><h3 id="基址变址寻址">4. 基址变址寻址</h3><table><thead><tr><th>寻执方式</th><th>含义</th></tr></thead><tbody><tr><td>[bx+si]</td><td>EA=[bx]+[si]，SA=[ds]</td></tr><tr><td>[bx+di]</td><td>EA=[bx]+[di]，SA=[ds]</td></tr><tr><td>[bp+si]</td><td>EA=[bp]+[si]，SA=[ds]</td></tr><tr><td>[bp+di]</td><td>EA=[bp]+[di]，SA=[ds]</td></tr></tbody></table><h3 id="相对基址变址寻址">5. 相对基址变址寻址</h3><table><thead><tr><th>寻执方式</th><th>含义</th></tr></thead><tbody><tr><td>[bx+si+idata]</td><td>EA=[bx]+[si]+idata，SA=[ds]</td></tr><tr><td>[bx+di+idata]</td><td>EA=[bx]+[di]+idata，SA=[ds]</td></tr><tr><td>[bp+si+idata]</td><td>EA=[bp]+[si]+idata，SA=[ds]</td></tr><tr><td>[bp+di+idata]</td><td>EA=[bp]+[di]+idata，SA=[ds]</td></tr></tbody></table><h1 id="指令处理的数据有多长">指令处理的数据有多长</h1><h2 id="寄存器指明">1. 寄存器指明</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov ax,bx<br></code></pre></td></tr></table></figure><h2 id="x-ptr-指明">2. X ptr 指明</h2><p>（1）word 指明操作数是字类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov word ptr [bx],[si]<br></code></pre></td></tr></table></figure><p>（2）byte 指明操作数是字节类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov byte ptr [bx],[si]<br></code></pre></td></tr></table></figure><h2 id="其他指明">3. 其他指明</h2><p>push 指令只进行字操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">push [bx]<br></code></pre></td></tr></table></figure><h1 id="算术运算">算术运算</h1><h2 id="除法">除法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">div [reg|mem]<br></code></pre></td></tr></table></figure><p>支持 8位、16位除法</p><ul><li>除数：8位或16位，在一个 reg 或内存单元中</li><li>被除数：若除数 8位，则被除数 16 位，默认存放在 AX中；若除数为 16位，则被除数 32位，AX 存低位，DX 存高位</li><li>结果：若除数为 8位，AL 存结果，AH 存余数；除数为 16位，AX 存结果，DX存余数。</li></ul><table><thead><tr><th>除数</th><th>被除数</th><th>结果</th><th>余数</th></tr></thead><tbody><tr><td>8位</td><td>AX</td><td>AL</td><td>AH</td></tr><tr><td>16位</td><td>低位AX，高位DX</td><td>AX</td><td>DX</td></tr></tbody></table><h2 id="乘法">乘法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mul [reg|内存单元]<br></code></pre></td></tr></table></figure><table style="width:100%;"><thead><tr><th>乘数位数</th><th>乘数位置</th><th>结果</th></tr></thead><tbody><tr><td>8 位</td><td>一个默认在 AL，另一个可以在 8位 reg，或者内存中</td><td>AX</td></tr><tr><td>16 位</td><td>一个默认在 AX，另一个可以在 16位 reg，或者内存中</td><td>低位 AX，高位 DX</td></tr></tbody></table><h1 id="转移指令原理">转移指令原理</h1><h2 id="分类">分类</h2><h3 id="根据转移行为不同">1、根据转移行为不同</h3><ul><li>段内转移：只修改 IP，如 <code>jmp ax</code></li><li>段间转移：同时修改 CS:IP，如<code>jmp 1000:0</code></li></ul><h3 id="根据指令对-ip-修改范围不同">2、根据指令对 IP 修改范围不同</h3><ul><li>短转移：IP 修改范围为 -128～127</li><li>近转移：IP 修改范围为 -32768～32767</li></ul><h3 id="cpu-转移指令">3、80806 CPU 转移指令</h3><ul><li><p>无条件转移指令（jmp）</p></li><li><p>条件转移指令</p><blockquote><p>所有条件转移指令，都是短转移</p></blockquote></li><li><p>循环指令（loop）</p><blockquote><p>所有的循环指令，都是短转移</p></blockquote></li><li><p>过程</p></li><li><p>中断</p></li></ul><h2 id="操作符-offset">操作符 offset</h2><p>由编译器处理</p><p>功能：取得标号处的偏移地址</p><h2 id="依据位移进行转移的-jmp-指令">依据位移进行转移的 jmp 指令</h2><h3 id="jmp-short-标号">jmp short [标号]</h3><p>实现功能：(IP)=(IP)+8位位移</p><p>汇编器在进行汇编时，根据汇编中的标号计算出来，并用补码表示</p><h3 id="jmp-neart-ptr-标号">jmp neart ptr [标号]</h3><p>实现段内近转移</p><p>实现功能：(IP)=(IP)+16位位移</p><h2 id="转移目的地址在指令中的-jmp-指令">转移目的地址在指令中的 jmp指令</h2><p>段间转移，又称远转移：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">jmp far ptr 标号<br></code></pre></td></tr></table></figure><h2 id="转移地址在寄存器中的-jmp-指令">转移地址在寄存器中的 jmp指令</h2><p>用某一合法寄存器的值修改 IP 的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">jmp reg<br></code></pre></td></tr></table></figure><h2 id="转移地址在内存中的-jmp-指令">转移地址在内存中的 jmp 指令</h2><p>段内转移：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">jmp word ptr [内存单元]<br></code></pre></td></tr></table></figure><p>段间转移：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">jmp dword ptr [内存单元]<br></code></pre></td></tr></table></figure><h2 id="jcxz-指令">jcxz 指令</h2><p>所有条件转移，都是短转移</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">jcxz [标号]<br></code></pre></td></tr></table></figure><p>当 CX=0时，跳转到标号处，位移由编译器在编译时算出，并由补码表示。</p><h1 id="call-和-ret">CALL 和 RET</h1><h2 id="ret">ret</h2><p>功能：近转移返回</p><p>相当于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">POP IP<br></code></pre></td></tr></table></figure><h2 id="retf">retf</h2><p>功能：远转移返回</p><p>相当于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">POP IP<br>POP CS<br></code></pre></td></tr></table></figure><h2 id="依据位移进行转移的-call-指令">依据位移进行转移的 call 指令</h2><p>call指令不实现短转移，下面指令为近转移：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">call 标号<br></code></pre></td></tr></table></figure><h2 id="转移地址在指令中的-call-指令">转移地址在指令中的 call 指令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">call far ptr 标号<br></code></pre></td></tr></table></figure><h2 id="转移地址在寄存器中的-call-指令">转移地址在寄存器中的 call指令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">call reg<br></code></pre></td></tr></table></figure><h2 id="转移地址在内存中的-call指令">转移地址在内存中的 call指令</h2><h3 id="近转移">近转移</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">call word ptr [内存地址单元]<br></code></pre></td></tr></table></figure><h3 id="远转移">远转移</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">call dword ptr [内存地址单元]<br></code></pre></td></tr></table></figure><h1 id="pc-机键盘处理过程">PC 机键盘处理过程</h1><h2 id="端口">端口</h2><p>相关端口：60h</p><h2 id="扫描码">扫描码</h2><p>通码第7位为0，断码第7位为1，所以：</p><p>断码=通码+80h</p><h2 id="号中断例程">9号中断例程</h2><p>9号中断例程是由BIOS提供，功能是将端口传来的扫描码，判断对应的 ascii码，一起存入 BIOS 键盘缓冲区</p><p>内存中设置有BIOS键盘缓冲区，可以存储15个键盘输入，低位字节：字符码，高位字节：扫描码</p><p>内存单元 0040:17 存储键盘状态信息</p><table><thead><tr><th>位</th><th>状态</th></tr></thead><tbody><tr><td>0</td><td>右Shift</td></tr><tr><td>1</td><td>左Shift</td></tr><tr><td>2</td><td>Ctrl</td></tr><tr><td>3</td><td>Alt</td></tr><tr><td>4</td><td>ScrollLock</td></tr><tr><td>5</td><td>NumLock</td></tr><tr><td>6</td><td>CapsLock</td></tr><tr><td>7</td><td>Insert</td></tr></tbody></table><h2 id="h中断例程">16h中断例程</h2><h3 id="号子程序">0号子程序</h3><p>功能：从BIOS键盘缓冲区读出一个字符，并将其从缓冲区删除。如果缓冲区没有数据，则继续循环检测。</p><p>结果：</p><ol type="1"><li>ah：扫描码</li><li>al：ASCII 码</li></ol><h1 id="端口读写">端口读写</h1><p>8086 CPU 可寻址 65536 个端口</p><p>只能用 al 存8位数据，ax 存16位数据</p><p>访问 256-65535 端口，用 dx 寄存器存端口号</p><p>读：从 71h 端口读数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">in al,71h<br></code></pre></td></tr></table></figure><p>写：向 71h 端口写数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">out 71h,al<br></code></pre></td></tr></table></figure><h1 id="显示缓冲区">显示缓冲区</h1><p>内存地址 <code>B8000H-BFFFFH</code> 的<code>32KB</code>空间为 8086CPU80X25 彩色字符模式的显示缓冲区</p><p>共8页，每页2000个字符，4000B</p><p>每个字符，低字节为显示字符的<code>ASCII 码</code>，高字节为字符的<code>颜色属性</code></p><p>颜色属性：</p><table><thead><tr><th>位数</th><th>描述</th></tr></thead><tbody><tr><td>7</td><td>闪烁位</td></tr><tr><td>6</td><td>背景R</td></tr><tr><td>5</td><td>背景G</td></tr><tr><td>4</td><td>背景B</td></tr><tr><td>3</td><td>高亮</td></tr><tr><td>2</td><td>前景R</td></tr><tr><td>1</td><td>前景G</td></tr><tr><td>0</td><td>前景B</td></tr></tbody></table><h1 id="中断机制">中断机制</h1><h2 id="中断向量表">中断向量表</h2><p>8086 CPU 默认</p><p>0000:000-0000:03FF 存放中断向量表，高地址字存放<code>段地址</code>，低地址字存放 <code>偏移地址</code></p><p>实际上 0000:0200-0000:02FF 为空</p><p>除法溢出中断是0号</p><h2 id="中断过程">中断过程</h2><p>当产生中断信号时，硬件执行一系列过程，最后将 CS:IP指向中断处理程序。这个过程叫中断过程</p><ol type="1"><li>从中断信息获取中断类型码---n</li><li>PSW 入栈</li><li>TF、IF 置0</li><li>CS 入栈</li><li>IP 入栈</li><li>IP=(n*4)，CS=(n*4+2)</li></ol><p>这个过程由硬件完成，程序员不可改变</p><h2 id="bios-中断例程">BIOS 中断例程</h2><h3 id="int-10h">int 10h</h3><h4 id="号子程序-1">2号子程序</h4><p>功能：设置光标</p><p>参数：</p><ol type="1"><li>bh：页号</li><li>dh：行号</li><li>dl：列号</li></ol><h4 id="号子程序-2">9号子程序</h4><p>功能：在光标处设置字符</p><p>参数：</p><ol type="1"><li>al：传入的字符</li><li>bl：颜色属性</li><li>bh：页号</li><li>cx：字符重复个数</li></ol><h3 id="int-13h">int 13h</h3><h2 id="dos-中断例程">DOS 中断例程</h2><h3 id="int-21h">int 21h</h3><h4 id="c号子程序">4c号子程序</h4><p>功能：返回dos</p><p>参数：</p><ol type="1"><li>al：返回值</li></ol><h4 id="号子程序-3">9号子程序</h4><p>功能：在光标处显示字符串</p><p>参数</p><ol type="1"><li>ds:dx：指向要显示的字符串</li></ol><h4 id="ah">0AH</h4><h2 id="内中断">内中断</h2><h2 id="外中断">外中断</h2><h3 id="可屏蔽中断">1. 可屏蔽中断</h3><h3 id="不可屏蔽中断">2. 不可屏蔽中断</h3><h1 id="参数传递">参数传递</h1><h2 id="寄存器冲突">寄存器冲突</h2><p>由于无法知道子程序所用寄存器，是否在别的地方被使用</p><p>应当在进入子程序后，将所用寄存器压栈保存，离开前，弹栈恢复</p><p>例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs assembly">proc:<br>push bx<br><br>mov bx,3<br>inc bx<br><br>pop bx<br>ret<br></code></pre></td></tr></table></figure><h2 id="首地址传参批量传参">首地址传参（批量传参）</h2><h2 id="用栈传参">用栈传参</h2><p>将需要传递的数据，在调用子程序之前，压栈，然后获取栈针<code>bp=sp</code>进行访问。</p><p>进入子程序之后，当前栈顶为 IP，后面依次为传递的参数数据</p><p>离开子程序后，使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">ret X<br></code></pre></td></tr></table></figure><p>弹栈删除</p><p>例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;实现 (a-b)*3<br>;ret 4 表示 (1)pop ip(2)add sp,4<br>difcube:<br>push bp<br>mov bp,sp<br>mov ax,[bp+4]<br>sub ax,[bp+6]<br>mov bp,ax<br>mul bp<br>mul bp<br>pop bp<br>ret 4<br></code></pre></td></tr></table></figure><h1 id="指令目录">指令目录</h1><h2 id="算术运算-1">算术运算</h2><table><thead><tr><th>指令</th><th>含义</th><th>功能</th><th>DST</th></tr></thead><tbody><tr><td>add</td><td>加法</td><td>(DST)=(DST)+(SRC)</td><td>内存|寄存器</td></tr><tr><td>adc</td><td>进位加法</td><td>(DST)=(DST)+(SRC)+CF</td><td>内存|寄存器</td></tr><tr><td>inc</td><td>+1</td><td>(DST)=(DST)+1</td><td>内存|寄存器</td></tr><tr><td>sub</td><td>减法</td><td>(DST)=(DST)-(SRC)</td><td></td></tr><tr><td>sbb</td><td>借位减法</td><td>(DST)=(DST)-(SRC)-1</td><td></td></tr><tr><td>dec</td><td>-1</td><td>(DST)=(DST)-1</td><td></td></tr><tr><td>neg</td><td>求反</td><td></td><td></td></tr><tr><td>cmp</td><td>比较，两数相减，只影响标志寄存器</td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table><h2 id="逻辑运算">逻辑运算</h2><h2 id="串指令">串指令</h2><table><thead><tr><th>指令</th><th>功能</th><th>描述</th></tr></thead><tbody><tr><td>movsb</td><td>((ES)*16+DI)=((DS)*16+SI)；IF DF=0，DI++，SI++，ELSE DI--，SI--</td><td>内存到内存的字节复制</td></tr><tr><td>movsw</td><td></td><td>内存到内存的字复制</td></tr><tr><td>rep</td><td>根据 CX，重复执行后面的串指令</td><td></td></tr><tr><td>cld</td><td>DF=0，UP</td><td></td></tr><tr><td>std</td><td>DF=1，DN</td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h2 id="程序转移指令">程序转移指令</h2><p>通常和 cmp 配合使用</p><table><thead><tr><th>分类</th><th>指令</th><th>含义</th><th>检测标志</th></tr></thead><tbody><tr><td>无符号数</td><td>JA</td><td>大于</td><td>CF=0 且 ZF=0</td></tr><tr><td></td><td>JNA，JBE</td><td>不大于，小于等于</td><td>CF=1 或 ZF=1</td></tr><tr><td></td><td>JB</td><td>低于</td><td>CF=1 且 ZF=0</td></tr><tr><td></td><td>JNB，JAE</td><td>不低于，大于等于</td><td>CF=0 或 ZF=1</td></tr><tr><td>有符号数</td><td>JG</td><td>大于</td><td></td></tr><tr><td></td><td>JNG，JLE</td><td>不大于，小于等于</td><td></td></tr><tr><td></td><td>JL</td><td>小于</td><td></td></tr><tr><td></td><td>JNL，JGE</td><td>不小于，大于等于</td><td></td></tr><tr><td>其他</td><td>JZ，JE</td><td>等于0</td><td>ZF=1</td></tr><tr><td></td><td>JNZ，JNE</td><td>不等于0</td><td>ZF=0</td></tr><tr><td></td><td>JC</td><td>有进位</td><td>CY</td></tr><tr><td></td><td>JNC</td><td>无进位</td><td>NC</td></tr><tr><td></td><td>JO</td><td>有溢出</td><td></td></tr><tr><td></td><td>JNO</td><td>无溢出</td><td></td></tr><tr><td></td><td>JP，JPE</td><td>为偶</td><td></td></tr><tr><td></td><td>JNP，JPO</td><td>为奇</td><td></td></tr></tbody></table><h1 id="中断汇总表">中断汇总表</h1><table><thead><tr><th>分类</th><th>中断例程</th><th>描述</th><th></th></tr></thead><tbody><tr><td>BIOS中断</td><td>10h</td><td>显示服务</td><td></td></tr><tr><td></td><td>13h</td><td>直接磁盘服务</td><td></td></tr><tr><td></td><td>14h</td><td>串行口服务</td><td></td></tr><tr><td></td><td>15h</td><td>杂项系统服务</td><td></td></tr><tr><td></td><td>16h</td><td>键盘服务</td><td></td></tr><tr><td></td><td>17h</td><td>并行口服务</td><td></td></tr><tr><td></td><td>1Ah</td><td>时钟服务</td><td></td></tr><tr><td>DOS中断</td><td>20h</td><td>终止程序运行</td><td></td></tr><tr><td></td><td>21h</td><td>DOS功能调用</td><td></td></tr><tr><td></td><td>22h</td><td>终止处理程序的地址</td><td></td></tr><tr><td></td><td>23h</td><td>Ctrl+C 处理程序</td><td></td></tr><tr><td></td><td>24h</td><td>致命错误处理程序</td><td></td></tr><tr><td></td><td>25h</td><td>读磁盘扇区</td><td></td></tr><tr><td></td><td>26h</td><td>写磁盘扇区</td><td></td></tr><tr><td></td><td>27h</td><td>终止，并驻留内存</td><td></td></tr><tr><td></td><td>28h</td><td>DOS空闲</td><td></td></tr><tr><td></td><td>2Fh</td><td>多重中断服务</td><td></td></tr><tr><td></td><td>33h</td><td>鼠标功能</td><td></td></tr></tbody></table><h2 id="int-10h-显示服务">int 10h 显示服务</h2><table><thead><tr><th>ah（功能号）</th><th>描述</th><th>参数</th></tr></thead><tbody><tr><td>00h</td><td>设置显示器模式</td><td></td></tr><tr><td>01h</td><td>设置光标形状</td><td></td></tr><tr><td>02h</td><td>设置光标位置</td><td></td></tr><tr><td>03h</td><td>读取光标位置</td><td></td></tr><tr><td>04h</td><td></td><td></td></tr><tr><td>05h</td><td>设置显示页</td><td></td></tr><tr><td>06h</td><td>初始化</td><td></td></tr><tr><td>07h</td><td>滚屏</td><td></td></tr><tr><td>08h</td><td>读取光标处的字符及其属性</td><td></td></tr><tr><td>09h</td><td>在光标处，按指定属性显示字符</td><td></td></tr><tr><td>0Ah</td><td>在当前光标处显示字符</td><td></td></tr><tr><td>0Bh</td><td>设置调色板、背景色、边框</td><td></td></tr><tr><td>0Ch</td><td>写图形像素</td><td></td></tr><tr><td>0Dh</td><td>读图形像素</td><td></td></tr><tr><td>0Eh</td><td></td><td></td></tr><tr><td>0Fh</td><td>读显示器模式</td><td></td></tr><tr><td>10h</td><td>颜色</td><td></td></tr><tr><td>11h</td><td>字体</td><td></td></tr><tr><td>12h</td><td>显示器的配置</td><td></td></tr></tbody></table><h1 id="debug">Debug</h1><table style="width:100%;"><thead><tr><th>指令</th><th>描述</th><th>格式</th></tr></thead><tbody><tr><td>R</td><td>查看、改变CPU寄存器的内容</td><td></td></tr><tr><td>D</td><td>查看内存 中的内容</td><td>-d 段地址 : 起始偏移地址 [末尾偏移地址]</td></tr><tr><td>E</td><td>改写内存中的内容</td><td></td></tr><tr><td>U</td><td>将内存中的机器指令编译成汇编指令</td><td></td></tr><tr><td>T</td><td>执行一条机器指令</td><td></td></tr><tr><td>A</td><td>以汇编指令的格式在内存中写入一条机器指令</td><td></td></tr><tr><td>Q</td><td>退出</td><td></td></tr></tbody></table><h1 id="nasm-vs-masm">NASM VS MASM</h1><p>Netwide Assembler，是一款开源且免费的汇编器，与MASM 都是 Intel汇编风格</p><p>（1）标号即汇编地址</p><p>在编译时，所有的标号都会被换为汇编地址，是一个立即数</p><p>如果要取得该地址处的值，必须是用 [tag]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov ax,tag立即数寻址<br>mov ax,[tag]直接寻址<br></code></pre></td></tr></table></figure><p>（2）不需要 seg，offset</p><p>因为标号即地址，立即数</p><p>（3）没有 dup ，取而代之的是 times</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">times 128 db 1定义128个字节1<br></code></pre></td></tr></table></figure><p>（4）多了一个伪指令 dq</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">dq 1定义一个4字变量<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机技术</category>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Technology</tag>
      
      <tag>ASM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue 笔记</title>
    <link href="/2024/05/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/Vue/Vue%20%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/05/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/Vue/Vue%20%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="一基础">一、基础</h1><h2 id="实例">1.实例</h2><h2 id="模板语法">2.模板语法</h2><h3 id="指令">指令</h3><p>指令，是带有<strong>v-</strong>前缀的特殊<strong>attribute</strong>。</p><h3 id="指令参数">指令参数</h3><p>在指令名后面以 <strong>：</strong>隔开做标识</p><p>：后面跟 <strong>[js表达式]</strong>可以做动态参数</p><h3 id="常用指令">常用指令</h3><h4 id="v-bind">v-bind</h4><p>如果要将组件数据绑定到<strong>DOM</strong>的<strong>Attribute</strong>上，可以使用<strong>v-bind:attribute</strong>指令,简写为<strong>:attribute</strong>。</p><p>这个指令是单向数据绑定。从model到view。</p><h4 id="v-model">v-model</h4><p>这个指令是双向数据绑定。<strong>model的改变影响view；view的改变也可以影响model</strong>。</p><h4 id="v-if">v-if</h4><p>如果指令值为<strong>false</strong>，则该标签不会被创建，被注释掉。</p><h4 id="v-show">v-show</h4><p>如果指令值为<strong>false</strong>，该标签会被创建，但是采用css样式的方式不显示。<code>display: none;</code>，对于频繁切换的，使用<strong>v-show</strong>性能更高。</p><h4 id="v-for">v-for</h4><p>Vue默认按照 <strong>就地更新</strong>的策略来更新用<code>v-for</code>来渲染的元素列表。</p><p>用过给定唯一的<code>key</code>属性，给每个元素一个唯一标识，从而重新排序现有的元素。</p><h1 id="二组件">二、组件</h1><h3 id="组件导出">1、组件导出</h3><h3 id="组件引入">2、组件引入</h3><h1 id="三差异">三、差异</h1><h4 id="vue2-vs-vue3">Vue2 VS Vue3</h4><ol type="1"><li>Vue2中多个组件必须放一个根组件下。</li><li>Vue3中有了<strong>createApp </strong>API。</li></ol><h1 id="组合式api">组合式API</h1><p>## ref</p><p><code>ref()</code> 接收参数，并将其包裹在一个带有 <code>.value</code>属性的 ref 对象中返回，Ref 会使它的值具有深层响应性</p><h2 id="reactive">reactive</h2><p><code>reactive()</code>，接受一个对象类型参数，返回该对象的一个代理对象<code>proxy</code>，通过<code>proxy</code>操作才具有响应性，对象属性结构为本地变量之后，失去响应性连接</p><h2 id="computed">computed</h2><h2 id="watch">watch</h2>]]></content>
    
    
    <categories>
      
      <category>计算机技术</category>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Technology</tag>
      
      <tag>Vue</tag>
      
      <tag>Js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Cloud</title>
    <link href="/2024/05/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/Spring/SpringCloud/"/>
    <url>/2024/05/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/Spring/SpringCloud/</url>
    
    <content type="html"><![CDATA[<h1 id="架构">架构</h1><h2 id="服务注册与发现">服务注册与发现</h2><ol type="1"><li>Eureka</li><li>Consul</li><li>Etcd</li><li>Nacos</li></ol><h2 id="服务调用与负载均衡">服务调用与负载均衡</h2><ol type="1"><li>Ribbon</li><li>OpenFeign</li><li>LoadBalancer</li></ol><h2 id="分布式事务">分布式事务</h2><ol type="1"><li>Seata</li><li>LCN</li><li>Hmily</li></ol><h2 id="服务熔断和降级">服务熔断和降级</h2><ol type="1"><li>Hystrix</li><li>Circuit Breaker<ul><li>Resilence4J</li><li>Spring Retry</li></ul></li><li>Sentinel</li></ol><h2 id="服务链路">服务链路</h2><ol type="1"><li>Sleuth+Zipkin</li><li>Micrometer Tracing</li></ol><h2 id="服务网关">服务网关</h2><ol type="1"><li>Zuul</li><li>Gate Way</li></ol><h2 id="分布式配置管理">分布式配置管理</h2><ol type="1"><li>Config+Bus</li><li>Consul</li><li>Nacos</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机技术</category>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Technology</tag>
      
      <tag>Spring</tag>
      
      <tag>SpringCloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker_APIs</title>
    <link href="/2024/05/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/Docker/Docker_%E5%BF%AB%E9%80%9F%E6%93%8D%E4%BD%9C/"/>
    <url>/2024/05/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/Docker/Docker_%E5%BF%AB%E9%80%9F%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="镜像操作">镜像操作</h1><h3 id="docker-pull-选项-地址-仓库名-tag">docker pull [选项] [地址]仓库名 [:tag]</h3><blockquote><p>拉取指定镜像</p></blockquote><ul><li><p>地址：<code>&lt;域名/IP&gt;[:端口号]</code>，默认<code>docker.io</code></p></li><li><p>仓库名：<code>&lt;用户名&gt;/&lt;软件名&gt;</code>，无用户名则为<code>library</code>是官方镜像源</p></li></ul><h3 id="docker-run--it---rm-镜像-命令">docker run -it --rm [镜像][命令]</h3><blockquote><p>交互式地根据镜像运行一个容器，终止运行后，删除容器</p></blockquote><ul><li><code>--rm</code>：容器退出后就删除</li><li><code>命令</code>：交互式输入的命令</li></ul><h3 id="docker-image-ls">docker image ls</h3><blockquote><p>列出所有镜像</p></blockquote><p>### docker image rm [选项] <镜像1> [<镜像2> ...]</p><blockquote><p>删除一个或多个镜像</p></blockquote><ul><li><code>&lt;镜像&gt;</code>：<code>镜像短 ID</code>|<code>镜像长 ID</code>|<code>镜像名</code> |<code>镜像摘要</code></li></ul><h3 id="docker-commit-选项">docker commit [选项] <容器ID或容器名>[<仓库名>[:<标签>]]</h3><blockquote><p>将容器的存储层保存下来成为镜像</p></blockquote><h3 id="docker-build-选项-上下文路径url-">docker build [选项]&lt;上下文路径/URL/-&gt;</h3><blockquote><p>根据指定路径下的 Dockerfile 文件，制作镜像</p></blockquote><h1 id="dockerfile">Dockerfile</h1><h3 id="from">FROM</h3><blockquote><p>指定基础镜像</p></blockquote><h3 id="run">RUN</h3><blockquote><p>用来执行命令行命令</p></blockquote><ul><li><em>shell</em> 格式：<code>RUN &lt;命令&gt;</code></li><li><em>exec</em>格式：<code>RUN ["可执行文件", "参数1", "参数2"]</code></li></ul><p>注：Dockerfile 中每一个指令都会建立一层，<code>RUN</code>也不例外。</p><h3 id="copy">COPY</h3><blockquote><p>将从构建上下文目录中 <code>&lt;源路径&gt;</code>的文件/目录复制到新的一层的镜像内的 <code>&lt;目标路径&gt;</code>位置。</p></blockquote><ul><li><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;源路径&gt;... &lt;目标路径&gt;</code></li><li><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] ["&lt;源路径1&gt;",... "&lt;目标路径&gt;"]</code></li></ul><h3 id="add">ADD</h3><blockquote><p>更高级的复制文件</p></blockquote><p><code>&lt;源路径&gt;</code> 可以是一个 URL，这种情况下，Docker引擎会试图去下载这个链接的文件放到 <code>&lt;目标路径&gt;</code>去。下载后的文件权限自动设置为 600</p><p>如果 <code>&lt;源路径&gt;</code> 为一个 <code>tar</code>压缩文件的话，压缩格式为 <code>gzip</code>, <code>bzip2</code> 以及<code>xz</code> 的情况下，<code>ADD</code>指令将会自动解压缩这个压缩文件到 <code>&lt;目标路径&gt;</code> 去。</p><h1 id="容器操作">容器操作</h1><h3 id="docker-container-stop">docker container stop</h3><blockquote><p>终止一个容器</p></blockquote><h3 id="docker-container-start">docker container start</h3><blockquote><p>启动一个处于终止状态的容器</p></blockquote><h3 id="docker-container-ls">docker container ls</h3><blockquote><p>查看处于运行状态容器</p></blockquote><h3 id="docker-container-rm">docker container rm</h3><blockquote><p>删除一个处于终止状态的容器</p></blockquote><h3 id="docker-container-prune">docker container prune</h3><blockquote><p>删除所有处于终止状态的容器</p></blockquote><h3 id="docker-attach-容器">docker attach [容器]</h3><blockquote><p>连接一个容器，从此 stdin 中 exit，会导致容器停止</p></blockquote><h3 id="docker-exec--it-容器-命令">docker exec -it [容器] [命令]</h3><blockquote><p>在一个正在运行中的容器中执行命令，从此 stdin 中exit，不会导致容器停止</p></blockquote><h1 id="数据管理">数据管理</h1><h3 id="docker-volume-create-name">docker volume create [name]</h3><blockquote><p>创建一个数据卷</p></blockquote><h3 id="docker-volume-ls">docker volume ls</h3><blockquote><p>查看所有的数据卷</p></blockquote><h3 id="docker-volume-inspect-name">docker volume inspect [name]</h3><blockquote><p>查看指定的数据卷</p></blockquote><h3 id="docker-volume-rm-数据卷">docker volume rm [数据卷]</h3><blockquote><p>删除一个数据卷</p></blockquote><h3 id="docker-run---mount-sourcenametaget挂载点">docker run --mountsource=[name],taget=[挂载点]</h3><blockquote><p>启动一个挂载数据卷的容器</p></blockquote><h3 id="docker-volume-prune">docker volume prune</h3><blockquote><p>清除所有无主数据卷</p></blockquote><h1 id="网络管理">网络管理</h1>]]></content>
    
    
    <categories>
      
      <category>计算机技术</category>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Dokcer</tag>
      
      <tag>Technology</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JSP 笔记</title>
    <link href="/2024/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JSP/"/>
    <url>/2024/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JSP/</url>
    
    <content type="html"><![CDATA[<h1 id="一语法">一、语法</h1><h2 id="速览">0、速览</h2><table><thead><tr><th>语法</th><th>格式</th></tr></thead><tbody><tr><td>脚本程序</td><td><code>&lt;% 代码片段 %&gt;</code></td></tr><tr><td>JSP声明</td><td><code>&lt;%! declaration; [ declaration; ] + ... %&gt;</code></td></tr><tr><td>JSP表达式</td><td><code>&lt;%= 表达式%&gt;</code></td></tr><tr><td>JSP注释</td><td><code>&lt;%-- 注释 --%&gt;</code></td></tr><tr><td>JSP指令</td><td><code>&lt;%@ derective attribute="value" %&gt;</code></td></tr><tr><td>JSP行为</td><td><code>&lt;jsp:action_name attribute="value"&gt;</code></td></tr></tbody></table><h2 id="脚本程序">1、脚本程序</h2><h2 id="jsp声明">2、JSP声明</h2><h2 id="jsp表达式">3、JSP表达式</h2><h2 id="jsp注解">4、JSP注解</h2><h2 id="jsp指令">5、JSP指令</h2><h2 id="jsp行为">6、JSP行为</h2><table><thead><tr><th style="text-align: left;"><strong>语法</strong></th><th style="text-align: left;"><strong>描述</strong></th></tr></thead><tbody><tr><td style="text-align: left;">jsp:include</td><td style="text-align: left;">用于在当前页面中包含静态或动态资源</td></tr><tr><td style="text-align: left;">jsp:useBean</td><td style="text-align: left;">寻找和初始化一个JavaBean组件</td></tr><tr><td style="text-align: left;">jsp:setProperty</td><td style="text-align: left;">设置 JavaBean组件的值</td></tr><tr><td style="text-align: left;">jsp:getProperty</td><td style="text-align: left;">将 JavaBean组件的值插入到 output中</td></tr><tr><td style="text-align: left;">jsp:forward</td><tdstyle="text-align: left;">从一个JSP文件向另一个文件传递一个包含用户请求的request对象</td></tr><tr><td style="text-align: left;">jsp:plugin</td><tdstyle="text-align: left;">用于在生成的HTML页面中包含Applet和JavaBean对象</td></tr><tr><td style="text-align: left;">jsp:element</td><td style="text-align: left;">动态创建一个XML元素</td></tr><tr><td style="text-align: left;">jsp:attribute</td><td style="text-align: left;">定义动态创建的XML元素的属性</td></tr><tr><td style="text-align: left;">jsp:body</td><td style="text-align: left;">定义动态创建的XML元素的主体</td></tr><tr><td style="text-align: left;">jsp:text</td><td style="text-align: left;">用于封装模板数据</td></tr></tbody></table><h2 id="jsp隐含对象">7、JSP隐含对象</h2><table><thead><tr><th style="text-align: left;"><strong>对象</strong></th><th style="text-align: left;"><strong>描述</strong></th></tr></thead><tbody><tr><td style="text-align: left;">request</td><tdstyle="text-align: left;"><strong>HttpServletRequest</strong>类的实例，代表HTTP请求的对象，包含客户端发送到服务器的信息，如表单数据、URL参数等。</td></tr><tr><td style="text-align: left;">response</td><tdstyle="text-align: left;"><strong>HttpServletResponse</strong>类的实例，代表HTTP 响应的对象，用于向客户端发送数据和响应。</td></tr><tr><td style="text-align: left;">out</td><tdstyle="text-align: left;"><strong>JspWriter</strong>类的实例，用于向客户端输出文本内容的对象，通常用于生成HTML。</td></tr><tr><td style="text-align: left;">session</td><tdstyle="text-align: left;"><strong>HttpSession</strong>类的实例，代表用户会话的对象，可用于存储和检索用户特定的数据，跨多个页面。</td></tr><tr><td style="text-align: left;">application</td><tdstyle="text-align: left;"><strong>ServletContext</strong>类的实例，代表Web 应用程序的上下文，可以用于存储和检索全局应用程序数据。</td></tr><tr><td style="text-align: left;">config</td><tdstyle="text-align: left;"><strong>ServletConfig</strong>类的实例，包含有关当前JSP 页面的配置信息，例如初始化参数。</td></tr><tr><td style="text-align: left;">pageContext</td><tdstyle="text-align: left;"><strong>PageContext</strong>类的实例，提供对JSP页面所有对象以及命名空间的访问</td></tr><tr><td style="text-align: left;">page</td><td style="text-align: left;">类似于 Java 类中的 this 关键字，代表当前JSP 页面的实例，可以用于调用页面的方法。</td></tr><tr><td style="text-align: left;">exception</td><td style="text-align: left;"><strong>exception</strong>类的对象，代表发生错误的 JSP 页面中对应的异常对象，用于处理 JSP页面中的异常情况，可用于捕获和处理页面中发生的异常。</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>计算机技术</category>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Technology</tag>
      
      <tag>JSP</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS #1 布局</title>
    <link href="/2024/05/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Css/"/>
    <url>/2024/05/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Css/</url>
    
    <content type="html"><![CDATA[<h2 id="flex-布局">1. flex 布局</h2><h3 id="容器属性">1.1 容器属性</h3><table><thead><tr><th>容器属性</th><th>默认值</th><th>可选值</th><th>描述</th></tr></thead><tbody><tr><td>flex-direction</td><td>row</td><td>row | row-reverse | column | column-reverse</td><td>主轴的方向</td></tr><tr><td>flex-wrap</td><td>nowrap</td><td>nowrap(不换行) | wrap(第一行在上方) |wrap-reverse(第一行在下方)</td><td>如何换行</td></tr><tr><td>flex-flow</td><td>row nowrap</td><td>flex-direction|| flex-wrap</td><td>属性简写</td></tr><tr><td>justify-content</td><td>flex-start</td><td>flex-start | flex-end | center | space-between | space-around;</td><td>主轴对齐方式</td></tr><tr><td>align-items</td><td>stretch</td><td>flex-start | flex-end | center | baseline(第一行文字的基线对齐)|stretch(未设置高度，自动占满)</td><td>交叉轴对齐方式</td></tr><tr><td>align-content</td><td>stretch</td><td>flex-start | flex-end | center | space-between | space-around |stretch;</td><td>多根轴线对齐方式</td></tr></tbody></table><h3 id="项目属性">2.1 项目属性</h3><table><thead><tr><th>项目属性</th><th>默认值</th><th>可选值</th><th>描述</th></tr></thead><tbody><tr><td>order</td><td>0</td><td><number></td><td>项目的排列顺序</td></tr><tr><td>flex-grow</td><td>0（如果存在剩余空间，也不放大）</td><td><number></td><td>项目的放大比例</td></tr><tr><td>flex-shrink</td><td>1（如果空间不足，该项目将缩小）</td><td><number> | 0(不缩小)</td><td>项目的缩小比例</td></tr><tr><td>flex-basis</td><td>auto（项目的本来大小）</td><td><length> | auto</td><td>在分配多余空间之前，项目占据的主轴空间</td></tr><tr><td>flex</td><td>0 1 auto</td><td></td><td>flex-grow，shrink，-basis简写</td></tr><tr><td>align-self</td><td>auto（继承父元素）</td><td></td><td>单个项目对齐方式，覆盖align-items</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>计算机技术</category>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Technology</tag>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis 笔记</title>
    <link href="/2024/05/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/Mybatis/Mybatis%20%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/05/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/Mybatis/Mybatis%20%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="一介绍">一、介绍</h1><h2 id="orm">1.1 ORM</h2><p>ORM(Object RelationshipMapping)对象关系映射，是为了解决面向对象和关系型数据库存在互不匹配现象的一种技术</p><p>ORM通过使用描述对象和数据库之间映射的元数据将程序中的对象自动持久化到关系数据库中。</p><h2 id="mybatis">1.2 Mybatis</h2><p>Mybatis 是一个<strong>持久层(Persistence)</strong>ORM框架。</p><h1 id="二快速开始">二、快速开始</h1><h2 id="依赖导入">2.1 依赖导入</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--MybatisPlus 依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-spring-boot3-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>LATEST<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!--Mysql 依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.32<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!--数据库连接池 依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid-spring-boot-3-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.20<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="数据库相关配置">2.2 数据库相关配置</h2><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">server.port</span>=<span class="hljs-string">8080</span><br><span class="hljs-attr">spring.datasource.type</span>=<span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span><br><span class="hljs-attr">spring.datasource.driver-class-name</span>=<span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br><span class="hljs-attr">spring.datasource.url</span>=<span class="hljs-string">mysql:jdbc://localhost:3307/test?useSSL=false</span><br><span class="hljs-attr">spring.datasource.username</span>=<span class="hljs-string">root</span><br><span class="hljs-attr">spring.datasource.password</span>=<span class="hljs-string">0417</span><br><span class="hljs-comment">#指定日志输出格式</span><br><span class="hljs-attr">mybatis-plus.configuration.log-impl</span>=<span class="hljs-string">org.apache.ibatis.logging.stdout.StdOutImpl</span><br></code></pre></td></tr></table></figure><h2 id="启动类加注解">3.3 启动类加注解</h2><h1 id="三基础">三、基础</h1><h2 id="基本注解">3.1 基本注解</h2><h3 id="mapperscan">1.@MapperScan</h3><blockquote><p>这个注解，指定Mapper的扫描包</p></blockquote><ul><li><p>修饰对象：启动类</p></li><li><p>默认值：映射器Mapper组件所在的包</p></li></ul><h3 id="mapper">2.@Mapper</h3><blockquote><p>声明一个映射器（Mapper）组件。</p></blockquote><ul><li>修饰对象：映射器接口</li></ul><h2 id="crud">3.2 CRUD</h2><h3 id="增">1.增</h3><p><code>@Insert("insert into user values( #&#123;id&#125;,#&#123;username&#125;,#&#123;password&#125;)")</code></p><h3 id="删">2.删</h3><p><code>@Delete("delete from user where id = #&#123;id&#125; ")</code></p><h3 id="改">3.改</h3><p><code>@Update("update user set username= #&#123;username&#125;, password = #&#123;password&#125; where id = #&#123;id&#125;")</code></p><h3 id="查">4.查</h3><p><code>@Select("Select * from user")</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs #&#123;arg&#125;```这个字符串格式是从被修饰方法的参数列表拿到参数。"><br><br><br>## 3.3 Mybatis-Plus<br><br>**MP**（Mybatis-Plus）是一个Mybatis的增强工具，在Mybatis的基础上**只做增强不做改变**。<br><br><br><br>### 基本配置<br><br>通过继承**BaseMapper**接口来使用Mybatis-Plus<br><br><br><br>### 常用注解<br><br>#### 1.@TableName<br><br>在实体类名与表名不一致时，映射实体类与表名。<br><br>#### 2.@TableField<br><br>在实体类字段名与表中字段名不一致时，映射实体类属性与表中字段。<br><br>#### 3.@TableId<br><br>描述主键字段属性。<br><br><br><br>```java<br>@TableId(value=&quot;id&quot;,type = IdType.AUTO)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机技术</category>
      
      <category>Mybatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Technology</tag>
      
      <tag>Mybatis</tag>
      
      <tag>ORM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis #0 学习笔记</title>
    <link href="/2024/05/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/Redis/Redis/"/>
    <url>/2024/05/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/Redis/Redis/</url>
    
    <content type="html"><![CDATA[<h1 id="一数据类型">一、数据类型</h1><table><thead><tr><th>数据类型</th><th>描述</th><th>阈值</th></tr></thead><tbody><tr><td>String</td><td>基本类型，二进制安全的字符串</td><td>最大 512MB</td></tr><tr><td>Hash</td><td>String类型的键值对集合，存储对象</td><td><span class="math inline">\(2^{32}-1\)</span> 个键值对</td></tr><tr><td>List</td><td>String类型的列表，按插入顺序排序</td><td><span class="math inline">\(2^{32}-1\)</span> 个元素</td></tr><tr><td>Set</td><td>String类型的无序集合</td><td><span class="math inline">\(2^{32}-1\)</span> 个成员</td></tr><tr><td>Zset</td><td>String类型的有序集合</td><td><span class="math inline">\(2^{32}-1\)</span> 个成员</td></tr></tbody></table><h1 id="二springboot-集成">二、SpringBoot 集成</h1><h2 id="redistemplatekv">2.1 RedisTemplate&lt;K,V&gt;</h2><h3 id="operations">2.1.2 Operations</h3><table><thead><tr><th>操作类</th><th>获取</th><th>作用</th></tr></thead><tbody><tr><td>ValueOperations</td><td>opssForValue()</td><td>提供 Redis String API 操作</td></tr><tr><td>HashOperations</td><td>opsForHash()</td><td>提供 Redis Hash API 操作</td></tr><tr><td>ListOperations</td><td>opsForList()</td><td>提供 Redis List API 操作</td></tr><tr><td>SetOperations</td><td>opsForSet()</td><td>提供 Redis Set API 操作</td></tr><tr><td>ZsetOperations</td><td>opsForZset()</td><td>提供 Redis ZSet(Sorted Set) API 操作</td></tr><tr><td>GeoOperations</td><td>opsForGeo()</td><td>提供 Redis Geo API 操作</td></tr><tr><td>HyperLogLogOperations</td><td>opsForHyperLogLog()</td><td>提供 Redis HyperLogLog API 操作</td></tr></tbody></table><h2 id="redisserializer">2.2 RedisSerializer</h2><table><thead><tr><th>序列化方式</th><th>备注</th><th>获取</th></tr></thead><tbody><tr><td>JdkSerializationRedisSerializer</td><td>jdk序列化，是默认的序列化方式</td><td>RedisSerializer.java()</td></tr><tr><td>StringRedisSerializer</td><td>String序列化，<strong>StringRedisTemplate</strong>的key和value采用的就是这种序列化方案。</td><td>RedisSerializer.string()</td></tr><tr><td>GenericJackson2JsonRedisSerializer</td><td>JSON序列化，对所有类通用</td><td>RedisSerializer.json()</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>计算机技术</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Technology</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring 笔记</title>
    <link href="/2024/05/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/Spring/Spring%20%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/05/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/Spring/Spring%20%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="一装配">一、装配</h1><blockquote><p>创建应用组件之间协作的行为，通常称为<strong>装配</strong>（<strong><em>wiring</em></strong>）</p></blockquote><h2 id="三种装配机制">1.1 三种装配机制</h2><ul><li><h4 id="xml显示装配">XML显示装配</h4></li><li><h4 id="在java中进行显示装配">在Java中进行显示装配</h4><blockquote><p>通过<strong><span class="citation"data-cites="Configuration">@Configuration</span></strong>注解声明一个<strong>Spring配置类</strong>。</p><h6 id="组件命名">组件命名</h6><ol type="1"><li>通过<strong><span class="citation"data-cites="Component">@Component</span>( beanID)</strong>注解给组件设置<strong>ID</strong></li><li>通过<strong><span class="citation" data-cites="Named">@Named</span>(beanID )</strong>注解设置组件<strong>ID</strong> (这个<strong><spanclass="citation"data-cites="Named">@Named</span></strong>注解是在<strong>Java依赖注入规范</strong>中定义的，不是Spring框架特有的)。</li><li>通过<strong><span class="citation" data-cites="Bean">@Bean</span>(name="")</strong>注解的name属性设置组件ID</li></ol><p><strong>JavaConfig</strong>配置类中，<strong>bean</strong>的ID默认与<strong><spanclass="citation"data-cites="Bean">@Bean</span></strong>注解的方法名一致。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean(name=&quot;test&quot;)</span><span class="hljs-comment">//这个Bean默认的ID是方法名knight,但是在@Bean注解中设置了name值为test</span><br><span class="hljs-keyword">public</span> Knight <span class="hljs-title function_">knight</span><span class="hljs-params">()</span>&#123;<span class="hljs-comment">//此时BeanID就是test</span><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Knight</span>()<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="javaconfig实现注入">JavaConfig实现注入</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//若Quest依赖Knight,则借助@Bean注解方法knight实现注入</span><br><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> Quest <span class="hljs-title function_">quest</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Quest</span>(knight())<br>&#125;<br></code></pre></td></tr></table></figure></blockquote></li><li><h4id="隐式的bean发现机制和自动装配">隐式的bean发现机制和自动装配</h4><blockquote><h5 id="启用组件扫描的方式">启用组件扫描的方式</h5><ul><li><p>隐式装配Config类需要使用<strong><span class="citation"data-cites="ComponentScan">@ComponentScan</span></strong>注解，<strong><spanclass="citation"data-cites="ComponentScan">@ComponentScan</span></strong>默认会扫描与<strong><em>配置类相同的包</em></strong>，在这个包及其子包下，查找带有<strong><spanclass="citation"data-cites="Component">@Component</span></strong>注解的类，并且会在Spring中自动为其创建一个_<strong>Bean</strong>_</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Config</span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>同时，可以通过<strong><span class="citation"data-cites="ComponentScan">@ComponentScan</span>( packageName)</strong>注解，设置组件扫描的<strong>基础包</strong>。</p><p>如果需要配置多个<strong>基础包</strong>，则设置<strong><spanclass="citation" data-cites="ComponentScan">@ComponentScan</span>(basePackages={"","",""})</strong>的属性basePackages的值为一个包名数组。</p><p>然而，由于basePackages值为<strong>String</strong>类型，显然，只是类型不安全的(<strong>not type safe</strong>)。</p><p>可以通过设置<strong>basePackageClasses</strong>属性，传入一个或多个<strong>Class</strong>对象，基础包将被设置为这些类所在的包。</p></li><li><p>显示通过__配置XML__，启动组件扫描</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;....&quot;</span>/&gt;</span>  <br></code></pre></td></tr></table></figure></li></ul><h5 id="自动装配">自动装配</h5><p>​ 通过<strong><span class="citation"data-cites="Autowired">@Autowired</span></strong>注解，修饰字段，或者成员方法，将声明的所需依赖，在bean实例化时，自动装配。</p></blockquote></li></ul><h2 id="单例性">1.2 单例性</h2><p><strong>Spring</strong> 中的<strong>Bean</strong>都是单例的。</p><p>Spring会拦截对<strong><span class="citation"data-cites="Bean注解方法">@Bean注解方法</span></strong>的调用，确保返回的是<strong>Spring</strong>所创建的<strong>Bean</strong>，也就是Spring在调用<strong><spanclass="citation"data-cites="Bean注解方法">@Bean注解方法</span></strong>时所创建的实例</p><h1 id="二controller">二、Controller</h1><blockquote><p>若 Controller方法返回自定义对象，会默认以<code>Content-Type=application/json</code>的形式返回数据。</p></blockquote><h2 id="restcontroller">2.1 <span class="citation"data-cites="RestController">@RestController</span></h2><p>被注解修饰的类是一个<strong>RESTful</strong>风格的<strong>Controller</strong>。主要用于<strong>前后端分离项目</strong>。返回纯数据。</p><h2 id="requestmapping">2.2 <span class="citation"data-cites="RequestMapping">@RequestMapping</span></h2><p>这个注解修饰一个<strong>控制器方法</strong>，默认参数<strong>value</strong>为该方法的<strong>路由路径</strong>，<strong>method</strong>参数指明该方法的接受的<strong>请求类型</strong>。</p><h2 id="requestparam">2.3 <span class="citation"data-cites="RequestParam">@RequestParam</span></h2><p>这个注解修饰<strong>控制器方法的参数</strong>，作用是<strong>将该参数映射到前端请求路径中</strong>的一个具体字段，默认参数值为请求路径中的字段名。</p><h2 id="requestbody">2.4 <span class="citation"data-cites="RequestBody">@RequestBody</span></h2><p>这个注解修饰<strong>控制器方法的参数</strong>，作用是<strong>将被修饰的参数（通常是一个对象）的字段与请求体中的<code>application/json</code>数据建立一一映射关系</strong>。</p><p>当请求体的数据是<code>x-www-urlencoded</code>形式时，<strong><spanclass="citation"data-cites="RequestBody">@RequestBody</span></strong>会将整个body的数据映射到它修饰的参数上面。</p><p>当请求体的数据是<code>multipart/form-data</code>形式时，<strong><spanclass="citation"data-cites="RequestBody">@RequestBody</span></strong>映射会报错。</p><h2 id="pathvariable">2.5 <span class="citation"data-cites="PathVariable">@PathVariable</span></h2><p>这个注解修饰<strong>控制器方法的参数</strong>，作用是<strong>动态获取请求路径中的参数，使之映射到同名的方法参数。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getUser</span><span class="hljs-params">( <span class="hljs-meta">@PathVariable</span> <span class="hljs-type">int</span> id)</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;根据ID获取用户&quot;</span>;    <br>&#125;<br></code></pre></td></tr></table></figure><h1 id="三spring-boot-devtools">三、Spring-Boot-Devtools</h1><p>这是一个Spring Boot提供的<strong>开发时</strong>组件。</p><h2 id="解决什么问题">3.1 解决什么问题</h2><p>在实际的项目开发调试过程中，会频繁地修改后台类文件，导致需要重新编译，重新启动，整个过程十分麻烦，影响开发效率。</p><h2 id="基本实现">3.2 基本实现</h2><p>spring-boot-devtool会监听<strong>classpath</strong>下的文件变动，触发<strong>Restart</strong>类加载器重新加载该类，从而实现类文件和属性文件的热部署。</p><h2 id="基本配置">3.3 基本配置</h2><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#热部署生效</span><br><span class="hljs-attr">spring.devtools.restart.enable</span>=<span class="hljs-string">true</span><br><span class="hljs-comment">#设置重启目录</span><br><span class="hljs-attr">spring.devtools.restart.additional-paths</span>=<span class="hljs-string">src/main/java</span><br><span class="hljs-comment">#设置classpath下的WEB-INF目录下的修改不重启</span><br><span class="hljs-attr">spring.devtools.restart.exclude</span>=<span class="hljs-string">static/**</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机技术</category>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Technology</tag>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue Router 笔记</title>
    <link href="/2024/05/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/Vue/VueRouter%20%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/05/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/Vue/VueRouter%20%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="安装与使用">安装与使用</h1><p>Vue2 只能使用 VueRouter3，Vue3 只能使用VueRouter4。</p><p>通过npm 安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm add vue-router@3<br><br>npm add vue-router@4<br></code></pre></td></tr></table></figure><p>第一步，独立维护一个路由配置文件。</p><p>src/router/index.js:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//导入VueRouter路由与Vue</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">VueRouter</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-comment">//导入自定义组件</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Test</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/components/Test.vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">My</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/components/My.vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Work</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/components/Work.vue&#x27;</span><br><br><span class="hljs-comment">//Vue挂载路由</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">VueRouter</span>)<br><br><span class="hljs-comment">//创建路由对象</span><br><span class="hljs-comment">//建立路径hash与组件的映射</span><br><span class="hljs-keyword">const</span> router=<span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span>(&#123;<br>    <span class="hljs-attr">routes</span>:[<br>        &#123; <span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/&#x27;</span> , <span class="hljs-attr">redirect</span>:<span class="hljs-string">&#x27;/path/to/component1&#x27;</span>&#125;<br>        &#123; <span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/path/to/component1&#x27;</span> , <span class="hljs-attr">component</span>: <span class="hljs-title class_">Test</span>&#125;,<br>        &#123; <span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/path/to/component2&#x27;</span> , <span class="hljs-attr">component</span>: <span class="hljs-title class_">My</span> &#125;,<br>&#123; <span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/path/to/component3&#x27;</span> , <span class="hljs-attr">component</span>: <span class="hljs-title class_">Work</span> &#125;<br>    ]<br>&#125;)<br><br><span class="hljs-comment">//导出路由对象</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router<br></code></pre></td></tr></table></figure><p>第二步，在main.js 里面，通过router属性，挂载路由。</p><p>src/main.js:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;Vue&#x27;</span><br>impory <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/App.vue&#x27;</span><br><span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/router&#x27;</span><br><br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>    <span class="hljs-attr">render</span>:<span class="hljs-function">(<span class="hljs-params">h</span>)=&gt;</span><span class="hljs-title function_">h</span>(<span class="hljs-title class_">App</span>),<br>    router<br>&#125;).<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#app&#x27;</span>)<br></code></pre></td></tr></table></figure><p>第三部，创建显示路由：</p><p>src/App.vue：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>&lt;div&gt;<br>        &lt;router-link to=&#x27;/path/to/component1&#x27;&gt;组件1&lt;/router-link&gt;<br>        &lt;router-link to=&#x27;/path/to/component2&#x27;&gt;组件2&lt;/router-link&gt;<br>        &lt;router-link to=&#x27;/path/to/component3&#x27;&gt;组件3&lt;/router-link&gt;<br>       &lt;!--路由出口 --&gt;<br>        &lt;router-view&gt;&lt;/router-view&gt;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><h1 id="路由重定向">路由重定向</h1><p>通过redirect属性重定向<code>'/'</code>路径到首页<code>/path/to/main</code></p><p>@/router/index.js：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> router=&#123;<br>    <br>    <span class="hljs-attr">routes</span>:[<br>        &#123;<span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-attr">redirect</span>:<span class="hljs-string">&#x27;/paht/to/main&#x27;</span>&#125;,<br>        &#123;&#125;,<br>        &#123;&#125;<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="嵌套路由">嵌套路由</h1><p>通过children属性声明子路由</p><p>@/router/index.js：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> router=&#123;<br>    <br>    <span class="hljs-attr">routes</span>:[<br>        &#123;<span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-attr">redirect</span>:<span class="hljs-string">&#x27;/paht/to/main&#x27;</span>&#125;,<br>        &#123;<span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/father&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">Father</span>, <br>         <span class="hljs-attr">children</span>: [<br>          &#123;<span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;children&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">Children</span>&#125;,<br>          &#123;&#125;,<br>            ]<br>        &#125;<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="动态路由">动态路由</h1><p>通过<code>:</code>-<code>冒号</code>声明路径参数，实现动态路由。</p><p>例如<code>/path/to/user/:id</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> router=&#123;<br>    <br>    <span class="hljs-attr">routes</span>:[<br>        &#123;<span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/path/to/user/:id&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">User</span>&#125;,<br>        &#123;&#125;,<br>        <br>    ]<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p><code>/path/to/user/1</code></p><p><code>/path/to/user/2</code></p><p>都会路由到User组件</p><p>在User组件中，可通过<code>this.$route.param</code>对象获取这个路径参数。</p><h2 id="属性传参">属性传参</h2><p>以属性<code>prop</code>的的方式接受路由参数。主要解决<code>$router</code>对象产生的耦合</p><p>第一步</p><p>将路由映射对象的<code>props</code>属性设置为<code>true</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> router=&#123;<br>    <br>    <span class="hljs-attr">routes</span>:[<br>        &#123;<span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/path/to/user/:id&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">User</span>,<span class="hljs-attr">props</span>:<span class="hljs-literal">true</span>&#125;,<br>        &#123;&#125;,<br>        <br>    ]<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>第二步</p><p>组件设置自定义属性。</p><p>User.vue：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>&lt;h1&gt;<br>        your id is&#123;&#123; id &#125;&#125;<br>    &lt;/h1&gt;<br>&lt;/template&gt;<br>&lt;script&gt;<br>export default&#123;<br>        //设置自定义属性id<br>       props: [ &#x27;id&#x27; ]<br>    &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h2 id="方法路由">方法路由</h2><table><thead><tr><th>声明式导航</th><th>编程式导航</th></tr></thead><tbody><tr><td><code>&lt;router-link to='/..'&gt;</code></td><td><code>this.$router.push('/...')</code></td></tr></tbody></table><p>Test.vue：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>&lt;button @click=&#x27;to&#x27;&gt;<br>        跳转<br>    &lt;/button&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>export default&#123;<br>        methods:&#123;<br>            to()&#123;<br>                this.$router.push(&quot;/user/$&#123;id&#125;&quot;)<br>            &#125;<br>            <br>            <br>        &#125;<br>    &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h1 id="导航卫士">导航卫士</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">router.<span class="hljs-title function_">beforeEach</span>( <span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>)=&gt;</span>&#123;<br><br><span class="hljs-keyword">if</span>( to.<span class="hljs-property">paht</span>=<span class="hljs-string">&#x27;/..&#x27;</span> &amp;&amp; !isAuthenticated)&#123;<br>        <span class="hljs-title function_">next</span>(<span class="hljs-string">&#x27;/login&#x27;</span>)<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-title function_">next</span>()<span class="hljs-comment">//放行</span><br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机技术</category>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Technology</tag>
      
      <tag>Vue</tag>
      
      <tag>Vue Router</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Security</title>
    <link href="/2024/05/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/Spring/SpringSecurity/"/>
    <url>/2024/05/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/Spring/SpringSecurity/</url>
    
    <content type="html"><![CDATA[<h1 id="一基础">一、基础</h1><h2 id="处理步骤">1.1 处理步骤</h2><p>如果一个请求到来，<strong>SpringSecurity</strong>会按照以处理步骤。</p><pre><code class=" mermaid">graph LRA(Http Request)--&gt;B(Filter)--&gt;C(AuthenticationManager)--&gt;D(AuthenticationProvider)--&gt;E(UserDetailsService)</code></pre><ol type="1"><li><p><strong>Filter</strong></p><blockquote><p>拦截Http请求，获取用户名和秘密等认证信息</p><p>关键方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Authentication <span class="hljs-title function_">attemptAuthentication</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span><br>        <span class="hljs-keyword">throws</span> AuthenticationException, IOException, ServletException;<br></code></pre></td></tr></table></figure></blockquote></li><li><p><strong>AuthenticationManager</strong></p><blockquote><p>从filter中获取认证信息，然后查找合适的AuthenticationProvider来发起认证流程</p><p>关键方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Authentication <span class="hljs-title function_">authenticate</span><span class="hljs-params">(Authentication authentication)</span> <span class="hljs-keyword">throws</span> AuthenticationException;<br></code></pre></td></tr></table></figure></blockquote></li><li><p><strong>AuthenticationProvider</strong></p><blockquote><p>调用UserDetailsService来查询已经保存的用户信息并与从http请求中获取的认证信息比对。如果成功则返回，否则则抛出异常。</p><p>关键方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> UserDetails <span class="hljs-title function_">retrieveUser</span><span class="hljs-params">(String username, UsernamePasswordAuthenticationToken authentication)</span><br>            <span class="hljs-keyword">throws</span> AuthenticationException;<br></code></pre></td></tr></table></figure></blockquote></li><li><p><strong>UserDetailsService</strong></p><blockquote><p>负责获取用户保存的认证信息，例如查询数据库。</p><p>关键方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">UserDetails <span class="hljs-title function_">loadUserByUsername</span><span class="hljs-params">(String username)</span> <span class="hljs-keyword">throws</span> UsernameNotFoundException;<br></code></pre></td></tr></table></figure></blockquote></li></ol><p>默认实现：</p><ul><li><strong>Filter：</strong> UsernamePasswordAuthenticationFilter</li><li><strong>AuthenticationManager：</strong> ProviderManager</li><li><strong>AuthenticationProvider：</strong>DaoAuthenticationProvider</li><li><strong>UserDetailsService：</strong>InMemoryUserDetailsManager</li></ul><h2 id="过滤器链">1.2 过滤器链</h2><h3 id="速览">1.2.1 速览</h3><table><thead><tr><th>次序</th><th>过滤器</th><th>描述</th><th></th></tr></thead><tbody><tr><td>1</td><td>DisableEncodeUrlFilter</td><td></td><td></td></tr><tr><td>2</td><td>ForceEagerSessionCreationFilter</td><td></td><td></td></tr><tr><td>3</td><td>ChannelProcessingFilter</td><td>通常是用来过滤哪些请求必须用 <code>https</code> 协议，哪些请求必须用 <code>http</code> 协议， 哪些请求随便用哪个协议都行</td><td></td></tr><tr><td>4</td><td>WebAsyncManagerIntegrationFilter</td><td></td><td></td></tr><tr><td>5</td><td>SecurityContextHolderFilter</td><td></td><td></td></tr><tr><td>6</td><td>SecurityContextPersistenceFilter</td><td>主要控制 <code>SecurityContext</code> 的在一次请求中的生命周期。请求来临时，创建<code>SecurityContext</code>安全上下文信息，请求结束时清空 <code>SecurityContextHolder</code></td><td></td></tr><tr><td>7</td><td>HeaderWriterFilter</td><td>HeaderWriterFilter<code>用来给</code>http<code>响应添加一些</code>Header<code>,比如</code>X-Frame-Options<code>,</code>X-XSS-Protection<code>，</code>X-Content-Type-Options</td><td></td></tr><tr><td>8</td><td>CorsFilter</td><td></td><td></td></tr><tr><td>9</td><td>CsrfFilter</td><td><code>CsrfFilter</code>用于防止<code>csrf</code>攻击，前后端使用json交互需要注意的一个问题。</td><td></td></tr><tr><td>10</td><td>LogoutFilter</td><td><code>LogoutFilter</code> 很明显这是处理注销的过滤器。你可以通过<code>HttpSecurity.logout()</code> 来定制注销逻辑，非常有用。</td><td></td></tr><tr><td>11</td><td>X509AuthenticationFilter</td><td><code>X509</code> 认证过滤器。你可以通过<code>HttpSecurity#X509()</code> 来启用和配置相关功能。</td><td></td></tr><tr><td>12</td><td>AbstractPreAuthenticatedProcessingFilter</td><td><code>AbstractPreAuthenticatedProcessingFilter</code>处理处理经过预先认证的身份验证请求的过滤器的基类，其中认证主体已经由外部系统进行了身份验证。目的只是从传入请求中提取主体上的必要信息，而不是对它们进行身份验证。</td><td></td></tr><tr><td>13</td><td>UsernamePasswordAuthenticationFilter</td><td>处理用户以及密码认证的核心过滤器。认证请求提交的<code>username</code>和<code>password</code>，被封装成<code>token</code>进行一系列的认证，便是主要通过这个过滤器完成的，在表单认证的方法中，这是最最关键的过滤器。</td><td></td></tr><tr><td>14</td><td>DefaultLoginPageGeneratingFilter</td><td>生成默认的登录页。默认 <code>/login</code></td><td></td></tr><tr><td>15</td><td>DefaultLoginPageGeneratingFilter</td><td>生成默认的退出页。默认 <code>/logout</code> 。</td><td></td></tr><tr><td>16</td><td>ConcurrentSessionFilter</td><td>主要用来判断<code>session</code>是否过期以及更新最新的访问时间</td><td></td></tr><tr><td>17</td><td>DigestAuthenticationFilter</td><td></td><td></td></tr><tr><td>18</td><td>BasicAuthenticationFilter</td><td>和<code>Digest</code>身份验证一样都是<code>Web</code>应用程序中流行的可选的身份验证机制 。<code>BasicAuthenticationFilter</code> 负责处理 <code>HTTP</code>头中显示的基本身份验证凭据。这个 <strong>Spring Security</strong> 的<strong>Spring Boot</strong> 自动配置默认是启用的 。</td><td></td></tr><tr><td>19</td><td>RequestCacheAwareFilter</td><td></td><td></td></tr><tr><td>20</td><td>SecurityContextHolderAwareRequestFilter</td><td>用来 实现<code>j2ee</code>中 <code>Servlet Api</code> 一些接口方法,比如 <code>getRemoteUser</code> 方法、<code>isUserInRole</code>方法，在使用 <strong>Spring Security</strong>时其实就是通过这个过滤器来实现的。</td><td></td></tr><tr><td>21</td><td>JaasApiIntegrationFilter</td><td>适用于<code>JAAS</code> （<code>Java</code> 认证授权服务）。如果<code>SecurityContextHolder</code> 中拥有的 <code>Authentication</code>是一个 <code>JaasAuthenticationToken</code>，那么该<code>JaasApiIntegrationFilter</code> 将使用包含在<code>JaasAuthenticationToken</code> 中的 <code>Subject</code> 继续执行<code>FilterChain</code>。</td><td></td></tr><tr><td>22</td><td>RememberMeAuthenticationFilter</td><td>处理 <strong><code>记住我</code></strong> 功能的过滤器。</td><td></td></tr><tr><td>23</td><td>AnonymousAuthenticationFilter</td><td>匿名认证过滤器。<strong>对于 <code>Spring Security</code>来说，所有对资源的访问都是有 <code>Authentication</code>的。对于无需登录（<code>UsernamePasswordAuthenticationFilter</code>）直接可以访问的资源，会授予其匿名用户身份</strong>。</td><td></td></tr><tr><td>24</td><td>SessionManagementFilter</td><td><code>Session</code> 管理器过滤器，内部维护了一个<code>SessionAuthenticationStrategy</code> 用于管理 <code>Session</code>。</td><td></td></tr><tr><td>25</td><td>ExceptionTranslationFilter</td><td>主要来传输异常事件</td><td></td></tr><tr><td>26</td><td>FilterSecurityInterceptor</td><td>这个过滤器决定了访问特定路径应该具备的权限，访问的用户的角色，权限是什么？访问的路径需要什么样的角色和权限？这些判断和处理都是由该类进行的。<strong>如果你要实现动态权限控制就必须研究该类</strong>。</td><td></td></tr><tr><td>27</td><td>AuthorizationFilter</td><td></td><td></td></tr><tr><td>28</td><td>SwitchUserFilter</td><td><code>SwitchUserFilter</code>是用来做账户切换的。默认的切换账号的<code>url</code>为<code>/login/impersonate</code>，默认注销切换账号的<code>url</code>为<code>/logout/impersonate</code>，默认的账号参数为<code>username</code>。</td><td></td></tr></tbody></table><h3 id="默认启动过滤器">1.2.2 默认启动过滤器</h3><ol type="1"><li>DisableEncodeUrlFilter</li><li>WebAsyncManagerIntegrationFilter</li><li>SecurityContextHolderFilter</li><li>HeaderWriterFilter</li><li>CsrfFilter</li><li>LogoutFilter</li><li>UsernamePasswordAuthenticationFilter</li><li>DefaultLoginPageGeneratingFilter</li><li>DefaultLoginPageGeneratingFilter</li><li>BasicAuthenticationFilter</li><li>RequestCacheAwareFilter</li><li>SecurityContextHolderAwareRequestFilter</li><li>AnonymousAuthenticationFilter</li><li>ExceptionTranslationFilter</li><li>AuthorizationFilter</li></ol><h1 id="二配置">二、配置</h1><h2 id="websecurityconfigureradaptor">2.1WebSecurityConfigurerAdaptor</h2><ol type="1"><li><p>anyRequest</p><blockquote><p>匹配所有请求路径</p></blockquote></li><li><p>access</p><blockquote><p>SpringEl表达式结果为true时可以访问</p></blockquote></li><li><p>anonymous</p><blockquote><p>匿名可以访问</p></blockquote></li><li><p>denyAll</p><blockquote><p>用户不能访问</p></blockquote></li><li><p>fullyAuthenticated</p><blockquote><p>用户完全认证可以访问（非remember-me下自动登录）</p></blockquote></li><li><p>hasAnyAuthority</p><blockquote><p>如果有参数，参数表示权限，则其中任何一个权限可以访问</p></blockquote></li><li><p>hasAnyRole</p><blockquote><p>如果有参数，参数表示角色，则其中任何一个角色可以访问</p></blockquote></li><li><p>hasAuthority</p><blockquote><p>如果有参数，参数表示权限，则其权限可以访问</p></blockquote></li><li><p>hasIpAddress</p><blockquote><p>如果有参数，参数表示IP地址，如果用户IP和参数匹配，则可以访问</p></blockquote></li><li><p>hasRole</p><blockquote><p>如果有参数，参数表示角色，则其角色可以访问</p></blockquote></li><li><p>permitAll</p><blockquote><p>用户可以任意访问</p></blockquote></li><li><p>rememberMe</p><blockquote><p>允许通过remember-me登录的用户访问</p></blockquote></li><li><p>authenticated</p><blockquote><p>用户登录后可访问</p></blockquote></li></ol><h1 id="三配置6.0">三、配置（6.0）</h1><h2 id="配置类">3.1 配置类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableWebSecurity</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableMethodSecurity</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SecurityConfiguration</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> SecurityFilterChain <span class="hljs-title function_">filterChain</span><span class="hljs-params">(HttpSecurity httpSecurity)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-keyword">return</span> httpSecurity.authorizeHttpRequests(authorize-&gt; &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        authorize<br>                                <span class="hljs-comment">// 放行登录接口</span><br>                                .requestMatchers(<span class="hljs-string">&quot;/login&quot;</span>).permitAll()<br>                                <span class="hljs-comment">// 其余的都需要权限校验</span><br>                                .anyRequest().authenticated()<br>                                <span class="hljs-comment">// 防跨站请求伪造</span><br>                                .and().csrf(csrf -&gt; csrf.disable());<br>                    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>                    &#125;<br>                &#125;<br>        ).build();<br><br>    &#125;<br>    <br>    <span class="hljs-comment">// 密码编码器</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> PasswordEncoder <span class="hljs-title function_">passwordEncoder</span><span class="hljs-params">()</span>&#123;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BCryptPasswordEncoder</span>();<br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机技术</category>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Technology</tag>
      
      <tag>Spring</tag>
      
      <tag>Spring Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JWT 笔记</title>
    <link href="/2024/05/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E4%BA%92%E8%81%94%E7%BD%91%E6%A0%87%E5%87%86/JWT/"/>
    <url>/2024/05/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E4%BA%92%E8%81%94%E7%BD%91%E6%A0%87%E5%87%86/JWT/</url>
    
    <content type="html"><![CDATA[<h1 id="一abstract">一、Abstract</h1><p><strong>JSON Web Token</strong> (<strong>JWT</strong>, suggestedpronunciation <strong>[/dʒɒt/]</strong>, same as the word "jot") is aproposed Internet standard for creating data with optional</p><p>signature and/or optional encryption whose payload holds JSON thatasserts some number of claims. The tokens are signed either using aprivate</p><p>secret or a public/private key.</p><h1 id="二structure">二、Structure</h1><h2 id="header">2.1 Header</h2><p>Identifies which algorithm is used to generate the signature. In thebelow example, <code>HS256</code> indicates that this token is signedusing HMAC-SHA256.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;alg&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;HS256&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;typ&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;JWT&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="payload">2.2 Payload</h2><p>Contains a set of claims. The JWT specification defines sevenRegistered Claim Names, which are the standard fields commonly includedin tokens.</p><p>Custom claims are usually also included, depending on the purpose ofthe token.</p><p>This example has the standard Issued At Time claim (<code>iat</code>)and a custom claim (<code>loggedInAs</code>).</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;loggedInAs&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;admin&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;iat&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1422779638</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="signature">2.3 Signature</h2><p>Securely validates the token. The signature is calculated by encodingthe header and payload using Base64url Encoding RFC 4648 andconcatenating the</p><p>two together with a period separator. That string is then run throughthe cryptographic algorithm specified in the header. This example usesHMAC-</p><p>SHA256 with a shared secret (public key algorithms are also defined).The <em>Base64url Encoding</em> is similar to base64, but uses differentnon-alphanumeric</p><p>characters and omits padding.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">HMAC_SHA256(<br>  secret<span class="hljs-punctuation">,</span><br>  base64urlEncoding(header) + &#x27;.&#x27; +<br>  base64urlEncoding(payload)<br>)<br></code></pre></td></tr></table></figure><p>The three parts are encoded separately using Base64url Encoding RFC4648, and concatenated using periods to produce the JWT:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> token = <span class="hljs-title function_">base64urlEncoding</span>(header) + <span class="hljs-string">&#x27;.&#x27;</span> + <span class="hljs-title function_">base64urlEncoding</span>(payload) + <span class="hljs-string">&#x27;.&#x27;</span> + <span class="hljs-title function_">base64urlEncoding</span>(signature)<br></code></pre></td></tr></table></figure><h1 id="三standard-fields">三、Standard Fields</h1><table><thead><tr><th>Code</th><th>Name</th><th>Description</th></tr></thead><tbody><tr><td>iss</td><td>Issuer</td><td>Identifies principal that issued the JWT.</td></tr><tr><td>sub</td><td>Subject</td><td>Identifies the subject of the JWT.</td></tr><tr><td>aud</td><td>Audience</td><td></td></tr><tr><td>exp</td><td>Expiration Time</td><td>Identifies the expiration time on and after which the JWT<strong>must not</strong> be accepted for processing. The value must bea NumericDate: either an integer or decimal, representing seconds past1970-01-01 00:00:00Z.</td></tr><tr><td>nbf</td><td>Not Before</td><td>Identifies the time on which the JWT will start to be accepted forprocessing. The value must be a NumericDate.</td></tr><tr><td>iat</td><td>Issued at</td><td>Identifies the time at which the JWT was issued. The value must be aNumericDate.</td></tr><tr><td>jti</td><td>JWT ID</td><td>Case-sensitive unique identifier of the token even among differentissuers.</td></tr></tbody></table><h1 id="四implement">四、Implement</h1><p>在 https://jwt.io/ 网站中收录有各类语言的JWT库实现，java目前有6个实现</p><ol type="1"><li><p><strong>java-jwt</strong></p><blockquote><p>Auth0实现的--maven: com.auth0 / java-jwt / 3.3.0</p><p>Auth0提供的JWT库简单实用,依赖第三方(如JAVA运行环境)提供的证书信息(keypair);有一问题是在生成id_token与 校验(verify)id_token时都需要 公钥</p><p>(public key)与密钥(private key),个人感觉是一不足(实际上在校验时只需要public key即可)</p></blockquote></li><li><p><strong>jose4j</strong></p><blockquote><p>Brian Campbell实现的--maven: org.bitbucket.b_c / jose4j / 0.6.3</p><p>jose4j提供了完整的JWT实现, 可以不依赖第三方提供的证书信息(keypair,库本身自带有RSA的实现),类定义与JWT协议规定匹配度高,易理解与上手对称加</p><p>密与非对称加密都有提供实现</p></blockquote></li><li><p><strong>nimbus-jose-jwt</strong></p><blockquote><p>connect2id实现的--maven: com.nimbusds / nimbus-jose-jwt / 5.7</p><p>nimbus-jose-jwt库类定义清晰,简单易用,易理解 ,依赖第三方提供的证书信息(keypair), 对称算法 与非对称算法皆有实现.</p></blockquote></li><li><p><strong>jjwt</strong>　　</p><blockquote><p>Les Haziewood实现的--maven: io.jsonwebtoken / jjwt-root / 0.11.1</p><p>jjwt小巧够用, 但对JWT的一些细节包装不够, 比如 Claims(只提供获取header,body)</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JwtUtils</span> &#123;<br><br>    <span class="hljs-comment">//单位秒</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> expiration_time=<span class="hljs-number">60</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String key=<span class="hljs-string">&quot;this is louis&quot;</span>;<br><br><br>    <span class="hljs-comment">// 生成token</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">generateToken</span><span class="hljs-params">(String username)</span>&#123;<br><br>        <span class="hljs-type">Date</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>        <span class="hljs-type">Date</span> <span class="hljs-variable">expire</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(now.getTime()+expiration_time*<span class="hljs-number">5</span>);<br>        <span class="hljs-keyword">return</span> Jwts.builder()<br>                .setHeaderParam(<span class="hljs-string">&quot;type&quot;</span>,<span class="hljs-string">&quot;JWT&quot;</span>)<br>                .setSubject(username)<br>                .setIssuedAt(now)<br>                .setExpiration(expire)<br>                .signWith(SignatureAlgorithm.HS256,key)<br>                .compact();<br><br>    &#125;<br><br>    <span class="hljs-comment">// 解析token</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Claims <span class="hljs-title function_">getClaimsByToken</span><span class="hljs-params">(String token)</span>&#123;<br><br>        <span class="hljs-keyword">return</span> Jwts.parser()<br>                .setSigningKey(key)<br>                .parseClaimsJws(token)<br>                .getBody();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p></blockquote></li><li><p><strong>prime-jwt</strong>　　</p><blockquote><p>Inversoft实现的--maven: io.fusionauth / fusionauth-jwt / 3.5.0</p><p>prime jwt库怎么说呢, 有些地方不符合JAVA语言规范, 支持对称算法(HMAC)与非对称算法(RSA), 也算容易理解</p></blockquote></li><li><p><strong>vertx-auth-jwt</strong>　　</p><blockquote><p>Vertx实现的--maven: io.vertx / vertx-auth-jwt / 3.5.1</p><p>Vertx Auth Jwt库算是最不容易理解的一个库了.花了不少时间才弄通这一示例. 不容易上手.并且生成与校验id_token 时都需要公钥与私钥,不足.</p></blockquote></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机技术</category>
      
      <category>互联网标准</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Technology</tag>
      
      <tag>JWT</tag>
      
      <tag>Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql #0 学习笔记</title>
    <link href="/2024/05/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/Mysql/Mysql/"/>
    <url>/2024/05/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/Mysql/Mysql/</url>
    
    <content type="html"><![CDATA[<h1 id="一数据类型">一、数据类型</h1><h2 id="数值类型">1. 数值类型</h2><h3 id="严格数值类型">1.1 严格数值类型</h3><table><thead><tr><th>类型</th><th>大小</th><th>范围</th></tr></thead><tbody><tr><td>TINYINT</td><td>1B</td><td>0-255</td></tr><tr><td>SMALLINT</td><td>2B</td><td>0-6 5535</td></tr><tr><td>MEDIUMINT</td><td>3B</td><td>0-16 777 215</td></tr><tr><td>INT（INTEGER）</td><td>4B</td><td>0-4 294 967 295</td></tr><tr><td>BIGINT</td><td>8B</td><td></td></tr><tr><td>DEC（DECIMAL）</td><td>对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2</td><td></td></tr></tbody></table><h3 id="近似数值类型">1.2 近似数值类型</h3><table><thead><tr><th>类型</th><th>大小</th><th>范围</th></tr></thead><tbody><tr><td>FLOAT</td><td>4B</td><td></td></tr><tr><td>DOUBLE</td><td>8B</td><td></td></tr></tbody></table><h2 id="日期和时间类型">2. 日期和时间类型</h2><table><thead><tr><th>类型</th><th>大小</th><th>范围</th><th>格式</th></tr></thead><tbody><tr><td>DATE</td><td>3B</td><td>1000-01-01/9999-12-31</td><td>YYYY-MM-DD</td></tr><tr><td>TIME</td><td>3B</td><td>'-838:59:59'/'838:59:59'</td><td>HH:MM:SS</td></tr><tr><td>YEAR</td><td>1B</td><td>1901/2155</td><td>YYYY</td></tr><tr><td>DATETIME</td><td>8B</td><td>'1000-01-01 00:00:00' 到 '9999-12-31 23:59:59'</td><td>YYYY-MM-DD hh:mm:ss</td></tr><tr><td>TIMESTAMP</td><td>4B</td><td>'1970-01-01 00:00:01' UTC 到 '2038-01-19 03:14:07' UTC</td><td>YYYY-MM-DD hh:mm:ss</td></tr></tbody></table><h2 id="字符串类型">3. 字符串类型</h2><table><thead><tr><th>类型</th><th>大小</th><th>用途</th></tr></thead><tbody><tr><td>CHAR</td><td>0-255 B</td><td>定长字符串</td></tr><tr><td>VARCHAR</td><td>0-65535 B</td><td>变长字符串</td></tr><tr><td>TINYBLOB</td><td>0-255 B</td><td>不超过 255 个字符的二进制字符串</td></tr><tr><td>TINYTEXT</td><td>0-255 B</td><td>短文本字符串</td></tr><tr><td>BLOB</td><td>0-65535 B</td><td>二进制形式的长文本数据</td></tr><tr><td>TEXT</td><td>0-65535 B</td><td>长文本数据</td></tr><tr><td>MEDIUMBLOB</td><td>0-65535 B</td><td>二进制形式的中等文本数据</td></tr><tr><td>MEDIUMTEXT</td><td>0-65535 B</td><td>中等文本数据</td></tr><tr><td>LONGBLOB</td><td>0-16 777 215 B</td><td>二进制形式的极大文本数据</td></tr><tr><td>LONGTEXT</td><td>0-16 777 215 B</td><td>极大文本数据</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>计算机技术</category>
      
      <category>Mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Technology</tag>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
